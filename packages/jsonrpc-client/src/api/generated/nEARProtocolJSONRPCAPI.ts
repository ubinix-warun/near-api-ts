/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * NEAR Protocol JSON RPC API
 * OpenAPI spec version: 1.0.0
 */
import { useMutation,
} from "@tanstack/react-query";
import type {
  MutationFunction,
  QueryClient,
  UseMutationOptions,
  UseMutationResult,
} from "@tanstack/react-query";

import type {
  JsonRpcRequestForBlock,
  JsonRpcRequestForBroadcastTxAsync,
  JsonRpcRequestForBroadcastTxCommit,
  JsonRpcRequestForChanges,
  JsonRpcRequestForChunk,
  JsonRpcRequestForClientConfig,
  JsonRpcRequestForEXPERIMENTALChanges,
  JsonRpcRequestForEXPERIMENTALChangesInBlock,
  JsonRpcRequestForEXPERIMENTALCongestionLevel,
  JsonRpcRequestForEXPERIMENTALGenesisConfig,
  JsonRpcRequestForEXPERIMENTALLightClientBlockProof,
  JsonRpcRequestForEXPERIMENTALLightClientProof,
  JsonRpcRequestForEXPERIMENTALMaintenanceWindows,
  JsonRpcRequestForEXPERIMENTALProtocolConfig,
  JsonRpcRequestForEXPERIMENTALReceipt,
  JsonRpcRequestForEXPERIMENTALSplitStorageInfo,
  JsonRpcRequestForEXPERIMENTALTxStatus,
  JsonRpcRequestForEXPERIMENTALValidatorsOrdered,
  JsonRpcRequestForGasPrice,
  JsonRpcRequestForHealth,
  JsonRpcRequestForLightClientProof,
  JsonRpcRequestForNetworkInfo,
  JsonRpcRequestForNextLightClientBlock,
  JsonRpcRequestForQuery,
  JsonRpcRequestForSendTx,
  JsonRpcRequestForStatus,
  JsonRpcRequestForTx,
  JsonRpcRequestForValidators,
  JsonRpcResponseForArrayOfRangeOfUint64AndRpcError,
  JsonRpcResponseForArrayOfValidatorStakeViewAndRpcError,
  JsonRpcResponseForCryptoHashAndRpcError,
  JsonRpcResponseForGenesisConfigAndRpcError,
  JsonRpcResponseForNullableRpcHealthResponseAndRpcError,
  JsonRpcResponseForRpcBlockResponseAndRpcError,
  JsonRpcResponseForRpcChunkResponseAndRpcError,
  JsonRpcResponseForRpcClientConfigResponseAndRpcError,
  JsonRpcResponseForRpcCongestionLevelResponseAndRpcError,
  JsonRpcResponseForRpcGasPriceResponseAndRpcError,
  JsonRpcResponseForRpcLightClientBlockProofResponseAndRpcError,
  JsonRpcResponseForRpcLightClientExecutionProofResponseAndRpcError,
  JsonRpcResponseForRpcLightClientNextBlockResponseAndRpcError,
  JsonRpcResponseForRpcNetworkInfoResponseAndRpcError,
  JsonRpcResponseForRpcProtocolConfigResponseAndRpcError,
  JsonRpcResponseForRpcQueryResponseAndRpcError,
  JsonRpcResponseForRpcReceiptResponseAndRpcError,
  JsonRpcResponseForRpcSplitStorageInfoResponseAndRpcError,
  JsonRpcResponseForRpcStateChangesInBlockByTypeResponseAndRpcError,
  JsonRpcResponseForRpcStateChangesInBlockResponseAndRpcError,
  JsonRpcResponseForRpcStatusResponseAndRpcError,
  JsonRpcResponseForRpcTransactionResponseAndRpcError,
  JsonRpcResponseForRpcValidatorResponseAndRpcError,
} from "@near-api-ts/jsonrpc-types/dist/model";

import { customInstance } from "../../client";
import type { ErrorType } from "../../client";

type AwaitedInput<T> = PromiseLike<T> | T;

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

export const eXPERIMENTALChanges = (
  jsonRpcRequestForEXPERIMENTALChanges: JsonRpcRequestForEXPERIMENTALChanges,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<JsonRpcResponseForRpcStateChangesInBlockResponseAndRpcError>(
    {
      url: `/EXPERIMENTAL_changes`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: jsonRpcRequestForEXPERIMENTALChanges,
      signal,
    },
    options,
  );
};

export const getEXPERIMENTALChangesMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof eXPERIMENTALChanges>>,
    TError,
    { data: JsonRpcRequestForEXPERIMENTALChanges },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof eXPERIMENTALChanges>>,
  TError,
  { data: JsonRpcRequestForEXPERIMENTALChanges },
  TContext
> => {
  const mutationKey = ["eXPERIMENTALChanges"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof eXPERIMENTALChanges>>,
    { data: JsonRpcRequestForEXPERIMENTALChanges }
  > = (props) => {
    const { data } = props ?? {};

    return eXPERIMENTALChanges(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type EXPERIMENTALChangesMutationResult = NonNullable<
  Awaited<ReturnType<typeof eXPERIMENTALChanges>>
>;
export type EXPERIMENTALChangesMutationBody =
  JsonRpcRequestForEXPERIMENTALChanges;
export type EXPERIMENTALChangesMutationError = ErrorType<unknown>;

export const useEXPERIMENTALChanges = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof eXPERIMENTALChanges>>,
      TError,
      { data: JsonRpcRequestForEXPERIMENTALChanges },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof eXPERIMENTALChanges>>,
  TError,
  { data: JsonRpcRequestForEXPERIMENTALChanges },
  TContext
> => {
  const mutationOptions = getEXPERIMENTALChangesMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const eXPERIMENTALChangesInBlock = (
  jsonRpcRequestForEXPERIMENTALChangesInBlock: JsonRpcRequestForEXPERIMENTALChangesInBlock,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<JsonRpcResponseForRpcStateChangesInBlockByTypeResponseAndRpcError>(
    {
      url: `/EXPERIMENTAL_changes_in_block`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: jsonRpcRequestForEXPERIMENTALChangesInBlock,
      signal,
    },
    options,
  );
};

export const getEXPERIMENTALChangesInBlockMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof eXPERIMENTALChangesInBlock>>,
    TError,
    { data: JsonRpcRequestForEXPERIMENTALChangesInBlock },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof eXPERIMENTALChangesInBlock>>,
  TError,
  { data: JsonRpcRequestForEXPERIMENTALChangesInBlock },
  TContext
> => {
  const mutationKey = ["eXPERIMENTALChangesInBlock"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof eXPERIMENTALChangesInBlock>>,
    { data: JsonRpcRequestForEXPERIMENTALChangesInBlock }
  > = (props) => {
    const { data } = props ?? {};

    return eXPERIMENTALChangesInBlock(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type EXPERIMENTALChangesInBlockMutationResult = NonNullable<
  Awaited<ReturnType<typeof eXPERIMENTALChangesInBlock>>
>;
export type EXPERIMENTALChangesInBlockMutationBody =
  JsonRpcRequestForEXPERIMENTALChangesInBlock;
export type EXPERIMENTALChangesInBlockMutationError = ErrorType<unknown>;

export const useEXPERIMENTALChangesInBlock = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof eXPERIMENTALChangesInBlock>>,
      TError,
      { data: JsonRpcRequestForEXPERIMENTALChangesInBlock },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof eXPERIMENTALChangesInBlock>>,
  TError,
  { data: JsonRpcRequestForEXPERIMENTALChangesInBlock },
  TContext
> => {
  const mutationOptions = getEXPERIMENTALChangesInBlockMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const eXPERIMENTALCongestionLevel = (
  jsonRpcRequestForEXPERIMENTALCongestionLevel: JsonRpcRequestForEXPERIMENTALCongestionLevel,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<JsonRpcResponseForRpcCongestionLevelResponseAndRpcError>(
    {
      url: `/EXPERIMENTAL_congestion_level`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: jsonRpcRequestForEXPERIMENTALCongestionLevel,
      signal,
    },
    options,
  );
};

export const getEXPERIMENTALCongestionLevelMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof eXPERIMENTALCongestionLevel>>,
    TError,
    { data: JsonRpcRequestForEXPERIMENTALCongestionLevel },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof eXPERIMENTALCongestionLevel>>,
  TError,
  { data: JsonRpcRequestForEXPERIMENTALCongestionLevel },
  TContext
> => {
  const mutationKey = ["eXPERIMENTALCongestionLevel"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof eXPERIMENTALCongestionLevel>>,
    { data: JsonRpcRequestForEXPERIMENTALCongestionLevel }
  > = (props) => {
    const { data } = props ?? {};

    return eXPERIMENTALCongestionLevel(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type EXPERIMENTALCongestionLevelMutationResult = NonNullable<
  Awaited<ReturnType<typeof eXPERIMENTALCongestionLevel>>
>;
export type EXPERIMENTALCongestionLevelMutationBody =
  JsonRpcRequestForEXPERIMENTALCongestionLevel;
export type EXPERIMENTALCongestionLevelMutationError = ErrorType<unknown>;

export const useEXPERIMENTALCongestionLevel = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof eXPERIMENTALCongestionLevel>>,
      TError,
      { data: JsonRpcRequestForEXPERIMENTALCongestionLevel },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof eXPERIMENTALCongestionLevel>>,
  TError,
  { data: JsonRpcRequestForEXPERIMENTALCongestionLevel },
  TContext
> => {
  const mutationOptions =
    getEXPERIMENTALCongestionLevelMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const eXPERIMENTALGenesisConfig = (
  jsonRpcRequestForEXPERIMENTALGenesisConfig: JsonRpcRequestForEXPERIMENTALGenesisConfig,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<JsonRpcResponseForGenesisConfigAndRpcError>(
    {
      url: `/EXPERIMENTAL_genesis_config`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: jsonRpcRequestForEXPERIMENTALGenesisConfig,
      signal,
    },
    options,
  );
};

export const getEXPERIMENTALGenesisConfigMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof eXPERIMENTALGenesisConfig>>,
    TError,
    { data: JsonRpcRequestForEXPERIMENTALGenesisConfig },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof eXPERIMENTALGenesisConfig>>,
  TError,
  { data: JsonRpcRequestForEXPERIMENTALGenesisConfig },
  TContext
> => {
  const mutationKey = ["eXPERIMENTALGenesisConfig"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof eXPERIMENTALGenesisConfig>>,
    { data: JsonRpcRequestForEXPERIMENTALGenesisConfig }
  > = (props) => {
    const { data } = props ?? {};

    return eXPERIMENTALGenesisConfig(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type EXPERIMENTALGenesisConfigMutationResult = NonNullable<
  Awaited<ReturnType<typeof eXPERIMENTALGenesisConfig>>
>;
export type EXPERIMENTALGenesisConfigMutationBody =
  JsonRpcRequestForEXPERIMENTALGenesisConfig;
export type EXPERIMENTALGenesisConfigMutationError = ErrorType<unknown>;

export const useEXPERIMENTALGenesisConfig = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof eXPERIMENTALGenesisConfig>>,
      TError,
      { data: JsonRpcRequestForEXPERIMENTALGenesisConfig },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof eXPERIMENTALGenesisConfig>>,
  TError,
  { data: JsonRpcRequestForEXPERIMENTALGenesisConfig },
  TContext
> => {
  const mutationOptions = getEXPERIMENTALGenesisConfigMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const eXPERIMENTALLightClientBlockProof = (
  jsonRpcRequestForEXPERIMENTALLightClientBlockProof: JsonRpcRequestForEXPERIMENTALLightClientBlockProof,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<JsonRpcResponseForRpcLightClientBlockProofResponseAndRpcError>(
    {
      url: `/EXPERIMENTAL_light_client_block_proof`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: jsonRpcRequestForEXPERIMENTALLightClientBlockProof,
      signal,
    },
    options,
  );
};

export const getEXPERIMENTALLightClientBlockProofMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof eXPERIMENTALLightClientBlockProof>>,
    TError,
    { data: JsonRpcRequestForEXPERIMENTALLightClientBlockProof },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof eXPERIMENTALLightClientBlockProof>>,
  TError,
  { data: JsonRpcRequestForEXPERIMENTALLightClientBlockProof },
  TContext
> => {
  const mutationKey = ["eXPERIMENTALLightClientBlockProof"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof eXPERIMENTALLightClientBlockProof>>,
    { data: JsonRpcRequestForEXPERIMENTALLightClientBlockProof }
  > = (props) => {
    const { data } = props ?? {};

    return eXPERIMENTALLightClientBlockProof(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type EXPERIMENTALLightClientBlockProofMutationResult = NonNullable<
  Awaited<ReturnType<typeof eXPERIMENTALLightClientBlockProof>>
>;
export type EXPERIMENTALLightClientBlockProofMutationBody =
  JsonRpcRequestForEXPERIMENTALLightClientBlockProof;
export type EXPERIMENTALLightClientBlockProofMutationError = ErrorType<unknown>;

export const useEXPERIMENTALLightClientBlockProof = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof eXPERIMENTALLightClientBlockProof>>,
      TError,
      { data: JsonRpcRequestForEXPERIMENTALLightClientBlockProof },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof eXPERIMENTALLightClientBlockProof>>,
  TError,
  { data: JsonRpcRequestForEXPERIMENTALLightClientBlockProof },
  TContext
> => {
  const mutationOptions =
    getEXPERIMENTALLightClientBlockProofMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const eXPERIMENTALLightClientProof = (
  jsonRpcRequestForEXPERIMENTALLightClientProof: JsonRpcRequestForEXPERIMENTALLightClientProof,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<JsonRpcResponseForRpcLightClientExecutionProofResponseAndRpcError>(
    {
      url: `/EXPERIMENTAL_light_client_proof`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: jsonRpcRequestForEXPERIMENTALLightClientProof,
      signal,
    },
    options,
  );
};

export const getEXPERIMENTALLightClientProofMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof eXPERIMENTALLightClientProof>>,
    TError,
    { data: JsonRpcRequestForEXPERIMENTALLightClientProof },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof eXPERIMENTALLightClientProof>>,
  TError,
  { data: JsonRpcRequestForEXPERIMENTALLightClientProof },
  TContext
> => {
  const mutationKey = ["eXPERIMENTALLightClientProof"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof eXPERIMENTALLightClientProof>>,
    { data: JsonRpcRequestForEXPERIMENTALLightClientProof }
  > = (props) => {
    const { data } = props ?? {};

    return eXPERIMENTALLightClientProof(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type EXPERIMENTALLightClientProofMutationResult = NonNullable<
  Awaited<ReturnType<typeof eXPERIMENTALLightClientProof>>
>;
export type EXPERIMENTALLightClientProofMutationBody =
  JsonRpcRequestForEXPERIMENTALLightClientProof;
export type EXPERIMENTALLightClientProofMutationError = ErrorType<unknown>;

export const useEXPERIMENTALLightClientProof = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof eXPERIMENTALLightClientProof>>,
      TError,
      { data: JsonRpcRequestForEXPERIMENTALLightClientProof },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof eXPERIMENTALLightClientProof>>,
  TError,
  { data: JsonRpcRequestForEXPERIMENTALLightClientProof },
  TContext
> => {
  const mutationOptions =
    getEXPERIMENTALLightClientProofMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const eXPERIMENTALMaintenanceWindows = (
  jsonRpcRequestForEXPERIMENTALMaintenanceWindows: JsonRpcRequestForEXPERIMENTALMaintenanceWindows,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<JsonRpcResponseForArrayOfRangeOfUint64AndRpcError>(
    {
      url: `/EXPERIMENTAL_maintenance_windows`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: jsonRpcRequestForEXPERIMENTALMaintenanceWindows,
      signal,
    },
    options,
  );
};

export const getEXPERIMENTALMaintenanceWindowsMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof eXPERIMENTALMaintenanceWindows>>,
    TError,
    { data: JsonRpcRequestForEXPERIMENTALMaintenanceWindows },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof eXPERIMENTALMaintenanceWindows>>,
  TError,
  { data: JsonRpcRequestForEXPERIMENTALMaintenanceWindows },
  TContext
> => {
  const mutationKey = ["eXPERIMENTALMaintenanceWindows"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof eXPERIMENTALMaintenanceWindows>>,
    { data: JsonRpcRequestForEXPERIMENTALMaintenanceWindows }
  > = (props) => {
    const { data } = props ?? {};

    return eXPERIMENTALMaintenanceWindows(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type EXPERIMENTALMaintenanceWindowsMutationResult = NonNullable<
  Awaited<ReturnType<typeof eXPERIMENTALMaintenanceWindows>>
>;
export type EXPERIMENTALMaintenanceWindowsMutationBody =
  JsonRpcRequestForEXPERIMENTALMaintenanceWindows;
export type EXPERIMENTALMaintenanceWindowsMutationError = ErrorType<unknown>;

export const useEXPERIMENTALMaintenanceWindows = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof eXPERIMENTALMaintenanceWindows>>,
      TError,
      { data: JsonRpcRequestForEXPERIMENTALMaintenanceWindows },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof eXPERIMENTALMaintenanceWindows>>,
  TError,
  { data: JsonRpcRequestForEXPERIMENTALMaintenanceWindows },
  TContext
> => {
  const mutationOptions =
    getEXPERIMENTALMaintenanceWindowsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const eXPERIMENTALProtocolConfig = (
  jsonRpcRequestForEXPERIMENTALProtocolConfig: JsonRpcRequestForEXPERIMENTALProtocolConfig,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<JsonRpcResponseForRpcProtocolConfigResponseAndRpcError>(
    {
      url: `/EXPERIMENTAL_protocol_config`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: jsonRpcRequestForEXPERIMENTALProtocolConfig,
      signal,
    },
    options,
  );
};

export const getEXPERIMENTALProtocolConfigMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof eXPERIMENTALProtocolConfig>>,
    TError,
    { data: JsonRpcRequestForEXPERIMENTALProtocolConfig },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof eXPERIMENTALProtocolConfig>>,
  TError,
  { data: JsonRpcRequestForEXPERIMENTALProtocolConfig },
  TContext
> => {
  const mutationKey = ["eXPERIMENTALProtocolConfig"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof eXPERIMENTALProtocolConfig>>,
    { data: JsonRpcRequestForEXPERIMENTALProtocolConfig }
  > = (props) => {
    const { data } = props ?? {};

    return eXPERIMENTALProtocolConfig(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type EXPERIMENTALProtocolConfigMutationResult = NonNullable<
  Awaited<ReturnType<typeof eXPERIMENTALProtocolConfig>>
>;
export type EXPERIMENTALProtocolConfigMutationBody =
  JsonRpcRequestForEXPERIMENTALProtocolConfig;
export type EXPERIMENTALProtocolConfigMutationError = ErrorType<unknown>;

export const useEXPERIMENTALProtocolConfig = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof eXPERIMENTALProtocolConfig>>,
      TError,
      { data: JsonRpcRequestForEXPERIMENTALProtocolConfig },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof eXPERIMENTALProtocolConfig>>,
  TError,
  { data: JsonRpcRequestForEXPERIMENTALProtocolConfig },
  TContext
> => {
  const mutationOptions = getEXPERIMENTALProtocolConfigMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const eXPERIMENTALReceipt = (
  jsonRpcRequestForEXPERIMENTALReceipt: JsonRpcRequestForEXPERIMENTALReceipt,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<JsonRpcResponseForRpcReceiptResponseAndRpcError>(
    {
      url: `/EXPERIMENTAL_receipt`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: jsonRpcRequestForEXPERIMENTALReceipt,
      signal,
    },
    options,
  );
};

export const getEXPERIMENTALReceiptMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof eXPERIMENTALReceipt>>,
    TError,
    { data: JsonRpcRequestForEXPERIMENTALReceipt },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof eXPERIMENTALReceipt>>,
  TError,
  { data: JsonRpcRequestForEXPERIMENTALReceipt },
  TContext
> => {
  const mutationKey = ["eXPERIMENTALReceipt"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof eXPERIMENTALReceipt>>,
    { data: JsonRpcRequestForEXPERIMENTALReceipt }
  > = (props) => {
    const { data } = props ?? {};

    return eXPERIMENTALReceipt(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type EXPERIMENTALReceiptMutationResult = NonNullable<
  Awaited<ReturnType<typeof eXPERIMENTALReceipt>>
>;
export type EXPERIMENTALReceiptMutationBody =
  JsonRpcRequestForEXPERIMENTALReceipt;
export type EXPERIMENTALReceiptMutationError = ErrorType<unknown>;

export const useEXPERIMENTALReceipt = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof eXPERIMENTALReceipt>>,
      TError,
      { data: JsonRpcRequestForEXPERIMENTALReceipt },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof eXPERIMENTALReceipt>>,
  TError,
  { data: JsonRpcRequestForEXPERIMENTALReceipt },
  TContext
> => {
  const mutationOptions = getEXPERIMENTALReceiptMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const eXPERIMENTALSplitStorageInfo = (
  jsonRpcRequestForEXPERIMENTALSplitStorageInfo: JsonRpcRequestForEXPERIMENTALSplitStorageInfo,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<JsonRpcResponseForRpcSplitStorageInfoResponseAndRpcError>(
    {
      url: `/EXPERIMENTAL_split_storage_info`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: jsonRpcRequestForEXPERIMENTALSplitStorageInfo,
      signal,
    },
    options,
  );
};

export const getEXPERIMENTALSplitStorageInfoMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof eXPERIMENTALSplitStorageInfo>>,
    TError,
    { data: JsonRpcRequestForEXPERIMENTALSplitStorageInfo },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof eXPERIMENTALSplitStorageInfo>>,
  TError,
  { data: JsonRpcRequestForEXPERIMENTALSplitStorageInfo },
  TContext
> => {
  const mutationKey = ["eXPERIMENTALSplitStorageInfo"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof eXPERIMENTALSplitStorageInfo>>,
    { data: JsonRpcRequestForEXPERIMENTALSplitStorageInfo }
  > = (props) => {
    const { data } = props ?? {};

    return eXPERIMENTALSplitStorageInfo(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type EXPERIMENTALSplitStorageInfoMutationResult = NonNullable<
  Awaited<ReturnType<typeof eXPERIMENTALSplitStorageInfo>>
>;
export type EXPERIMENTALSplitStorageInfoMutationBody =
  JsonRpcRequestForEXPERIMENTALSplitStorageInfo;
export type EXPERIMENTALSplitStorageInfoMutationError = ErrorType<unknown>;

export const useEXPERIMENTALSplitStorageInfo = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof eXPERIMENTALSplitStorageInfo>>,
      TError,
      { data: JsonRpcRequestForEXPERIMENTALSplitStorageInfo },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof eXPERIMENTALSplitStorageInfo>>,
  TError,
  { data: JsonRpcRequestForEXPERIMENTALSplitStorageInfo },
  TContext
> => {
  const mutationOptions =
    getEXPERIMENTALSplitStorageInfoMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const eXPERIMENTALTxStatus = (
  jsonRpcRequestForEXPERIMENTALTxStatus: JsonRpcRequestForEXPERIMENTALTxStatus,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<JsonRpcResponseForRpcTransactionResponseAndRpcError>(
    {
      url: `/EXPERIMENTAL_tx_status`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: jsonRpcRequestForEXPERIMENTALTxStatus,
      signal,
    },
    options,
  );
};

export const getEXPERIMENTALTxStatusMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof eXPERIMENTALTxStatus>>,
    TError,
    { data: JsonRpcRequestForEXPERIMENTALTxStatus },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof eXPERIMENTALTxStatus>>,
  TError,
  { data: JsonRpcRequestForEXPERIMENTALTxStatus },
  TContext
> => {
  const mutationKey = ["eXPERIMENTALTxStatus"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof eXPERIMENTALTxStatus>>,
    { data: JsonRpcRequestForEXPERIMENTALTxStatus }
  > = (props) => {
    const { data } = props ?? {};

    return eXPERIMENTALTxStatus(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type EXPERIMENTALTxStatusMutationResult = NonNullable<
  Awaited<ReturnType<typeof eXPERIMENTALTxStatus>>
>;
export type EXPERIMENTALTxStatusMutationBody =
  JsonRpcRequestForEXPERIMENTALTxStatus;
export type EXPERIMENTALTxStatusMutationError = ErrorType<unknown>;

export const useEXPERIMENTALTxStatus = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof eXPERIMENTALTxStatus>>,
      TError,
      { data: JsonRpcRequestForEXPERIMENTALTxStatus },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof eXPERIMENTALTxStatus>>,
  TError,
  { data: JsonRpcRequestForEXPERIMENTALTxStatus },
  TContext
> => {
  const mutationOptions = getEXPERIMENTALTxStatusMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const eXPERIMENTALValidatorsOrdered = (
  jsonRpcRequestForEXPERIMENTALValidatorsOrdered: JsonRpcRequestForEXPERIMENTALValidatorsOrdered,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<JsonRpcResponseForArrayOfValidatorStakeViewAndRpcError>(
    {
      url: `/EXPERIMENTAL_validators_ordered`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: jsonRpcRequestForEXPERIMENTALValidatorsOrdered,
      signal,
    },
    options,
  );
};

export const getEXPERIMENTALValidatorsOrderedMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof eXPERIMENTALValidatorsOrdered>>,
    TError,
    { data: JsonRpcRequestForEXPERIMENTALValidatorsOrdered },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof eXPERIMENTALValidatorsOrdered>>,
  TError,
  { data: JsonRpcRequestForEXPERIMENTALValidatorsOrdered },
  TContext
> => {
  const mutationKey = ["eXPERIMENTALValidatorsOrdered"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof eXPERIMENTALValidatorsOrdered>>,
    { data: JsonRpcRequestForEXPERIMENTALValidatorsOrdered }
  > = (props) => {
    const { data } = props ?? {};

    return eXPERIMENTALValidatorsOrdered(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type EXPERIMENTALValidatorsOrderedMutationResult = NonNullable<
  Awaited<ReturnType<typeof eXPERIMENTALValidatorsOrdered>>
>;
export type EXPERIMENTALValidatorsOrderedMutationBody =
  JsonRpcRequestForEXPERIMENTALValidatorsOrdered;
export type EXPERIMENTALValidatorsOrderedMutationError = ErrorType<unknown>;

export const useEXPERIMENTALValidatorsOrdered = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof eXPERIMENTALValidatorsOrdered>>,
      TError,
      { data: JsonRpcRequestForEXPERIMENTALValidatorsOrdered },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof eXPERIMENTALValidatorsOrdered>>,
  TError,
  { data: JsonRpcRequestForEXPERIMENTALValidatorsOrdered },
  TContext
> => {
  const mutationOptions =
    getEXPERIMENTALValidatorsOrderedMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const block = (
  jsonRpcRequestForBlock: JsonRpcRequestForBlock,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<JsonRpcResponseForRpcBlockResponseAndRpcError>(
    {
      url: `/block`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: jsonRpcRequestForBlock,
      signal,
    },
    options,
  );
};

export const getBlockMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof block>>,
    TError,
    { data: JsonRpcRequestForBlock },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof block>>,
  TError,
  { data: JsonRpcRequestForBlock },
  TContext
> => {
  const mutationKey = ["block"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof block>>,
    { data: JsonRpcRequestForBlock }
  > = (props) => {
    const { data } = props ?? {};

    return block(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type BlockMutationResult = NonNullable<
  Awaited<ReturnType<typeof block>>
>;
export type BlockMutationBody = JsonRpcRequestForBlock;
export type BlockMutationError = ErrorType<unknown>;

export const useBlock = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof block>>,
      TError,
      { data: JsonRpcRequestForBlock },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof block>>,
  TError,
  { data: JsonRpcRequestForBlock },
  TContext
> => {
  const mutationOptions = getBlockMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const broadcastTxAsync = (
  jsonRpcRequestForBroadcastTxAsync: JsonRpcRequestForBroadcastTxAsync,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<JsonRpcResponseForCryptoHashAndRpcError>(
    {
      url: `/broadcast_tx_async`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: jsonRpcRequestForBroadcastTxAsync,
      signal,
    },
    options,
  );
};

export const getBroadcastTxAsyncMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof broadcastTxAsync>>,
    TError,
    { data: JsonRpcRequestForBroadcastTxAsync },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof broadcastTxAsync>>,
  TError,
  { data: JsonRpcRequestForBroadcastTxAsync },
  TContext
> => {
  const mutationKey = ["broadcastTxAsync"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof broadcastTxAsync>>,
    { data: JsonRpcRequestForBroadcastTxAsync }
  > = (props) => {
    const { data } = props ?? {};

    return broadcastTxAsync(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type BroadcastTxAsyncMutationResult = NonNullable<
  Awaited<ReturnType<typeof broadcastTxAsync>>
>;
export type BroadcastTxAsyncMutationBody = JsonRpcRequestForBroadcastTxAsync;
export type BroadcastTxAsyncMutationError = ErrorType<unknown>;

export const useBroadcastTxAsync = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof broadcastTxAsync>>,
      TError,
      { data: JsonRpcRequestForBroadcastTxAsync },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof broadcastTxAsync>>,
  TError,
  { data: JsonRpcRequestForBroadcastTxAsync },
  TContext
> => {
  const mutationOptions = getBroadcastTxAsyncMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const broadcastTxCommit = (
  jsonRpcRequestForBroadcastTxCommit: JsonRpcRequestForBroadcastTxCommit,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<JsonRpcResponseForRpcTransactionResponseAndRpcError>(
    {
      url: `/broadcast_tx_commit`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: jsonRpcRequestForBroadcastTxCommit,
      signal,
    },
    options,
  );
};

export const getBroadcastTxCommitMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof broadcastTxCommit>>,
    TError,
    { data: JsonRpcRequestForBroadcastTxCommit },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof broadcastTxCommit>>,
  TError,
  { data: JsonRpcRequestForBroadcastTxCommit },
  TContext
> => {
  const mutationKey = ["broadcastTxCommit"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof broadcastTxCommit>>,
    { data: JsonRpcRequestForBroadcastTxCommit }
  > = (props) => {
    const { data } = props ?? {};

    return broadcastTxCommit(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type BroadcastTxCommitMutationResult = NonNullable<
  Awaited<ReturnType<typeof broadcastTxCommit>>
>;
export type BroadcastTxCommitMutationBody = JsonRpcRequestForBroadcastTxCommit;
export type BroadcastTxCommitMutationError = ErrorType<unknown>;

export const useBroadcastTxCommit = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof broadcastTxCommit>>,
      TError,
      { data: JsonRpcRequestForBroadcastTxCommit },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof broadcastTxCommit>>,
  TError,
  { data: JsonRpcRequestForBroadcastTxCommit },
  TContext
> => {
  const mutationOptions = getBroadcastTxCommitMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const changes = (
  jsonRpcRequestForChanges: JsonRpcRequestForChanges,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<JsonRpcResponseForRpcStateChangesInBlockResponseAndRpcError>(
    {
      url: `/changes`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: jsonRpcRequestForChanges,
      signal,
    },
    options,
  );
};

export const getChangesMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof changes>>,
    TError,
    { data: JsonRpcRequestForChanges },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof changes>>,
  TError,
  { data: JsonRpcRequestForChanges },
  TContext
> => {
  const mutationKey = ["changes"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof changes>>,
    { data: JsonRpcRequestForChanges }
  > = (props) => {
    const { data } = props ?? {};

    return changes(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ChangesMutationResult = NonNullable<
  Awaited<ReturnType<typeof changes>>
>;
export type ChangesMutationBody = JsonRpcRequestForChanges;
export type ChangesMutationError = ErrorType<unknown>;

export const useChanges = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof changes>>,
      TError,
      { data: JsonRpcRequestForChanges },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof changes>>,
  TError,
  { data: JsonRpcRequestForChanges },
  TContext
> => {
  const mutationOptions = getChangesMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const chunk = (
  jsonRpcRequestForChunk: JsonRpcRequestForChunk,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<JsonRpcResponseForRpcChunkResponseAndRpcError>(
    {
      url: `/chunk`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: jsonRpcRequestForChunk,
      signal,
    },
    options,
  );
};

export const getChunkMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof chunk>>,
    TError,
    { data: JsonRpcRequestForChunk },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof chunk>>,
  TError,
  { data: JsonRpcRequestForChunk },
  TContext
> => {
  const mutationKey = ["chunk"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof chunk>>,
    { data: JsonRpcRequestForChunk }
  > = (props) => {
    const { data } = props ?? {};

    return chunk(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ChunkMutationResult = NonNullable<
  Awaited<ReturnType<typeof chunk>>
>;
export type ChunkMutationBody = JsonRpcRequestForChunk;
export type ChunkMutationError = ErrorType<unknown>;

export const useChunk = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof chunk>>,
      TError,
      { data: JsonRpcRequestForChunk },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof chunk>>,
  TError,
  { data: JsonRpcRequestForChunk },
  TContext
> => {
  const mutationOptions = getChunkMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const clientConfig = (
  jsonRpcRequestForClientConfig: JsonRpcRequestForClientConfig,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<JsonRpcResponseForRpcClientConfigResponseAndRpcError>(
    {
      url: `/client_config`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: jsonRpcRequestForClientConfig,
      signal,
    },
    options,
  );
};

export const getClientConfigMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof clientConfig>>,
    TError,
    { data: JsonRpcRequestForClientConfig },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof clientConfig>>,
  TError,
  { data: JsonRpcRequestForClientConfig },
  TContext
> => {
  const mutationKey = ["clientConfig"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof clientConfig>>,
    { data: JsonRpcRequestForClientConfig }
  > = (props) => {
    const { data } = props ?? {};

    return clientConfig(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ClientConfigMutationResult = NonNullable<
  Awaited<ReturnType<typeof clientConfig>>
>;
export type ClientConfigMutationBody = JsonRpcRequestForClientConfig;
export type ClientConfigMutationError = ErrorType<unknown>;

export const useClientConfig = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof clientConfig>>,
      TError,
      { data: JsonRpcRequestForClientConfig },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof clientConfig>>,
  TError,
  { data: JsonRpcRequestForClientConfig },
  TContext
> => {
  const mutationOptions = getClientConfigMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const gasPrice = (
  jsonRpcRequestForGasPrice: JsonRpcRequestForGasPrice,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<JsonRpcResponseForRpcGasPriceResponseAndRpcError>(
    {
      url: `/gas_price`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: jsonRpcRequestForGasPrice,
      signal,
    },
    options,
  );
};

export const getGasPriceMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof gasPrice>>,
    TError,
    { data: JsonRpcRequestForGasPrice },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof gasPrice>>,
  TError,
  { data: JsonRpcRequestForGasPrice },
  TContext
> => {
  const mutationKey = ["gasPrice"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof gasPrice>>,
    { data: JsonRpcRequestForGasPrice }
  > = (props) => {
    const { data } = props ?? {};

    return gasPrice(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type GasPriceMutationResult = NonNullable<
  Awaited<ReturnType<typeof gasPrice>>
>;
export type GasPriceMutationBody = JsonRpcRequestForGasPrice;
export type GasPriceMutationError = ErrorType<unknown>;

export const useGasPrice = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof gasPrice>>,
      TError,
      { data: JsonRpcRequestForGasPrice },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof gasPrice>>,
  TError,
  { data: JsonRpcRequestForGasPrice },
  TContext
> => {
  const mutationOptions = getGasPriceMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const health = (
  jsonRpcRequestForHealth: JsonRpcRequestForHealth,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<JsonRpcResponseForNullableRpcHealthResponseAndRpcError>(
    {
      url: `/health`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: jsonRpcRequestForHealth,
      signal,
    },
    options,
  );
};

export const getHealthMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof health>>,
    TError,
    { data: JsonRpcRequestForHealth },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof health>>,
  TError,
  { data: JsonRpcRequestForHealth },
  TContext
> => {
  const mutationKey = ["health"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof health>>,
    { data: JsonRpcRequestForHealth }
  > = (props) => {
    const { data } = props ?? {};

    return health(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type HealthMutationResult = NonNullable<
  Awaited<ReturnType<typeof health>>
>;
export type HealthMutationBody = JsonRpcRequestForHealth;
export type HealthMutationError = ErrorType<unknown>;

export const useHealth = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof health>>,
      TError,
      { data: JsonRpcRequestForHealth },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof health>>,
  TError,
  { data: JsonRpcRequestForHealth },
  TContext
> => {
  const mutationOptions = getHealthMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const lightClientProof = (
  jsonRpcRequestForLightClientProof: JsonRpcRequestForLightClientProof,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<JsonRpcResponseForRpcLightClientExecutionProofResponseAndRpcError>(
    {
      url: `/light_client_proof`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: jsonRpcRequestForLightClientProof,
      signal,
    },
    options,
  );
};

export const getLightClientProofMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof lightClientProof>>,
    TError,
    { data: JsonRpcRequestForLightClientProof },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof lightClientProof>>,
  TError,
  { data: JsonRpcRequestForLightClientProof },
  TContext
> => {
  const mutationKey = ["lightClientProof"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof lightClientProof>>,
    { data: JsonRpcRequestForLightClientProof }
  > = (props) => {
    const { data } = props ?? {};

    return lightClientProof(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type LightClientProofMutationResult = NonNullable<
  Awaited<ReturnType<typeof lightClientProof>>
>;
export type LightClientProofMutationBody = JsonRpcRequestForLightClientProof;
export type LightClientProofMutationError = ErrorType<unknown>;

export const useLightClientProof = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof lightClientProof>>,
      TError,
      { data: JsonRpcRequestForLightClientProof },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof lightClientProof>>,
  TError,
  { data: JsonRpcRequestForLightClientProof },
  TContext
> => {
  const mutationOptions = getLightClientProofMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const networkInfo = (
  jsonRpcRequestForNetworkInfo: JsonRpcRequestForNetworkInfo,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<JsonRpcResponseForRpcNetworkInfoResponseAndRpcError>(
    {
      url: `/network_info`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: jsonRpcRequestForNetworkInfo,
      signal,
    },
    options,
  );
};

export const getNetworkInfoMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof networkInfo>>,
    TError,
    { data: JsonRpcRequestForNetworkInfo },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof networkInfo>>,
  TError,
  { data: JsonRpcRequestForNetworkInfo },
  TContext
> => {
  const mutationKey = ["networkInfo"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof networkInfo>>,
    { data: JsonRpcRequestForNetworkInfo }
  > = (props) => {
    const { data } = props ?? {};

    return networkInfo(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type NetworkInfoMutationResult = NonNullable<
  Awaited<ReturnType<typeof networkInfo>>
>;
export type NetworkInfoMutationBody = JsonRpcRequestForNetworkInfo;
export type NetworkInfoMutationError = ErrorType<unknown>;

export const useNetworkInfo = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof networkInfo>>,
      TError,
      { data: JsonRpcRequestForNetworkInfo },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof networkInfo>>,
  TError,
  { data: JsonRpcRequestForNetworkInfo },
  TContext
> => {
  const mutationOptions = getNetworkInfoMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const nextLightClientBlock = (
  jsonRpcRequestForNextLightClientBlock: JsonRpcRequestForNextLightClientBlock,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<JsonRpcResponseForRpcLightClientNextBlockResponseAndRpcError>(
    {
      url: `/next_light_client_block`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: jsonRpcRequestForNextLightClientBlock,
      signal,
    },
    options,
  );
};

export const getNextLightClientBlockMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof nextLightClientBlock>>,
    TError,
    { data: JsonRpcRequestForNextLightClientBlock },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof nextLightClientBlock>>,
  TError,
  { data: JsonRpcRequestForNextLightClientBlock },
  TContext
> => {
  const mutationKey = ["nextLightClientBlock"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof nextLightClientBlock>>,
    { data: JsonRpcRequestForNextLightClientBlock }
  > = (props) => {
    const { data } = props ?? {};

    return nextLightClientBlock(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type NextLightClientBlockMutationResult = NonNullable<
  Awaited<ReturnType<typeof nextLightClientBlock>>
>;
export type NextLightClientBlockMutationBody =
  JsonRpcRequestForNextLightClientBlock;
export type NextLightClientBlockMutationError = ErrorType<unknown>;

export const useNextLightClientBlock = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof nextLightClientBlock>>,
      TError,
      { data: JsonRpcRequestForNextLightClientBlock },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof nextLightClientBlock>>,
  TError,
  { data: JsonRpcRequestForNextLightClientBlock },
  TContext
> => {
  const mutationOptions = getNextLightClientBlockMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const query = (
  jsonRpcRequestForQuery: JsonRpcRequestForQuery,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<JsonRpcResponseForRpcQueryResponseAndRpcError>(
    {
      url: `/query`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: jsonRpcRequestForQuery,
      signal,
    },
    options,
  );
};

export const getQueryMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof query>>,
    TError,
    { data: JsonRpcRequestForQuery },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof query>>,
  TError,
  { data: JsonRpcRequestForQuery },
  TContext
> => {
  const mutationKey = ["query"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof query>>,
    { data: JsonRpcRequestForQuery }
  > = (props) => {
    const { data } = props ?? {};

    return query(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type QueryMutationResult = NonNullable<
  Awaited<ReturnType<typeof query>>
>;
export type QueryMutationBody = JsonRpcRequestForQuery;
export type QueryMutationError = ErrorType<unknown>;

export const useQuery = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof query>>,
      TError,
      { data: JsonRpcRequestForQuery },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof query>>,
  TError,
  { data: JsonRpcRequestForQuery },
  TContext
> => {
  const mutationOptions = getQueryMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const sendTx = (
  jsonRpcRequestForSendTx: JsonRpcRequestForSendTx,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<JsonRpcResponseForRpcTransactionResponseAndRpcError>(
    {
      url: `/send_tx`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: jsonRpcRequestForSendTx,
      signal,
    },
    options,
  );
};

export const getSendTxMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sendTx>>,
    TError,
    { data: JsonRpcRequestForSendTx },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sendTx>>,
  TError,
  { data: JsonRpcRequestForSendTx },
  TContext
> => {
  const mutationKey = ["sendTx"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sendTx>>,
    { data: JsonRpcRequestForSendTx }
  > = (props) => {
    const { data } = props ?? {};

    return sendTx(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type SendTxMutationResult = NonNullable<
  Awaited<ReturnType<typeof sendTx>>
>;
export type SendTxMutationBody = JsonRpcRequestForSendTx;
export type SendTxMutationError = ErrorType<unknown>;

export const useSendTx = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sendTx>>,
      TError,
      { data: JsonRpcRequestForSendTx },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof sendTx>>,
  TError,
  { data: JsonRpcRequestForSendTx },
  TContext
> => {
  const mutationOptions = getSendTxMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const status = (
  jsonRpcRequestForStatus: JsonRpcRequestForStatus,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<JsonRpcResponseForRpcStatusResponseAndRpcError>(
    {
      url: `/status`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: jsonRpcRequestForStatus,
      signal,
    },
    options,
  );
};

export const getStatusMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof status>>,
    TError,
    { data: JsonRpcRequestForStatus },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof status>>,
  TError,
  { data: JsonRpcRequestForStatus },
  TContext
> => {
  const mutationKey = ["status"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof status>>,
    { data: JsonRpcRequestForStatus }
  > = (props) => {
    const { data } = props ?? {};

    return status(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type StatusMutationResult = NonNullable<
  Awaited<ReturnType<typeof status>>
>;
export type StatusMutationBody = JsonRpcRequestForStatus;
export type StatusMutationError = ErrorType<unknown>;

export const useStatus = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof status>>,
      TError,
      { data: JsonRpcRequestForStatus },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof status>>,
  TError,
  { data: JsonRpcRequestForStatus },
  TContext
> => {
  const mutationOptions = getStatusMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const tx = (
  jsonRpcRequestForTx: JsonRpcRequestForTx,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<JsonRpcResponseForRpcTransactionResponseAndRpcError>(
    {
      url: `/tx`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: jsonRpcRequestForTx,
      signal,
    },
    options,
  );
};

export const getTxMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof tx>>,
    TError,
    { data: JsonRpcRequestForTx },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof tx>>,
  TError,
  { data: JsonRpcRequestForTx },
  TContext
> => {
  const mutationKey = ["tx"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof tx>>,
    { data: JsonRpcRequestForTx }
  > = (props) => {
    const { data } = props ?? {};

    return tx(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type TxMutationResult = NonNullable<Awaited<ReturnType<typeof tx>>>;
export type TxMutationBody = JsonRpcRequestForTx;
export type TxMutationError = ErrorType<unknown>;

export const useTx = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof tx>>,
      TError,
      { data: JsonRpcRequestForTx },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof tx>>,
  TError,
  { data: JsonRpcRequestForTx },
  TContext
> => {
  const mutationOptions = getTxMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const validators = (
  jsonRpcRequestForValidators: JsonRpcRequestForValidators,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<JsonRpcResponseForRpcValidatorResponseAndRpcError>(
    {
      url: `/validators`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: jsonRpcRequestForValidators,
      signal,
    },
    options,
  );
};

export const getValidatorsMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof validators>>,
    TError,
    { data: JsonRpcRequestForValidators },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof validators>>,
  TError,
  { data: JsonRpcRequestForValidators },
  TContext
> => {
  const mutationKey = ["validators"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof validators>>,
    { data: JsonRpcRequestForValidators }
  > = (props) => {
    const { data } = props ?? {};

    return validators(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ValidatorsMutationResult = NonNullable<
  Awaited<ReturnType<typeof validators>>
>;
export type ValidatorsMutationBody = JsonRpcRequestForValidators;
export type ValidatorsMutationError = ErrorType<unknown>;

export const useValidators = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof validators>>,
      TError,
      { data: JsonRpcRequestForValidators },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof validators>>,
  TError,
  { data: JsonRpcRequestForValidators },
  TContext
> => {
  const mutationOptions = getValidatorsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
