/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * NEAR Protocol JSON RPC API
 * OpenAPI spec version: 1.0.0
 */
import {
  z as zod
} from 'zod';


export const eXPERIMENTALChangesBodyParamsBlockIdMinOne = 0;


export const eXPERIMENTALChangesBody = zod.object({
  "id": zod.string(),
  "jsonrpc": zod.string(),
  "method": zod.enum(['EXPERIMENTAL_changes']),
  "params": zod.object({
  "block_id": zod.number().min(eXPERIMENTALChangesBodyParamsBlockIdMinOne).or(zod.string())
}).or(zod.object({
  "finality": zod.enum(['optimistic', 'near-final', 'final']).describe('Different types of finality.')
})).or(zod.object({
  "sync_checkpoint": zod.enum(['genesis', 'earliest_available'])
})).and(zod.object({
  "account_ids": zod.array(zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')),
  "changes_type": zod.enum(['account_changes'])
}).or(zod.object({
  "changes_type": zod.enum(['single_access_key_changes']),
  "keys": zod.array(zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
}))
})).or(zod.object({
  "changes_type": zod.enum(['single_gas_key_changes']),
  "keys": zod.array(zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
}))
})).or(zod.object({
  "account_ids": zod.array(zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')),
  "changes_type": zod.enum(['all_access_key_changes'])
})).or(zod.object({
  "account_ids": zod.array(zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')),
  "changes_type": zod.enum(['all_gas_key_changes'])
})).or(zod.object({
  "account_ids": zod.array(zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')),
  "changes_type": zod.enum(['contract_code_changes'])
})).or(zod.object({
  "account_ids": zod.array(zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')),
  "changes_type": zod.enum(['data_changes']),
  "key_prefix_base64": zod.string()
}))).describe('It is a [serializable view] of [`StateChangesRequest`].\n\n [serializable view]: ./index.html\n [`StateChangesRequest`]: ../types/struct.StateChangesRequest.html')
})

export const eXPERIMENTALChangesResponseResultChangesItemChangeStoragePaidAtDefault = 0;
export const eXPERIMENTALChangesResponseResultChangesItemChangeStoragePaidAtMin = 0;
export const eXPERIMENTALChangesResponseResultChangesItemChangeStorageUsageMin = 0;
export const eXPERIMENTALChangesResponseResultChangesItemChangeAccessKeyNonceMin = 0;
export const eXPERIMENTALChangesResponseResultChangesItemChangeGasKeyBalanceMin = 0;
export const eXPERIMENTALChangesResponseResultChangesItemChangeGasKeyNumNoncesMin = 0;
export const eXPERIMENTALChangesResponseResultChangesItemChangeIndexMin = 0;
export const eXPERIMENTALChangesResponseResultChangesItemChangeNonceMin = 0;


export const eXPERIMENTALChangesResponse = zod.object({
  "result": zod.object({
  "block_hash": zod.string(),
  "changes": zod.array(zod.object({
  "change": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "amount": zod.string(),
  "code_hash": zod.string(),
  "global_contract_account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').nullish(),
  "global_contract_hash": zod.string().nullish(),
  "locked": zod.string(),
  "storage_paid_at": zod.number().min(eXPERIMENTALChangesResponseResultChangesItemChangeStoragePaidAtMin).optional().describe('TODO(2271): deprecated.'),
  "storage_usage": zod.number().min(eXPERIMENTALChangesResponseResultChangesItemChangeStorageUsageMin)
}).describe('A view of the account'),
  "type": zod.enum(['account_update'])
}).or(zod.object({
  "change": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}),
  "type": zod.enum(['account_deletion'])
})).or(zod.object({
  "change": zod.object({
  "access_key": zod.object({
  "nonce": zod.number().min(eXPERIMENTALChangesResponseResultChangesItemChangeAccessKeyNonceMin),
  "permission": zod.enum(['FullAccess']).or(zod.object({
  "FunctionCall": zod.object({
  "allowance": zod.string().nullish(),
  "method_names": zod.array(zod.string()),
  "receiver_id": zod.string()
})
}))
}),
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
}),
  "type": zod.enum(['access_key_update'])
})).or(zod.object({
  "change": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
}),
  "type": zod.enum(['access_key_deletion'])
})).or(zod.object({
  "change": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "gas_key": zod.object({
  "balance": zod.number().min(eXPERIMENTALChangesResponseResultChangesItemChangeGasKeyBalanceMin),
  "num_nonces": zod.number().min(eXPERIMENTALChangesResponseResultChangesItemChangeGasKeyNumNoncesMin),
  "permission": zod.enum(['FullAccess']).or(zod.object({
  "FunctionCall": zod.object({
  "allowance": zod.string().nullish(),
  "method_names": zod.array(zod.string()),
  "receiver_id": zod.string()
})
}))
}),
  "public_key": zod.string()
}),
  "type": zod.enum(['gas_key_update'])
})).or(zod.object({
  "change": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "index": zod.number().min(eXPERIMENTALChangesResponseResultChangesItemChangeIndexMin),
  "nonce": zod.number().min(eXPERIMENTALChangesResponseResultChangesItemChangeNonceMin),
  "public_key": zod.string()
}),
  "type": zod.enum(['gas_key_nonce_update'])
})).or(zod.object({
  "change": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
}),
  "type": zod.enum(['gas_key_deletion'])
})).or(zod.object({
  "change": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "key_base64": zod.string(),
  "value_base64": zod.string()
}),
  "type": zod.enum(['data_update'])
})).or(zod.object({
  "change": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "key_base64": zod.string()
}),
  "type": zod.enum(['data_deletion'])
})).or(zod.object({
  "change": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "code_base64": zod.string()
}),
  "type": zod.enum(['contract_code_update'])
})).or(zod.object({
  "change": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}),
  "type": zod.enum(['contract_code_deletion'])
})))
})
}).or(zod.object({
  "error": zod.object({
  "cause": zod.object({
  "info": zod.object({
  "method_name": zod.string()
}),
  "name": zod.enum(['METHOD_NOT_FOUND'])
}).or(zod.object({
  "info": zod.object({
  "error_message": zod.string()
}),
  "name": zod.enum(['PARSE_ERROR'])
})),
  "name": zod.enum(['REQUEST_VALIDATION_ERROR'])
}).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['HANDLER_ERROR'])
})).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['INTERNAL_ERROR'])
})).describe('This struct may be returned from JSON RPC server in case of error\n It is expected that this struct has impl From<_> all other RPC errors\n like [RpcBlockError](crate::types::blocks::RpcBlockError)')
}))


export const eXPERIMENTALChangesInBlockBodyParamsBlockIdMinOne = 0;


export const eXPERIMENTALChangesInBlockBody = zod.object({
  "id": zod.string(),
  "jsonrpc": zod.string(),
  "method": zod.enum(['EXPERIMENTAL_changes_in_block']),
  "params": zod.object({
  "block_id": zod.number().min(eXPERIMENTALChangesInBlockBodyParamsBlockIdMinOne).or(zod.string())
}).or(zod.object({
  "finality": zod.enum(['optimistic', 'near-final', 'final']).describe('Different types of finality.')
})).or(zod.object({
  "sync_checkpoint": zod.enum(['genesis', 'earliest_available'])
}))
})

export const eXPERIMENTALChangesInBlockResponse = zod.object({
  "result": zod.object({
  "block_hash": zod.string(),
  "changes": zod.array(zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "type": zod.enum(['account_touched'])
}).or(zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "type": zod.enum(['access_key_touched'])
})).or(zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "type": zod.enum(['data_touched'])
})).or(zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "type": zod.enum(['contract_code_touched'])
})).describe('It is a [serializable view] of [`StateChangeKind`].\n\n [serializable view]: ./index.html\n [`StateChangeKind`]: ../types/struct.StateChangeKind.html'))
})
}).or(zod.object({
  "error": zod.object({
  "cause": zod.object({
  "info": zod.object({
  "method_name": zod.string()
}),
  "name": zod.enum(['METHOD_NOT_FOUND'])
}).or(zod.object({
  "info": zod.object({
  "error_message": zod.string()
}),
  "name": zod.enum(['PARSE_ERROR'])
})),
  "name": zod.enum(['REQUEST_VALIDATION_ERROR'])
}).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['HANDLER_ERROR'])
})).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['INTERNAL_ERROR'])
})).describe('This struct may be returned from JSON RPC server in case of error\n It is expected that this struct has impl From<_> all other RPC errors\n like [RpcBlockError](crate::types::blocks::RpcBlockError)')
}))


export const eXPERIMENTALCongestionLevelBodyParamsBlockIdMinOne = 0;
export const eXPERIMENTALCongestionLevelBodyParamsShardIdMin = 0;


export const eXPERIMENTALCongestionLevelBody = zod.object({
  "id": zod.string(),
  "jsonrpc": zod.string(),
  "method": zod.enum(['EXPERIMENTAL_congestion_level']),
  "params": zod.object({
  "block_id": zod.number().min(eXPERIMENTALCongestionLevelBodyParamsBlockIdMinOne).or(zod.string()),
  "shard_id": zod.number().min(eXPERIMENTALCongestionLevelBodyParamsShardIdMin).describe('The shard identifier. It may be an arbitrary number - it does not need to be\n a number in the range 0..NUM_SHARDS. The shard ids do not need to be\n sequential or contiguous.\n\n The shard id is wrapped in a new type to prevent the old pattern of using\n indices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\n if fully complete it potentially may be simplified to a regular type alias.')
}).or(zod.object({
  "chunk_id": zod.string()
}))
})

export const eXPERIMENTALCongestionLevelResponse = zod.object({
  "result": zod.object({
  "congestion_level": zod.number()
})
}).or(zod.object({
  "error": zod.object({
  "cause": zod.object({
  "info": zod.object({
  "method_name": zod.string()
}),
  "name": zod.enum(['METHOD_NOT_FOUND'])
}).or(zod.object({
  "info": zod.object({
  "error_message": zod.string()
}),
  "name": zod.enum(['PARSE_ERROR'])
})),
  "name": zod.enum(['REQUEST_VALIDATION_ERROR'])
}).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['HANDLER_ERROR'])
})).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['INTERNAL_ERROR'])
})).describe('This struct may be returned from JSON RPC server in case of error\n It is expected that this struct has impl From<_> all other RPC errors\n like [RpcBlockError](crate::types::blocks::RpcBlockError)')
}))


export const eXPERIMENTALGenesisConfigBody = zod.object({
  "id": zod.string(),
  "jsonrpc": zod.string(),
  "method": zod.enum(['EXPERIMENTAL_genesis_config']),
  "params": zod.object({

})
})

export const eXPERIMENTALGenesisConfigResponseResultAvgHiddenValidatorSeatsPerShardItemMin = 0;
export const eXPERIMENTALGenesisConfigResponseResultBlockProducerKickoutThresholdMin = 0;
export const eXPERIMENTALGenesisConfigResponseResultChunkProducerAssignmentChangesLimitDefault = 5;
export const eXPERIMENTALGenesisConfigResponseResultChunkProducerAssignmentChangesLimitMin = 0;
export const eXPERIMENTALGenesisConfigResponseResultChunkProducerKickoutThresholdMin = 0;
export const eXPERIMENTALGenesisConfigResponseResultChunkValidatorOnlyKickoutThresholdDefault = 80;
export const eXPERIMENTALGenesisConfigResponseResultChunkValidatorOnlyKickoutThresholdMin = 0;
export const eXPERIMENTALGenesisConfigResponseResultEpochLengthMin = 0;
export const eXPERIMENTALGenesisConfigResponseResultGasLimitMin = 0;
export const eXPERIMENTALGenesisConfigResponseResultGasPriceAdjustmentRateMin = 2;

export const eXPERIMENTALGenesisConfigResponseResultGasPriceAdjustmentRateMax = 2;
export const eXPERIMENTALGenesisConfigResponseResultGenesisHeightMin = 0;
export const eXPERIMENTALGenesisConfigResponseResultMaxInflationRateMin = 2;

export const eXPERIMENTALGenesisConfigResponseResultMaxInflationRateMax = 2;
export const eXPERIMENTALGenesisConfigResponseResultMaxKickoutStakePercDefault = 100;
export const eXPERIMENTALGenesisConfigResponseResultMaxKickoutStakePercMin = 0;
export const eXPERIMENTALGenesisConfigResponseResultMinimumStakeDivisorDefault = 10;
export const eXPERIMENTALGenesisConfigResponseResultMinimumStakeDivisorMin = 0;
export const eXPERIMENTALGenesisConfigResponseResultMinimumStakeRatioDefault = [1, 6250];
export const eXPERIMENTALGenesisConfigResponseResultMinimumStakeRatioMin = 2;

export const eXPERIMENTALGenesisConfigResponseResultMinimumStakeRatioMax = 2;
export const eXPERIMENTALGenesisConfigResponseResultMinimumValidatorsPerShardDefault = 1;
export const eXPERIMENTALGenesisConfigResponseResultMinimumValidatorsPerShardMin = 0;
export const eXPERIMENTALGenesisConfigResponseResultNumBlockProducerSeatsMin = 0;
export const eXPERIMENTALGenesisConfigResponseResultNumBlockProducerSeatsPerShardItemMin = 0;
export const eXPERIMENTALGenesisConfigResponseResultNumBlocksPerYearMin = 0;
export const eXPERIMENTALGenesisConfigResponseResultNumChunkOnlyProducerSeatsDefault = 300;
export const eXPERIMENTALGenesisConfigResponseResultNumChunkOnlyProducerSeatsMin = 0;
export const eXPERIMENTALGenesisConfigResponseResultNumChunkProducerSeatsDefault = 100;
export const eXPERIMENTALGenesisConfigResponseResultNumChunkProducerSeatsMin = 0;
export const eXPERIMENTALGenesisConfigResponseResultNumChunkValidatorSeatsDefault = 300;
export const eXPERIMENTALGenesisConfigResponseResultNumChunkValidatorSeatsMin = 0;
export const eXPERIMENTALGenesisConfigResponseResultOnlineMaxThresholdDefault = [99, 100];
export const eXPERIMENTALGenesisConfigResponseResultOnlineMaxThresholdMin = 2;

export const eXPERIMENTALGenesisConfigResponseResultOnlineMaxThresholdMax = 2;
export const eXPERIMENTALGenesisConfigResponseResultOnlineMinThresholdDefault = [9, 10];
export const eXPERIMENTALGenesisConfigResponseResultOnlineMinThresholdMin = 2;

export const eXPERIMENTALGenesisConfigResponseResultOnlineMinThresholdMax = 2;
export const eXPERIMENTALGenesisConfigResponseResultProtocolRewardRateMin = 2;

export const eXPERIMENTALGenesisConfigResponseResultProtocolRewardRateMax = 2;
export const eXPERIMENTALGenesisConfigResponseResultProtocolUpgradeStakeThresholdDefault = [4, 5];
export const eXPERIMENTALGenesisConfigResponseResultProtocolUpgradeStakeThresholdMin = 2;

export const eXPERIMENTALGenesisConfigResponseResultProtocolUpgradeStakeThresholdMax = 2;
export const eXPERIMENTALGenesisConfigResponseResultProtocolVersionMin = 0;
export const eXPERIMENTALGenesisConfigResponseResultShardLayoutV0NumShardsMin = 0;
export const eXPERIMENTALGenesisConfigResponseResultShardLayoutV0VersionMin = 0;
export const eXPERIMENTALGenesisConfigResponseResultShardLayoutV1ShardsSplitMapItemItemMin = 0;
export const eXPERIMENTALGenesisConfigResponseResultShardLayoutV1ToParentShardMapItemMin = 0;
export const eXPERIMENTALGenesisConfigResponseResultShardLayoutV1VersionMin = 0;
export const eXPERIMENTALGenesisConfigResponseResultShardLayoutV2IdToIndexMapMinOne = 0;
export const eXPERIMENTALGenesisConfigResponseResultShardLayoutV2IndexToIdMapMinOne = 0;
export const eXPERIMENTALGenesisConfigResponseResultShardLayoutV2ShardIdsItemMin = 0;
export const eXPERIMENTALGenesisConfigResponseResultShardLayoutV2ShardsParentMapMinOne = 0;
export const eXPERIMENTALGenesisConfigResponseResultShardLayoutV2ShardsSplitMapItemMin = 0;
export const eXPERIMENTALGenesisConfigResponseResultShardLayoutV2VersionMin = 0;
// export const eXPERIMENTALGenesisConfigResponseResultShardLayoutDefault = { V2: [object Object] };
export const eXPERIMENTALGenesisConfigResponseResultShardLayoutDefault = { V2: [] };
export const eXPERIMENTALGenesisConfigResponseResultShuffleShardAssignmentForChunkProducersDefault = false;
export const eXPERIMENTALGenesisConfigResponseResultTargetValidatorMandatesPerShardDefault = 68;
export const eXPERIMENTALGenesisConfigResponseResultTargetValidatorMandatesPerShardMin = 0;
export const eXPERIMENTALGenesisConfigResponseResultTransactionValidityPeriodMin = 0;
export const eXPERIMENTALGenesisConfigResponseResultUseProductionConfigDefault = false;

export const eXPERIMENTALGenesisConfigResponse = zod.object({
  "result": zod.object({
  "avg_hidden_validator_seats_per_shard": zod.array(zod.number().min(eXPERIMENTALGenesisConfigResponseResultAvgHiddenValidatorSeatsPerShardItemMin)).describe('Expected number of hidden validators per shard.'),
  "block_producer_kickout_threshold": zod.number().min(eXPERIMENTALGenesisConfigResponseResultBlockProducerKickoutThresholdMin).describe('Threshold for kicking out block producers, between 0 and 100.'),
  "chain_id": zod.string().describe('ID of the blockchain. This must be unique for every blockchain.\n If your testnet blockchains do not have unique chain IDs, you will have a bad time.'),
  "chunk_producer_assignment_changes_limit": zod.number().min(eXPERIMENTALGenesisConfigResponseResultChunkProducerAssignmentChangesLimitMin).default(eXPERIMENTALGenesisConfigResponseResultChunkProducerAssignmentChangesLimitDefault).describe('Limits the number of shard changes in chunk producer assignments,\n if algorithm is able to choose assignment with better balance of\n number of chunk producers for shards.'),
  "chunk_producer_kickout_threshold": zod.number().min(eXPERIMENTALGenesisConfigResponseResultChunkProducerKickoutThresholdMin).describe('Threshold for kicking out chunk producers, between 0 and 100.'),
  "chunk_validator_only_kickout_threshold": zod.number().min(eXPERIMENTALGenesisConfigResponseResultChunkValidatorOnlyKickoutThresholdMin).default(eXPERIMENTALGenesisConfigResponseResultChunkValidatorOnlyKickoutThresholdDefault).describe('Threshold for kicking out nodes which are only chunk validators, between 0 and 100.'),
  "dynamic_resharding": zod.boolean().describe('Enable dynamic re-sharding.'),
  "epoch_length": zod.number().min(eXPERIMENTALGenesisConfigResponseResultEpochLengthMin).describe('Epoch length counted in block heights.'),
  "fishermen_threshold": zod.string().describe('Fishermen stake threshold.'),
  "gas_limit": zod.number().min(eXPERIMENTALGenesisConfigResponseResultGasLimitMin).describe('Initial gas limit.'),
  "gas_price_adjustment_rate": zod.array(zod.number()).min(eXPERIMENTALGenesisConfigResponseResultGasPriceAdjustmentRateMin).max(eXPERIMENTALGenesisConfigResponseResultGasPriceAdjustmentRateMax).describe('Gas price adjustment rate'),
  "genesis_height": zod.number().min(eXPERIMENTALGenesisConfigResponseResultGenesisHeightMin).describe('Height of genesis block.'),
  "genesis_time": zod.string().datetime({}).describe('Official time of blockchain start.'),
  "max_gas_price": zod.string(),
  "max_inflation_rate": zod.array(zod.number()).min(eXPERIMENTALGenesisConfigResponseResultMaxInflationRateMin).max(eXPERIMENTALGenesisConfigResponseResultMaxInflationRateMax).describe('Maximum inflation on the total supply every epoch.'),
  "max_kickout_stake_perc": zod.number().min(eXPERIMENTALGenesisConfigResponseResultMaxKickoutStakePercMin).default(eXPERIMENTALGenesisConfigResponseResultMaxKickoutStakePercDefault).describe('Max stake percentage of the validators we will kick out.'),
  "min_gas_price": zod.string().describe('Minimum gas price. It is also the initial gas price.'),
  "minimum_stake_divisor": zod.number().min(eXPERIMENTALGenesisConfigResponseResultMinimumStakeDivisorMin).default(eXPERIMENTALGenesisConfigResponseResultMinimumStakeDivisorDefault).describe('The minimum stake required for staking is last seat price divided by this number.'),
  "minimum_stake_ratio": zod.array(zod.number()).min(eXPERIMENTALGenesisConfigResponseResultMinimumStakeRatioMin).max(eXPERIMENTALGenesisConfigResponseResultMinimumStakeRatioMax).default(eXPERIMENTALGenesisConfigResponseResultMinimumStakeRatioDefault).describe('The lowest ratio s/s_total any block producer can have.\n See <https://github.com/near/NEPs/pull/167> for details'),
  "minimum_validators_per_shard": zod.number().min(eXPERIMENTALGenesisConfigResponseResultMinimumValidatorsPerShardMin).default(eXPERIMENTALGenesisConfigResponseResultMinimumValidatorsPerShardDefault).describe('The minimum number of validators each shard must have'),
  "num_block_producer_seats": zod.number().min(eXPERIMENTALGenesisConfigResponseResultNumBlockProducerSeatsMin).describe('Number of block producer seats at genesis.'),
  "num_block_producer_seats_per_shard": zod.array(zod.number().min(eXPERIMENTALGenesisConfigResponseResultNumBlockProducerSeatsPerShardItemMin)).describe('Defines number of shards and number of block producer seats per each shard at genesis.\n Note: not used with protocol_feature_chunk_only_producers -- replaced by minimum_validators_per_shard\n Note: not used before as all block producers produce chunks for all shards'),
  "num_blocks_per_year": zod.number().min(eXPERIMENTALGenesisConfigResponseResultNumBlocksPerYearMin).describe('Expected number of blocks per year'),
  "num_chunk_only_producer_seats": zod.number().min(eXPERIMENTALGenesisConfigResponseResultNumChunkOnlyProducerSeatsMin).default(eXPERIMENTALGenesisConfigResponseResultNumChunkOnlyProducerSeatsDefault).describe('Deprecated.'),
  "num_chunk_producer_seats": zod.number().min(eXPERIMENTALGenesisConfigResponseResultNumChunkProducerSeatsMin).default(eXPERIMENTALGenesisConfigResponseResultNumChunkProducerSeatsDefault).describe('Number of chunk producers.\n Don\'t mess it up with chunk-only producers feature which is deprecated.'),
  "num_chunk_validator_seats": zod.number().min(eXPERIMENTALGenesisConfigResponseResultNumChunkValidatorSeatsMin).default(eXPERIMENTALGenesisConfigResponseResultNumChunkValidatorSeatsDefault),
  "online_max_threshold": zod.array(zod.number()).min(eXPERIMENTALGenesisConfigResponseResultOnlineMaxThresholdMin).max(eXPERIMENTALGenesisConfigResponseResultOnlineMaxThresholdMax).default(eXPERIMENTALGenesisConfigResponseResultOnlineMaxThresholdDefault).describe('Online maximum threshold above which validator gets full reward.'),
  "online_min_threshold": zod.array(zod.number()).min(eXPERIMENTALGenesisConfigResponseResultOnlineMinThresholdMin).max(eXPERIMENTALGenesisConfigResponseResultOnlineMinThresholdMax).default(eXPERIMENTALGenesisConfigResponseResultOnlineMinThresholdDefault).describe('Online minimum threshold below which validator doesn\'t receive reward.'),
  "protocol_reward_rate": zod.array(zod.number()).min(eXPERIMENTALGenesisConfigResponseResultProtocolRewardRateMin).max(eXPERIMENTALGenesisConfigResponseResultProtocolRewardRateMax).describe('Protocol treasury rate'),
  "protocol_treasury_account": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('Protocol treasury account'),
  "protocol_upgrade_stake_threshold": zod.array(zod.number()).min(eXPERIMENTALGenesisConfigResponseResultProtocolUpgradeStakeThresholdMin).max(eXPERIMENTALGenesisConfigResponseResultProtocolUpgradeStakeThresholdMax).default(eXPERIMENTALGenesisConfigResponseResultProtocolUpgradeStakeThresholdDefault).describe('Threshold of stake that needs to indicate that they ready for upgrade.'),
  "protocol_version": zod.number().min(eXPERIMENTALGenesisConfigResponseResultProtocolVersionMin).describe('Protocol version that this genesis works with.'),
  "shard_layout": zod.object({
  "V0": zod.object({
  "num_shards": zod.number().min(eXPERIMENTALGenesisConfigResponseResultShardLayoutV0NumShardsMin).describe('Map accounts evenly across all shards'),
  "version": zod.number().min(eXPERIMENTALGenesisConfigResponseResultShardLayoutV0VersionMin).describe('Version of the shard layout, this is useful for uniquely identify the shard layout')
}).describe('A shard layout that maps accounts evenly across all shards -- by calculate the hash of account\n id and mod number of shards. This is added to capture the old `account_id_to_shard_id` algorithm,\n to keep backward compatibility for some existing tests.\n `parent_shards` for `ShardLayoutV1` is always `None`, meaning it can only be the first shard layout\n a chain uses.')
}).or(zod.object({
  "V1": zod.object({
  "boundary_accounts": zod.array(zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')).describe('The boundary accounts are the accounts on boundaries between shards.\n Each shard contains a range of accounts from one boundary account to\n another - or the smallest or largest account possible. The total\n number of shards is equal to the number of boundary accounts plus 1.'),
  "shards_split_map": zod.array(zod.array(zod.number().min(eXPERIMENTALGenesisConfigResponseResultShardLayoutV1ShardsSplitMapItemItemMin).describe('The shard identifier. It may be an arbitrary number - it does not need to be\n a number in the range 0..NUM_SHARDS. The shard ids do not need to be\n sequential or contiguous.\n\n The shard id is wrapped in a new type to prevent the old pattern of using\n indices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\n if fully complete it potentially may be simplified to a regular type alias.'))).nullish().describe('Maps shards from the last shard layout to shards that it splits to in this shard layout,\n Useful for constructing states for the shards.\n None for the genesis shard layout'),
  "to_parent_shard_map": zod.array(zod.number().min(eXPERIMENTALGenesisConfigResponseResultShardLayoutV1ToParentShardMapItemMin).describe('The shard identifier. It may be an arbitrary number - it does not need to be\n a number in the range 0..NUM_SHARDS. The shard ids do not need to be\n sequential or contiguous.\n\n The shard id is wrapped in a new type to prevent the old pattern of using\n indices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\n if fully complete it potentially may be simplified to a regular type alias.')).nullish().describe('Maps shard in this shard layout to their parent shard\n Since shard_ids always range from 0 to num_shards - 1, we use vec instead of a hashmap'),
  "version": zod.number().min(eXPERIMENTALGenesisConfigResponseResultShardLayoutV1VersionMin).describe('Version of the shard layout, this is useful for uniquely identify the shard layout')
})
})).or(zod.object({
  "V2": zod.object({
  "boundary_accounts": zod.array(zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')),
  "id_to_index_map": zod.record(zod.string(), zod.number().min(eXPERIMENTALGenesisConfigResponseResultShardLayoutV2IdToIndexMapMinOne)),
  "index_to_id_map": zod.record(zod.string(), zod.number().min(eXPERIMENTALGenesisConfigResponseResultShardLayoutV2IndexToIdMapMinOne).describe('The shard identifier. It may be an arbitrary number - it does not need to be\n a number in the range 0..NUM_SHARDS. The shard ids do not need to be\n sequential or contiguous.\n\n The shard id is wrapped in a new type to prevent the old pattern of using\n indices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\n if fully complete it potentially may be simplified to a regular type alias.')),
  "shard_ids": zod.array(zod.number().min(eXPERIMENTALGenesisConfigResponseResultShardLayoutV2ShardIdsItemMin).describe('The shard identifier. It may be an arbitrary number - it does not need to be\n a number in the range 0..NUM_SHARDS. The shard ids do not need to be\n sequential or contiguous.\n\n The shard id is wrapped in a new type to prevent the old pattern of using\n indices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\n if fully complete it potentially may be simplified to a regular type alias.')),
  "shards_parent_map": zod.record(zod.string(), zod.number().min(eXPERIMENTALGenesisConfigResponseResultShardLayoutV2ShardsParentMapMinOne).describe('The shard identifier. It may be an arbitrary number - it does not need to be\n a number in the range 0..NUM_SHARDS. The shard ids do not need to be\n sequential or contiguous.\n\n The shard id is wrapped in a new type to prevent the old pattern of using\n indices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\n if fully complete it potentially may be simplified to a regular type alias.')).nullish(),
  "shards_split_map": zod.record(zod.string(), zod.array(zod.number().min(eXPERIMENTALGenesisConfigResponseResultShardLayoutV2ShardsSplitMapItemMin).describe('The shard identifier. It may be an arbitrary number - it does not need to be\n a number in the range 0..NUM_SHARDS. The shard ids do not need to be\n sequential or contiguous.\n\n The shard id is wrapped in a new type to prevent the old pattern of using\n indices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\n if fully complete it potentially may be simplified to a regular type alias.'))).nullish(),
  "version": zod.number().min(eXPERIMENTALGenesisConfigResponseResultShardLayoutV2VersionMin)
}).describe('Counterpart to `ShardLayoutV2` composed of maps with string keys to aid\n serde serialization.')
})),
      // .describe('A versioned struct that contains all information needed to assign accounts to shards.\n\n Because of re-sharding, the chain may use different shard layout to split shards at different\n times. Currently, `ShardLayout` is stored as part of `EpochConfig`, which is generated each\n epoch given the epoch protocol version. In mainnet/testnet, we use two shard layouts since\n re-sharding has only happened once. It is stored as part of genesis config, see\n default_simple_nightshade_shard_layout() Below is an overview for some important\n functionalities of ShardLayout interface.').default(eXPERIMENTALGenesisConfigResponseResultShardLayoutDefault).describe('Layout information regarding how to split accounts to shards'),
  "shuffle_shard_assignment_for_chunk_producers": zod.boolean().optional().describe('If true, shuffle the chunk producers across shards. In other words, if\n the shard assignments were `[S_0, S_1, S_2, S_3]` where `S_i` represents\n the set of chunk producers for shard `i`, if this flag were true, the\n shard assignments might become, for example, `[S_2, S_0, S_3, S_1]`.'),
  "target_validator_mandates_per_shard": zod.number().min(eXPERIMENTALGenesisConfigResponseResultTargetValidatorMandatesPerShardMin).default(eXPERIMENTALGenesisConfigResponseResultTargetValidatorMandatesPerShardDefault).describe('Number of target chunk validator mandates for each shard.'),
  "total_supply": zod.string().describe('Total supply of tokens at genesis.'),
  "transaction_validity_period": zod.number().min(eXPERIMENTALGenesisConfigResponseResultTransactionValidityPeriodMin).describe('Number of blocks for which a given transaction is valid'),
  "use_production_config": zod.boolean().optional().describe('This is only for test purposes. We hard code some configs for mainnet and testnet\n in AllEpochConfig, and we want to have a way to test that code path. This flag is for that.\n If set to true, the node will use the same config override path as mainnet and testnet.'),
  "validators": zod.array(zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "amount": zod.string(),
  "public_key": zod.string()
}).describe('Account info for validators')).describe('List of initial validators.')
})
}).or(zod.object({
  "error": zod.object({
  "cause": zod.object({
  "info": zod.object({
  "method_name": zod.string()
}),
  "name": zod.enum(['METHOD_NOT_FOUND'])
}).or(zod.object({
  "info": zod.object({
  "error_message": zod.string()
}),
  "name": zod.enum(['PARSE_ERROR'])
})),
  "name": zod.enum(['REQUEST_VALIDATION_ERROR'])
}).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['HANDLER_ERROR'])
})).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['INTERNAL_ERROR'])
})).describe('This struct may be returned from JSON RPC server in case of error\n It is expected that this struct has impl From<_> all other RPC errors\n like [RpcBlockError](crate::types::blocks::RpcBlockError)')
}))


export const eXPERIMENTALLightClientBlockProofBody = zod.object({
  "id": zod.string(),
  "jsonrpc": zod.string(),
  "method": zod.enum(['EXPERIMENTAL_light_client_block_proof']),
  "params": zod.object({
  "block_hash": zod.string(),
  "light_client_head": zod.string()
})
})

export const eXPERIMENTALLightClientBlockProofResponseResultBlockHeaderLiteInnerLiteHeightMin = 0;
export const eXPERIMENTALLightClientBlockProofResponseResultBlockHeaderLiteInnerLiteTimestampMin = 0;


export const eXPERIMENTALLightClientBlockProofResponse = zod.object({
  "result": zod.object({
  "block_header_lite": zod.object({
  "inner_lite": zod.object({
  "block_merkle_root": zod.string(),
  "epoch_id": zod.string(),
  "height": zod.number().min(eXPERIMENTALLightClientBlockProofResponseResultBlockHeaderLiteInnerLiteHeightMin),
  "next_bp_hash": zod.string(),
  "next_epoch_id": zod.string(),
  "outcome_root": zod.string(),
  "prev_state_root": zod.string(),
  "timestamp": zod.number().min(eXPERIMENTALLightClientBlockProofResponseResultBlockHeaderLiteInnerLiteTimestampMin).describe('Legacy json number. Should not be used.'),
  "timestamp_nanosec": zod.string()
}),
  "inner_rest_hash": zod.string(),
  "prev_block_hash": zod.string()
}),
  "block_proof": zod.array(zod.object({
  "direction": zod.enum(['Left', 'Right']),
  "hash": zod.string()
}))
})
}).or(zod.object({
  "error": zod.object({
  "cause": zod.object({
  "info": zod.object({
  "method_name": zod.string()
}),
  "name": zod.enum(['METHOD_NOT_FOUND'])
}).or(zod.object({
  "info": zod.object({
  "error_message": zod.string()
}),
  "name": zod.enum(['PARSE_ERROR'])
})),
  "name": zod.enum(['REQUEST_VALIDATION_ERROR'])
}).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['HANDLER_ERROR'])
})).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['INTERNAL_ERROR'])
})).describe('This struct may be returned from JSON RPC server in case of error\n It is expected that this struct has impl From<_> all other RPC errors\n like [RpcBlockError](crate::types::blocks::RpcBlockError)')
}))


export const eXPERIMENTALLightClientProofBody = zod.object({
  "id": zod.string(),
  "jsonrpc": zod.string(),
  "method": zod.enum(['EXPERIMENTAL_light_client_proof']),
  "params": zod.object({
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "transaction_hash": zod.string(),
  "type": zod.enum(['transaction'])
}).or(zod.object({
  "receipt_id": zod.string(),
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "type": zod.enum(['receipt'])
}))
})

export const eXPERIMENTALLightClientProofResponseResultBlockHeaderLiteInnerLiteHeightMin = 0;
export const eXPERIMENTALLightClientProofResponseResultBlockHeaderLiteInnerLiteTimestampMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeGasBurntMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeMetadataVersionMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeMetadataDefault = { version: 1 };export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorIndexMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorInvalidNonceAkNonceMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorInvalidNonceTxNonceMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorNonceTooLargeTxNonceMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededLimitMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededSizeMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorShardCongestedShardIdMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorShardStuckMissedChunksMin = 0;
export const eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorShardStuckShardIdMin = 0;


export const eXPERIMENTALLightClientProofResponse = zod.object({
  "result": zod.object({
  "block_header_lite": zod.object({
  "inner_lite": zod.object({
  "block_merkle_root": zod.string(),
  "epoch_id": zod.string(),
  "height": zod.number().min(eXPERIMENTALLightClientProofResponseResultBlockHeaderLiteInnerLiteHeightMin),
  "next_bp_hash": zod.string(),
  "next_epoch_id": zod.string(),
  "outcome_root": zod.string(),
  "prev_state_root": zod.string(),
  "timestamp": zod.number().min(eXPERIMENTALLightClientProofResponseResultBlockHeaderLiteInnerLiteTimestampMin).describe('Legacy json number. Should not be used.'),
  "timestamp_nanosec": zod.string()
}),
  "inner_rest_hash": zod.string(),
  "prev_block_hash": zod.string()
}),
  "block_proof": zod.array(zod.object({
  "direction": zod.enum(['Left', 'Right']),
  "hash": zod.string()
})),
  "outcome_proof": zod.object({
  "block_hash": zod.string(),
  "id": zod.string(),
  "outcome": zod.object({
  "executor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('The id of the account on which the execution happens. For transaction this is signer_id,\n for receipt this is receiver_id.'),
  "gas_burnt": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeGasBurntMin).describe('The amount of the gas burnt by the given transaction or receipt.'),
  "logs": zod.array(zod.string()).describe('Logs from this transaction or receipt.'),
  "metadata": zod.object({
  "gas_profile": zod.array(zod.object({
  "cost": zod.string(),
  "cost_category": zod.string(),
  "gas_used": zod.string()
})).nullish(),
  "version": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeMetadataVersionMin)
}).default(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeMetadataDefault).describe('Execution metadata, versioned'),
  "receipt_ids": zod.array(zod.string()).describe('Receipt IDs generated by this transaction or receipt.'),
  "status": zod.enum(['Unknown']).describe('The execution is pending or unknown.').or(zod.object({
  "Failure": zod.object({
  "ActionError": zod.object({
  "index": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorIndexMin).nullish().describe('Index of the failed action in the transaction.\n Action index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`'),
  "kind": zod.object({
  "AccountAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage').or(zod.object({
  "AccountDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when TX receiver_id doesn\'t exist (but action is not Action::CreateAccount)')).or(zod.object({
  "CreateAccountOnlyByRegistrar": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "registrar_account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A top-level account ID can only be created by registrar.')).or(zod.object({
  "CreateAccountNotAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A newly created account must be under a namespace of the creator account')).or(zod.object({
  "ActorNoPermission": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "actor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\n or the first TX action is a `CreateAccount` action')).or(zod.object({
  "DeleteKeyDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('Account tries to remove an access key that doesn\'t exist')).or(zod.object({
  "AddKeyAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The public key is already used for an existing access key')).or(zod.object({
  "DeleteAccountStaking": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is staking and can not be deleted')).or(zod.object({
  "LackBalanceForState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which needs balance'),
  "amount": zod.string().describe('Balance required to complete an action.')
})
}).describe('ActionReceipt can\'t be completed, because the remaining balance will not be enough to cover storage.')).or(zod.object({
  "TriesToUnstake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is not yet staked, but tries to unstake')).or(zod.object({
  "TriesToStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "balance": zod.string(),
  "locked": zod.string(),
  "stake": zod.string()
})
}).describe('The account doesn\'t have enough balance to increase the stake.')).or(zod.object({
  "InsufficientStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "minimum_stake": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "FunctionCallError": zod.enum(['WasmUnknownError', '_EVMError']).or(zod.object({
  "CompilationError": zod.object({
  "CodeDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).or(zod.object({
  "PrepareError": zod.enum(['Serialization']).describe('Error happened while serializing the module.').or(zod.enum(['Deserialization']).describe('Error happened while deserializing the module.')).or(zod.enum(['InternalMemoryDeclared']).describe('Internal memory declaration has been found in the module.')).or(zod.enum(['GasInstrumentation']).describe('Gas instrumentation failed.\n\n This most likely indicates the module isn\'t valid.')).or(zod.enum(['StackHeightInstrumentation']).describe('Stack instrumentation failed.\n\n This  most likely indicates the module isn\'t valid.')).or(zod.enum(['Instantiate']).describe('Error happened during instantiation.\n\n This might indicate that `start` function trapped, or module isn\'t\n instantiable and/or un-linkable.')).or(zod.enum(['Memory']).describe('Error creating memory.')).or(zod.enum(['TooManyFunctions']).describe('Contract contains too many functions.')).or(zod.enum(['TooManyLocals']).describe('Contract contains too many locals.')).describe('Error that can occur while preparing or executing Wasm smart-contract.')
})).or(zod.object({
  "WasmerCompileError": zod.object({
  "msg": zod.string()
})
}).describe('This is for defense in depth.\n We expect our runtime-independent preparation code to fully catch all invalid wasms,\n but, if it ever misses something we‚Äôll emit this error'))
}).describe('Wasm compilation error')).or(zod.object({
  "LinkError": zod.object({
  "msg": zod.string()
})
}).describe('Wasm binary env link error\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "MethodResolveError": zod.enum(['MethodEmptyName', 'MethodNotFound', 'MethodInvalidSignature'])
}).describe('Import/export resolve error')).or(zod.object({
  "WasmTrap": zod.enum(['Unreachable']).describe('An `unreachable` opcode was executed.').or(zod.enum(['IncorrectCallIndirectSignature']).describe('Call indirect incorrect signature trap.')).or(zod.enum(['MemoryOutOfBounds']).describe('Memory out of bounds trap.')).or(zod.enum(['CallIndirectOOB']).describe('Call indirect out of bounds trap.')).or(zod.enum(['IllegalArithmetic']).describe('An arithmetic exception, e.g. divided by zero.')).or(zod.enum(['MisalignedAtomicAccess']).describe('Misaligned atomic access trap.')).or(zod.enum(['IndirectCallToNull']).describe('Indirect call to null.')).or(zod.enum(['StackOverflow']).describe('Stack overflow.')).or(zod.enum(['GenericTrap']).describe('Generic trap.')).describe('A kind of a trap happened during execution of a binary')
}).describe('A trap happened during execution of a binary\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "HostError": zod.enum(['BadUTF16']).describe('String encoding is bad UTF-16 sequence').or(zod.enum(['BadUTF8']).describe('String encoding is bad UTF-8 sequence')).or(zod.enum(['GasExceeded']).describe('Exceeded the prepaid gas')).or(zod.enum(['GasLimitExceeded']).describe('Exceeded the maximum amount of gas allowed to burn per contract')).or(zod.enum(['BalanceExceeded']).describe('Exceeded the account balance')).or(zod.enum(['EmptyMethodName']).describe('Tried to call an empty method name')).or(zod.object({
  "GuestPanic": zod.object({
  "panic_msg": zod.string()
})
}).describe('Smart contract panicked')).or(zod.enum(['IntegerOverflow']).describe('IntegerOverflow happened during a contract execution')).or(zod.object({
  "InvalidPromiseIndex": zod.object({
  "promise_idx": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMin)
})
}).describe('`promise_idx` does not correspond to existing promises')).or(zod.enum(['CannotAppendActionToJointPromise']).describe('Actions can only be appended to non-joint promise.')).or(zod.enum(['CannotReturnJointPromise']).describe('Returning joint promise is currently prohibited')).or(zod.object({
  "InvalidPromiseResultIndex": zod.object({
  "result_idx": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMin)
})
}).describe('Accessed invalid promise result index')).or(zod.object({
  "InvalidRegisterId": zod.object({
  "register_id": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMin)
})
}).describe('Accessed invalid register id')).or(zod.object({
  "IteratorWasInvalidated": zod.object({
  "iterator_index": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMin)
})
}).describe('Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie')).or(zod.enum(['MemoryAccessViolation']).describe('Accessed memory outside the bounds')).or(zod.object({
  "InvalidReceiptIndex": zod.object({
  "receipt_index": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMin)
})
}).describe('VM Logic returned an invalid receipt index')).or(zod.object({
  "InvalidIteratorIndex": zod.object({
  "iterator_index": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMin)
})
}).describe('Iterator index `iterator_index` does not exist')).or(zod.enum(['InvalidAccountId']).describe('VM Logic returned an invalid account id')).or(zod.enum(['InvalidMethodName']).describe('VM Logic returned an invalid method name')).or(zod.enum(['InvalidPublicKey']).describe('VM Logic provided an invalid public key')).or(zod.object({
  "ProhibitedInView": zod.object({
  "method_name": zod.string()
})
}).describe('`method_name` is not allowed in view calls')).or(zod.object({
  "NumberOfLogsExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMin)
})
}).describe('The total number of logs will exceed the limit.')).or(zod.object({
  "KeyLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMin)
})
}).describe('The storage key length exceeded the limit.')).or(zod.object({
  "ValueLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMin)
})
}).describe('The storage value length exceeded the limit.')).or(zod.object({
  "TotalLogLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMin)
})
}).describe('The total log length exceeded the limit.')).or(zod.object({
  "NumberPromisesExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMin),
  "number_of_promises": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMin)
})
}).describe('The maximum number of promises within a FunctionCall exceeded the limit.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMin),
  "number_of_input_data_dependencies": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin)
})
}).describe('The maximum number of input data dependencies exceeded the limit.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMin)
})
}).describe('The returned value length exceeded the limit.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMin),
  "size": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMin)
})
}).describe('The contract size for DeployContract action exceeded the limit.')).or(zod.object({
  "Deprecated": zod.object({
  "method_name": zod.string()
})
}).describe('The host function was deprecated.')).or(zod.object({
  "ECRecoverError": zod.object({
  "msg": zod.string()
})
}).describe('General errors for ECDSA recover.')).or(zod.object({
  "AltBn128InvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to alt_bn128 family of functions (e.g., point which isn\'t\n on the curve).')).or(zod.object({
  "Ed25519VerifyInvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to ed25519 signature verification function (e.g. signature cannot be\n derived from bytes).'))
}).describe('Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "ExecutionError": zod.string()
})).describe('Serializable version of `near-vm-runner::FunctionCallError`.\n\n Must never reorder/remove elements, can only add new variants at the end (but do that very\n carefully). It describes stable serialization format, and only used by serialization logic.')
}).describe('An error occurred during a `FunctionCall` Action, parameter is debug message.')).or(zod.object({
  "NewReceiptValidationError": zod.object({
  "InvalidPredecessorId": zod.object({
  "account_id": zod.string()
})
}).describe('The `predecessor_id` of a Receipt is not valid.').or(zod.object({
  "InvalidReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a Receipt is not valid.')).or(zod.object({
  "InvalidSignerId": zod.object({
  "account_id": zod.string()
})
}).describe('The `signer_id` of an ActionReceipt is not valid.')).or(zod.object({
  "InvalidDataReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a DataReceiver within an ActionReceipt is not valid.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMin)
})
}).describe('The length of the returned data exceeded the limit in a DataReceipt.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMin),
  "number_of_input_data_dependencies": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin)
})
}).describe('The number of input data dependencies exceeds the limit in an ActionReceipt.')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMin),
  "total_prepaid_gas": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMin),
  "total_number_of_actions": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin),
  "total_number_of_bytes": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMin),
  "size": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMin)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMin)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of an ActionReceipt.')).or(zod.object({
  "ReceiptSizeExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMin),
  "size": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMin)
})
}).describe('Receipt is bigger than the limit.')).describe('Describes the error for validating a receipt.')
}).describe('Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\n receipt validation.')).or(zod.object({
  "OnlyImplicitAccountCreationAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\n See NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\n Also, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\n TODO(#8598): This error is named very poorly. A better name would be\n `OnlyNamedAccountCreationAllowed`.')).or(zod.object({
  "DeleteAccountWithLargeState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Delete account whose state is large is temporarily banned.')).or(zod.enum(['DelegateActionInvalidSignature']).describe('Signature does not match the provided actions and given signer public key.')).or(zod.object({
  "DelegateActionSenderDoesNotMatchTxReceiver": zod.object({
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Receiver of the transaction doesn\'t match Sender of the delegate action')).or(zod.enum(['DelegateActionExpired']).describe('Delegate action has expired. `max_block_height` is less than actual block height.')).or(zod.object({
  "DelegateActionAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('The given public key doesn\'t exist for Sender account')).or(zod.object({
  "DelegateActionInvalidNonce": zod.object({
  "ak_nonce": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMin),
  "delegate_nonce": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMin)
})
}).describe('DelegateAction nonce must be greater sender[public_key].nonce')).or(zod.object({
  "DelegateActionNonceTooLarge": zod.object({
  "delegate_nonce": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMin),
  "upper_bound": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMin)
})
}).describe('DelegateAction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "GlobalContractDoesNotExist": zod.object({
  "identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
})
})).describe('The kind of ActionError happened')
}).describe('An error happened during Action execution')
}).describe('An error happened during Action execution').or(zod.object({
  "InvalidTxError": zod.object({
  "InvalidAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('Happens if a wrong AccessKey used or AccessKey has not enough permissions').or(zod.object({
  "InvalidSignerId": zod.object({
  "signer_id": zod.string()
})
}).describe('TX signer_id is not a valid [`AccountId`]')).or(zod.object({
  "SignerDoesNotExist": zod.object({
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('TX signer_id is not found in a storage')).or(zod.object({
  "InvalidNonce": zod.object({
  "ak_nonce": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorInvalidNonceAkNonceMin),
  "tx_nonce": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorInvalidNonceTxNonceMin)
})
}).describe('Transaction nonce must be strictly greater than `account[access_key].nonce`.')).or(zod.object({
  "NonceTooLarge": zod.object({
  "tx_nonce": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorNonceTooLargeTxNonceMin),
  "upper_bound": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMin)
})
}).describe('Transaction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "InvalidReceiverId": zod.object({
  "receiver_id": zod.string()
})
}).describe('TX receiver_id is not a valid AccountId')).or(zod.enum(['InvalidSignature']).describe('TX signature is not valid')).or(zod.object({
  "NotEnoughBalance": zod.object({
  "balance": zod.string(),
  "cost": zod.string(),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account does not have enough balance to cover TX cost')).or(zod.object({
  "LackBalanceForState": zod.object({
  "amount": zod.string().describe('Required balance to cover the state.'),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which doesn\'t have enough balance to cover storage.')
})
}).describe('Signer account doesn\'t have enough balance after transaction.')).or(zod.enum(['CostOverflow']).describe('An integer overflow occurred during transaction cost estimation.')).or(zod.enum(['InvalidChain']).describe('Transaction parent block hash doesn\'t belong to the current chain')).or(zod.enum(['Expired']).describe('Transaction has expired')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMin),
  "total_prepaid_gas": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMin),
  "total_number_of_actions": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin),
  "total_number_of_bytes": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMin),
  "size": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMin)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMin)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of a Transaction.')).or(zod.object({
  "TransactionSizeExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededLimitMin),
  "size": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededSizeMin)
})
}).describe('The size of serialized transaction exceeded the limit.')).or(zod.enum(['InvalidTransactionVersion']).describe('Transaction version is invalid.')).or(zod.object({
  "StorageError": zod.enum(['StorageInternalError']).describe('Key-value db internal failure').or(zod.object({
  "MissingTrieValue": zod.object({
  "context": zod.enum(['TrieIterator']).describe('Missing trie value when reading from TrieIterator.').or(zod.enum(['TriePrefetchingStorage']).describe('Missing trie value when reading from TriePrefetchingStorage.')).or(zod.enum(['TrieMemoryPartialStorage']).describe('Missing trie value when reading from TrieMemoryPartialStorage.')).or(zod.enum(['TrieStorage']).describe('Missing trie value when reading from TrieStorage.')).describe('Contexts in which `StorageError::MissingTrieValue` error might occur.'),
  "hash": zod.string()
})
}).describe('Requested trie value by its hash which is missing in storage.')).or(zod.enum(['UnexpectedTrieValue']).describe('Found trie node which shouldn\'t be part of state. Raised during\n validation of state sync parts where incorrect node was passed.\n TODO (#8997): consider including hash of trie node.')).or(zod.object({
  "StorageInconsistentState": zod.string()
}).describe('Either invalid state or key-value db is corrupted.\n For PartialStorage it cannot be corrupted.\n Error message is unreliable and for debugging purposes only. It\'s also probably ok to\n panic in every place that produces this error.\n We can check if db is corrupted by verifying everything in the state trie.')).or(zod.object({
  "FlatStorageBlockNotSupported": zod.string()
}).describe('Flat storage error, meaning that it doesn\'t support some block anymore.\n We guarantee that such block cannot become final, thus block processing\n must resume normally.')).or(zod.object({
  "MemTrieLoadingError": zod.string()
}).describe('In-memory trie could not be loaded for some reason.')).describe('Errors which may occur during working with trie storages, storing\n trie values (trie nodes and state values) by their hashes.')
})).or(zod.object({
  "ShardCongested": zod.object({
  "congestion_level": zod.number().describe('A value between 0 (no congestion) and 1 (max congestion).'),
  "shard_id": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorShardCongestedShardIdMin).describe('The congested shard.')
})
}).describe('The receiver shard of the transaction is too congested to accept new\n transactions at the moment.')).or(zod.object({
  "ShardStuck": zod.object({
  "missed_chunks": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorShardStuckMissedChunksMin).describe('The number of blocks since the last included chunk of the shard.'),
  "shard_id": zod.number().min(eXPERIMENTALLightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorShardStuckShardIdMin).describe('The shard that fails making progress.')
})
}).describe('The receiver shard of the transaction missed several chunks and rejects\n new transaction until it can make progress again.')).describe('An error happened during TX execution')
}).describe('An error happened during Transaction execution')).describe('Error returned in the ExecutionOutcome in case of failure')
}).describe('The execution has failed.')).or(zod.object({
  "SuccessValue": zod.string()
}).describe('The final action succeeded and returned some value or an empty vec encoded in base64.')).or(zod.object({
  "SuccessReceiptId": zod.string()
}).describe('The final action of the receipt returned a promise or the signed transaction was converted\n to a receipt. Contains the receipt_id of the generated receipt.')).describe('Execution status. Contains the result in case of successful execution.'),
  "tokens_burnt": zod.string().describe('The amount of tokens burnt corresponding to the burnt gas amount.\n This value doesn\'t always equal to the `gas_burnt` multiplied by the gas price, because\n the prepaid gas price might be lower than the actual gas price and it creates a deficit.\n `tokens_burnt` also contains the penalty subtracted from refunds, while\n `gas_burnt` only contains the gas that we actually burn for the execution.')
}),
  "proof": zod.array(zod.object({
  "direction": zod.enum(['Left', 'Right']),
  "hash": zod.string()
}))
}),
  "outcome_root_proof": zod.array(zod.object({
  "direction": zod.enum(['Left', 'Right']),
  "hash": zod.string()
}))
})
}).or(zod.object({
  "error": zod.object({
  "cause": zod.object({
  "info": zod.object({
  "method_name": zod.string()
}),
  "name": zod.enum(['METHOD_NOT_FOUND'])
}).or(zod.object({
  "info": zod.object({
  "error_message": zod.string()
}),
  "name": zod.enum(['PARSE_ERROR'])
})),
  "name": zod.enum(['REQUEST_VALIDATION_ERROR'])
}).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['HANDLER_ERROR'])
})).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['INTERNAL_ERROR'])
})).describe('This struct may be returned from JSON RPC server in case of error\n It is expected that this struct has impl From<_> all other RPC errors\n like [RpcBlockError](crate::types::blocks::RpcBlockError)')
}))


export const eXPERIMENTALMaintenanceWindowsBody = zod.object({
  "id": zod.string(),
  "jsonrpc": zod.string(),
  "method": zod.enum(['EXPERIMENTAL_maintenance_windows']),
  "params": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
})

export const eXPERIMENTALMaintenanceWindowsResponseResultItemEndMin = 0;
export const eXPERIMENTALMaintenanceWindowsResponseResultItemStartMin = 0;


export const eXPERIMENTALMaintenanceWindowsResponse = zod.object({
  "result": zod.array(zod.object({
  "end": zod.number().min(eXPERIMENTALMaintenanceWindowsResponseResultItemEndMin),
  "start": zod.number().min(eXPERIMENTALMaintenanceWindowsResponseResultItemStartMin)
}))
}).or(zod.object({
  "error": zod.object({
  "cause": zod.object({
  "info": zod.object({
  "method_name": zod.string()
}),
  "name": zod.enum(['METHOD_NOT_FOUND'])
}).or(zod.object({
  "info": zod.object({
  "error_message": zod.string()
}),
  "name": zod.enum(['PARSE_ERROR'])
})),
  "name": zod.enum(['REQUEST_VALIDATION_ERROR'])
}).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['HANDLER_ERROR'])
})).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['INTERNAL_ERROR'])
})).describe('This struct may be returned from JSON RPC server in case of error\n It is expected that this struct has impl From<_> all other RPC errors\n like [RpcBlockError](crate::types::blocks::RpcBlockError)')
}))


export const eXPERIMENTALProtocolConfigBodyParamsBlockIdMinOne = 0;


export const eXPERIMENTALProtocolConfigBody = zod.object({
  "id": zod.string(),
  "jsonrpc": zod.string(),
  "method": zod.enum(['EXPERIMENTAL_protocol_config']),
  "params": zod.object({
  "block_id": zod.number().min(eXPERIMENTALProtocolConfigBodyParamsBlockIdMinOne).or(zod.string())
}).or(zod.object({
  "finality": zod.enum(['optimistic', 'near-final', 'final']).describe('Different types of finality.')
})).or(zod.object({
  "sync_checkpoint": zod.enum(['genesis', 'earliest_available'])
}))
})

export const eXPERIMENTALProtocolConfigResponseResultAvgHiddenValidatorSeatsPerShardItemMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultBlockProducerKickoutThresholdMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultChunkProducerKickoutThresholdMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultChunkValidatorOnlyKickoutThresholdMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultEpochLengthMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultGasLimitMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultGasPriceAdjustmentRateMin = 2;

export const eXPERIMENTALProtocolConfigResponseResultGasPriceAdjustmentRateMax = 2;
export const eXPERIMENTALProtocolConfigResponseResultGenesisHeightMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultMaxInflationRateMin = 2;

export const eXPERIMENTALProtocolConfigResponseResultMaxInflationRateMax = 2;
export const eXPERIMENTALProtocolConfigResponseResultMaxKickoutStakePercMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultMinimumStakeDivisorMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultMinimumStakeRatioMin = 2;

export const eXPERIMENTALProtocolConfigResponseResultMinimumStakeRatioMax = 2;
export const eXPERIMENTALProtocolConfigResponseResultMinimumValidatorsPerShardMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultNumBlockProducerSeatsMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultNumBlockProducerSeatsPerShardItemMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultNumBlocksPerYearMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultOnlineMaxThresholdMin = 2;

export const eXPERIMENTALProtocolConfigResponseResultOnlineMaxThresholdMax = 2;
export const eXPERIMENTALProtocolConfigResponseResultOnlineMinThresholdMin = 2;

export const eXPERIMENTALProtocolConfigResponseResultOnlineMinThresholdMax = 2;
export const eXPERIMENTALProtocolConfigResponseResultProtocolRewardRateMin = 2;

export const eXPERIMENTALProtocolConfigResponseResultProtocolRewardRateMax = 2;
export const eXPERIMENTALProtocolConfigResponseResultProtocolUpgradeStakeThresholdMin = 2;

export const eXPERIMENTALProtocolConfigResponseResultProtocolUpgradeStakeThresholdMax = 2;
export const eXPERIMENTALProtocolConfigResponseResultProtocolVersionMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigAccountCreationConfigMinAllowedTopLevelAccountLengthMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigCongestionControlConfigAllowedShardOutgoingGasMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigCongestionControlConfigMaxCongestionIncomingGasMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigCongestionControlConfigMaxCongestionMemoryConsumptionMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigCongestionControlConfigMaxCongestionMissedChunksMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigCongestionControlConfigMaxCongestionOutgoingGasMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigCongestionControlConfigMaxOutgoingGasMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigCongestionControlConfigMaxTxGasMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigCongestionControlConfigMinOutgoingGasMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigCongestionControlConfigMinTxGasMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigCongestionControlConfigOutgoingReceiptsBigSizeLimitMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigCongestionControlConfigOutgoingReceiptsUsualSizeLimitMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigAddKeyCostFullAccessCostExecutionMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigAddKeyCostFullAccessCostSendNotSirMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigAddKeyCostFullAccessCostSendSirMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigAddKeyCostFunctionCallCostExecutionMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigAddKeyCostFunctionCallCostSendNotSirMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigAddKeyCostFunctionCallCostSendSirMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigAddKeyCostFunctionCallCostPerByteExecutionMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigAddKeyCostFunctionCallCostPerByteSendNotSirMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigAddKeyCostFunctionCallCostPerByteSendSirMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigCreateAccountCostExecutionMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigCreateAccountCostSendNotSirMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigCreateAccountCostSendSirMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigDelegateCostExecutionMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigDelegateCostSendNotSirMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigDelegateCostSendSirMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigDeleteAccountCostExecutionMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigDeleteAccountCostSendNotSirMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigDeleteAccountCostSendSirMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigDeleteKeyCostExecutionMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigDeleteKeyCostSendNotSirMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigDeleteKeyCostSendSirMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigDeployContractCostExecutionMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigDeployContractCostSendNotSirMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigDeployContractCostSendSirMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigDeployContractCostPerByteExecutionMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigDeployContractCostPerByteSendNotSirMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigDeployContractCostPerByteSendSirMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigFunctionCallCostExecutionMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigFunctionCallCostSendNotSirMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigFunctionCallCostSendSirMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigFunctionCallCostPerByteExecutionMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigFunctionCallCostPerByteSendNotSirMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigFunctionCallCostPerByteSendSirMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigStakeCostExecutionMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigStakeCostSendNotSirMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigStakeCostSendSirMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigTransferCostExecutionMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigTransferCostSendNotSirMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigTransferCostSendSirMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionReceiptCreationConfigExecutionMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionReceiptCreationConfigSendNotSirMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionReceiptCreationConfigSendSirMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsBurntGasRewardMin = 2;

export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsBurntGasRewardMax = 2;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsDataReceiptCreationConfigBaseCostExecutionMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsDataReceiptCreationConfigBaseCostSendNotSirMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsDataReceiptCreationConfigBaseCostSendSirMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsDataReceiptCreationConfigCostPerByteExecutionMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsDataReceiptCreationConfigCostPerByteSendNotSirMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsDataReceiptCreationConfigCostPerByteSendSirMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsPessimisticGasPriceInflationRatioMin = 2;

export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsPessimisticGasPriceInflationRatioMax = 2;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsStorageUsageConfigNumBytesAccountMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsStorageUsageConfigNumExtraBytesRecordMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsAltBn128G1MultiexpBaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsAltBn128G1MultiexpElementMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsAltBn128G1SumBaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsAltBn128G1SumElementMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsAltBn128PairingCheckBaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsAltBn128PairingCheckElementMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsBaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsBls12381G1MultiexpBaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsBls12381G1MultiexpElementMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsBls12381G2MultiexpBaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsBls12381G2MultiexpElementMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsBls12381MapFp2ToG2BaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsBls12381MapFp2ToG2ElementMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsBls12381MapFpToG1BaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsBls12381MapFpToG1ElementMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsBls12381P1DecompressBaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsBls12381P1DecompressElementMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsBls12381P1SumBaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsBls12381P1SumElementMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsBls12381P2DecompressBaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsBls12381P2DecompressElementMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsBls12381P2SumBaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsBls12381P2SumElementMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsBls12381PairingBaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsBls12381PairingElementMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsContractCompileBaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsContractCompileBytesMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsContractLoadingBaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsContractLoadingBytesMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsEcrecoverBaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsEd25519VerifyBaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsEd25519VerifyByteMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsKeccak256BaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsKeccak256ByteMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsKeccak512BaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsKeccak512ByteMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsLogBaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsLogByteMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsPromiseAndBaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsPromiseAndPerPromiseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsPromiseReturnMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsReadCachedTrieNodeMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsReadMemoryBaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsReadMemoryByteMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsReadRegisterBaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsReadRegisterByteMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsRipemd160BaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsRipemd160BlockMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsSha256BaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsSha256ByteMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageHasKeyBaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageHasKeyByteMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageIterCreateFromByteMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageIterCreatePrefixBaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageIterCreatePrefixByteMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageIterCreateRangeBaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageIterCreateToByteMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageIterNextBaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageIterNextKeyByteMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageIterNextValueByteMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageLargeReadOverheadBaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageLargeReadOverheadByteMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageReadBaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageReadKeyByteMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageReadValueByteMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageRemoveBaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageRemoveKeyByteMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageRemoveRetValueByteMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageWriteBaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageWriteEvictedByteMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageWriteKeyByteMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageWriteValueByteMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsTouchingTrieNodeMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsUtf16DecodingBaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsUtf16DecodingByteMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsUtf8DecodingBaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsUtf8DecodingByteMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsValidatorStakeBaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsValidatorTotalStakeBaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsWriteMemoryBaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsWriteMemoryByteMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsWriteRegisterBaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsWriteRegisterByteMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsYieldCreateBaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsYieldCreateByteMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsYieldResumeBaseMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsYieldResumeByteMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigGrowMemCostMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigAccountIdValidityRulesVersionMinOne = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigAccountIdValidityRulesVersionDefault = 0;export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigInitialMemoryPagesMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxActionsPerReceiptMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxArgumentsLengthMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxContractSizeMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxFunctionsNumberPerContractMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxGasBurntMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxLengthMethodNameMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxLengthReturnedDataMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxLengthStorageKeyMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxLengthStorageValueMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxLocalsPerContractMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxMemoryPagesMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxNumberBytesMethodNamesMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxNumberInputDataDependenciesMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxNumberLogsMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxNumberRegistersMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxPromisesPerFunctionCallActionMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxReceiptSizeMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxRegisterSizeMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxStackHeightMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxTotalLogLengthMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxTotalPrepaidGasMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxTransactionSizeMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxYieldPayloadSizeMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigPerReceiptStorageProofSizeLimitMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigRegistersMemoryLimitMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigYieldTimeoutLengthInBlocksMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigRegularOpCostMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWitnessConfigCombinedTransactionsSizeLimitMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWitnessConfigMainStorageProofSizeSoftLimitMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWitnessConfigNewTransactionsValidationStateSizeSoftLimitMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultShardLayoutV0NumShardsMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultShardLayoutV0VersionMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultShardLayoutV1ShardsSplitMapItemItemMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultShardLayoutV1ToParentShardMapItemMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultShardLayoutV1VersionMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultShardLayoutV2IdToIndexMapMinOne = 0;
export const eXPERIMENTALProtocolConfigResponseResultShardLayoutV2IndexToIdMapMinOne = 0;
export const eXPERIMENTALProtocolConfigResponseResultShardLayoutV2ShardIdsItemMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultShardLayoutV2ShardsParentMapMinOne = 0;
export const eXPERIMENTALProtocolConfigResponseResultShardLayoutV2ShardsSplitMapItemMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultShardLayoutV2VersionMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultTargetValidatorMandatesPerShardMin = 0;
export const eXPERIMENTALProtocolConfigResponseResultTransactionValidityPeriodMin = 0;


export const eXPERIMENTALProtocolConfigResponse = zod.object({
  "result": zod.object({
  "avg_hidden_validator_seats_per_shard": zod.array(zod.number().min(eXPERIMENTALProtocolConfigResponseResultAvgHiddenValidatorSeatsPerShardItemMin)).describe('Expected number of hidden validators per shard.'),
  "block_producer_kickout_threshold": zod.number().min(eXPERIMENTALProtocolConfigResponseResultBlockProducerKickoutThresholdMin).describe('Threshold for kicking out block producers, between 0 and 100.'),
  "chain_id": zod.string().describe('ID of the blockchain. This must be unique for every blockchain.\n If your testnet blockchains do not have unique chain IDs, you will have a bad time.'),
  "chunk_producer_kickout_threshold": zod.number().min(eXPERIMENTALProtocolConfigResponseResultChunkProducerKickoutThresholdMin).describe('Threshold for kicking out chunk producers, between 0 and 100.'),
  "chunk_validator_only_kickout_threshold": zod.number().min(eXPERIMENTALProtocolConfigResponseResultChunkValidatorOnlyKickoutThresholdMin).describe('Threshold for kicking out nodes which are only chunk validators, between 0 and 100.'),
  "dynamic_resharding": zod.boolean().describe('Enable dynamic re-sharding.'),
  "epoch_length": zod.number().min(eXPERIMENTALProtocolConfigResponseResultEpochLengthMin).describe('Epoch length counted in block heights.'),
  "fishermen_threshold": zod.string().describe('Fishermen stake threshold.'),
  "gas_limit": zod.number().min(eXPERIMENTALProtocolConfigResponseResultGasLimitMin).describe('Initial gas limit.'),
  "gas_price_adjustment_rate": zod.array(zod.number()).min(eXPERIMENTALProtocolConfigResponseResultGasPriceAdjustmentRateMin).max(eXPERIMENTALProtocolConfigResponseResultGasPriceAdjustmentRateMax).describe('Gas price adjustment rate'),
  "genesis_height": zod.number().min(eXPERIMENTALProtocolConfigResponseResultGenesisHeightMin).describe('Height of genesis block.'),
  "genesis_time": zod.string().datetime({}).describe('Official time of blockchain start.'),
  "max_gas_price": zod.string().describe('Maximum gas price.'),
  "max_inflation_rate": zod.array(zod.number()).min(eXPERIMENTALProtocolConfigResponseResultMaxInflationRateMin).max(eXPERIMENTALProtocolConfigResponseResultMaxInflationRateMax).describe('Maximum inflation on the total supply every epoch.'),
  "max_kickout_stake_perc": zod.number().min(eXPERIMENTALProtocolConfigResponseResultMaxKickoutStakePercMin).describe('Max stake percentage of the validators we will kick out.'),
  "min_gas_price": zod.string().describe('Minimum gas price. It is also the initial gas price.'),
  "minimum_stake_divisor": zod.number().min(eXPERIMENTALProtocolConfigResponseResultMinimumStakeDivisorMin).describe('The minimum stake required for staking is last seat price divided by this number.'),
  "minimum_stake_ratio": zod.array(zod.number()).min(eXPERIMENTALProtocolConfigResponseResultMinimumStakeRatioMin).max(eXPERIMENTALProtocolConfigResponseResultMinimumStakeRatioMax).describe('The lowest ratio s/s_total any block producer can have.\n See <https://github.com/near/NEPs/pull/167> for details'),
  "minimum_validators_per_shard": zod.number().min(eXPERIMENTALProtocolConfigResponseResultMinimumValidatorsPerShardMin).describe('The minimum number of validators each shard must have'),
  "num_block_producer_seats": zod.number().min(eXPERIMENTALProtocolConfigResponseResultNumBlockProducerSeatsMin).describe('Number of block producer seats at genesis.'),
  "num_block_producer_seats_per_shard": zod.array(zod.number().min(eXPERIMENTALProtocolConfigResponseResultNumBlockProducerSeatsPerShardItemMin)).describe('Defines number of shards and number of block producer seats per each shard at genesis.'),
  "num_blocks_per_year": zod.number().min(eXPERIMENTALProtocolConfigResponseResultNumBlocksPerYearMin).describe('Expected number of blocks per year'),
  "online_max_threshold": zod.array(zod.number()).min(eXPERIMENTALProtocolConfigResponseResultOnlineMaxThresholdMin).max(eXPERIMENTALProtocolConfigResponseResultOnlineMaxThresholdMax).describe('Online maximum threshold above which validator gets full reward.'),
  "online_min_threshold": zod.array(zod.number()).min(eXPERIMENTALProtocolConfigResponseResultOnlineMinThresholdMin).max(eXPERIMENTALProtocolConfigResponseResultOnlineMinThresholdMax).describe('Online minimum threshold below which validator doesn\'t receive reward.'),
  "protocol_reward_rate": zod.array(zod.number()).min(eXPERIMENTALProtocolConfigResponseResultProtocolRewardRateMin).max(eXPERIMENTALProtocolConfigResponseResultProtocolRewardRateMax).describe('Protocol treasury rate'),
  "protocol_treasury_account": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('Protocol treasury account'),
  "protocol_upgrade_stake_threshold": zod.array(zod.number()).min(eXPERIMENTALProtocolConfigResponseResultProtocolUpgradeStakeThresholdMin).max(eXPERIMENTALProtocolConfigResponseResultProtocolUpgradeStakeThresholdMax).describe('Threshold of stake that needs to indicate that they ready for upgrade.'),
  "protocol_version": zod.number().min(eXPERIMENTALProtocolConfigResponseResultProtocolVersionMin).describe('Current Protocol Version'),
  "runtime_config": zod.object({
  "account_creation_config": zod.object({
  "min_allowed_top_level_account_length": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigAccountCreationConfigMinAllowedTopLevelAccountLengthMin).describe('The minimum length of the top-level account ID that is allowed to be created by any account.'),
  "registrar_account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('The account ID of the account registrar. This account ID allowed to create top-level\n accounts of any valid length.')
}).describe('The structure describes configuration for creation of new accounts.').describe('Config that defines rules for account creation.'),
  "congestion_control_config": zod.object({
  "allowed_shard_outgoing_gas": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigCongestionControlConfigAllowedShardOutgoingGasMin).describe('How much gas the chosen allowed shard can send to a 100% congested shard.\n\n See [`CongestionControlConfig`] for more details.'),
  "max_congestion_incoming_gas": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigCongestionControlConfigMaxCongestionIncomingGasMin).describe('How much gas in delayed receipts of a shard is 100% incoming congestion.\n\n See [`CongestionControlConfig`] for more details.'),
  "max_congestion_memory_consumption": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigCongestionControlConfigMaxCongestionMemoryConsumptionMin).describe('How much memory space of all delayed and buffered receipts in a shard is\n considered 100% congested.\n\n See [`CongestionControlConfig`] for more details.'),
  "max_congestion_missed_chunks": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigCongestionControlConfigMaxCongestionMissedChunksMin).describe('How many missed chunks in a row in a shard is considered 100% congested.'),
  "max_congestion_outgoing_gas": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigCongestionControlConfigMaxCongestionOutgoingGasMin).describe('How much gas in outgoing buffered receipts of a shard is 100% congested.\n\n Outgoing congestion contributes to overall congestion, which reduces how\n much other shards are allowed to forward to this shard.'),
  "max_outgoing_gas": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigCongestionControlConfigMaxOutgoingGasMin).describe('The maximum amount of gas attached to receipts a shard can forward to\n another shard per chunk.\n\n See [`CongestionControlConfig`] for more details.'),
  "max_tx_gas": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigCongestionControlConfigMaxTxGasMin).describe('The maximum amount of gas in a chunk spent on converting new transactions to\n receipts.\n\n See [`CongestionControlConfig`] for more details.'),
  "min_outgoing_gas": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigCongestionControlConfigMinOutgoingGasMin).describe('The minimum gas each shard can send to a shard that is not fully congested.\n\n See [`CongestionControlConfig`] for more details.'),
  "min_tx_gas": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigCongestionControlConfigMinTxGasMin).describe('The minimum amount of gas in a chunk spent on converting new transactions\n to receipts, as long as the receiving shard is not congested.\n\n See [`CongestionControlConfig`] for more details.'),
  "outgoing_receipts_big_size_limit": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigCongestionControlConfigOutgoingReceiptsBigSizeLimitMin).describe('Large size limit for outgoing receipts to a shard, used when it\'s safe\n to send a lot of receipts without making the state witness too large.\n It limits the total sum of outgoing receipts, not individual receipts.'),
  "outgoing_receipts_usual_size_limit": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigCongestionControlConfigOutgoingReceiptsUsualSizeLimitMin).describe('The standard size limit for outgoing receipts aimed at a single shard.\n This limit is pretty small to keep the size of source_receipt_proofs under control.\n It limits the total sum of outgoing receipts, not individual receipts.'),
  "reject_tx_congestion_threshold": zod.number().describe('How much congestion a shard can tolerate before it stops all shards from\n accepting new transactions with the receiver set to the congested shard.')
}).describe('The configuration for congestion control.'),
  "storage_amount_per_byte": zod.string().describe('Amount of yN per byte required to have on the account.  See\n <https://nomicon.io/Economics/Economic#state-stake> for details.'),
  "transaction_costs": zod.object({
  "action_creation_config": zod.object({
  "add_key_cost": zod.object({
  "full_access_cost": zod.object({
  "execution": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigAddKeyCostFullAccessCostExecutionMin).describe('Fee for executing the object.'),
  "send_not_sir": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigAddKeyCostFullAccessCostSendNotSirMin).describe('Fee for sending an object potentially across the shards.'),
  "send_sir": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigAddKeyCostFullAccessCostSendSirMin).describe('Fee for sending an object from the sender to itself, guaranteeing that it does not leave\n the shard.')
}).describe('Costs associated with an object that can only be sent over the network (and executed\n by the receiver).\n NOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\n And `execution` fee is burned when the item is being executed.').describe('Base cost of creating a full access access-key.'),
  "function_call_cost": zod.object({
  "execution": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigAddKeyCostFunctionCallCostExecutionMin).describe('Fee for executing the object.'),
  "send_not_sir": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigAddKeyCostFunctionCallCostSendNotSirMin).describe('Fee for sending an object potentially across the shards.'),
  "send_sir": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigAddKeyCostFunctionCallCostSendSirMin).describe('Fee for sending an object from the sender to itself, guaranteeing that it does not leave\n the shard.')
}).describe('Costs associated with an object that can only be sent over the network (and executed\n by the receiver).\n NOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\n And `execution` fee is burned when the item is being executed.').describe('Base cost of creating an access-key restricted to specific functions.'),
  "function_call_cost_per_byte": zod.object({
  "execution": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigAddKeyCostFunctionCallCostPerByteExecutionMin).describe('Fee for executing the object.'),
  "send_not_sir": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigAddKeyCostFunctionCallCostPerByteSendNotSirMin).describe('Fee for sending an object potentially across the shards.'),
  "send_sir": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigAddKeyCostFunctionCallCostPerByteSendSirMin).describe('Fee for sending an object from the sender to itself, guaranteeing that it does not leave\n the shard.')
}).describe('Costs associated with an object that can only be sent over the network (and executed\n by the receiver).\n NOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\n And `execution` fee is burned when the item is being executed.').describe('Cost per byte of method_names of creating a restricted access-key.')
}).describe('Describes the cost of creating an access key.').describe('Base cost of adding a key.'),
  "create_account_cost": zod.object({
  "execution": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigCreateAccountCostExecutionMin).describe('Fee for executing the object.'),
  "send_not_sir": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigCreateAccountCostSendNotSirMin).describe('Fee for sending an object potentially across the shards.'),
  "send_sir": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigCreateAccountCostSendSirMin).describe('Fee for sending an object from the sender to itself, guaranteeing that it does not leave\n the shard.')
}).describe('Costs associated with an object that can only be sent over the network (and executed\n by the receiver).\n NOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\n And `execution` fee is burned when the item is being executed.').describe('Base cost of creating an account.'),
  "delegate_cost": zod.object({
  "execution": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigDelegateCostExecutionMin).describe('Fee for executing the object.'),
  "send_not_sir": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigDelegateCostSendNotSirMin).describe('Fee for sending an object potentially across the shards.'),
  "send_sir": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigDelegateCostSendSirMin).describe('Fee for sending an object from the sender to itself, guaranteeing that it does not leave\n the shard.')
}).describe('Costs associated with an object that can only be sent over the network (and executed\n by the receiver).\n NOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\n And `execution` fee is burned when the item is being executed.').describe('Base cost for processing a delegate action.\n\n This is on top of the costs for the actions inside the delegate action.'),
  "delete_account_cost": zod.object({
  "execution": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigDeleteAccountCostExecutionMin).describe('Fee for executing the object.'),
  "send_not_sir": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigDeleteAccountCostSendNotSirMin).describe('Fee for sending an object potentially across the shards.'),
  "send_sir": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigDeleteAccountCostSendSirMin).describe('Fee for sending an object from the sender to itself, guaranteeing that it does not leave\n the shard.')
}).describe('Costs associated with an object that can only be sent over the network (and executed\n by the receiver).\n NOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\n And `execution` fee is burned when the item is being executed.').describe('Base cost of deleting an account.'),
  "delete_key_cost": zod.object({
  "execution": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigDeleteKeyCostExecutionMin).describe('Fee for executing the object.'),
  "send_not_sir": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigDeleteKeyCostSendNotSirMin).describe('Fee for sending an object potentially across the shards.'),
  "send_sir": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigDeleteKeyCostSendSirMin).describe('Fee for sending an object from the sender to itself, guaranteeing that it does not leave\n the shard.')
}).describe('Costs associated with an object that can only be sent over the network (and executed\n by the receiver).\n NOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\n And `execution` fee is burned when the item is being executed.').describe('Base cost of deleting a key.'),
  "deploy_contract_cost": zod.object({
  "execution": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigDeployContractCostExecutionMin).describe('Fee for executing the object.'),
  "send_not_sir": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigDeployContractCostSendNotSirMin).describe('Fee for sending an object potentially across the shards.'),
  "send_sir": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigDeployContractCostSendSirMin).describe('Fee for sending an object from the sender to itself, guaranteeing that it does not leave\n the shard.')
}).describe('Costs associated with an object that can only be sent over the network (and executed\n by the receiver).\n NOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\n And `execution` fee is burned when the item is being executed.').describe('Base cost of deploying a contract.'),
  "deploy_contract_cost_per_byte": zod.object({
  "execution": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigDeployContractCostPerByteExecutionMin).describe('Fee for executing the object.'),
  "send_not_sir": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigDeployContractCostPerByteSendNotSirMin).describe('Fee for sending an object potentially across the shards.'),
  "send_sir": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigDeployContractCostPerByteSendSirMin).describe('Fee for sending an object from the sender to itself, guaranteeing that it does not leave\n the shard.')
}).describe('Costs associated with an object that can only be sent over the network (and executed\n by the receiver).\n NOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\n And `execution` fee is burned when the item is being executed.').describe('Cost per byte of deploying a contract.'),
  "function_call_cost": zod.object({
  "execution": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigFunctionCallCostExecutionMin).describe('Fee for executing the object.'),
  "send_not_sir": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigFunctionCallCostSendNotSirMin).describe('Fee for sending an object potentially across the shards.'),
  "send_sir": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigFunctionCallCostSendSirMin).describe('Fee for sending an object from the sender to itself, guaranteeing that it does not leave\n the shard.')
}).describe('Costs associated with an object that can only be sent over the network (and executed\n by the receiver).\n NOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\n And `execution` fee is burned when the item is being executed.').describe('Base cost of calling a function.'),
  "function_call_cost_per_byte": zod.object({
  "execution": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigFunctionCallCostPerByteExecutionMin).describe('Fee for executing the object.'),
  "send_not_sir": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigFunctionCallCostPerByteSendNotSirMin).describe('Fee for sending an object potentially across the shards.'),
  "send_sir": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigFunctionCallCostPerByteSendSirMin).describe('Fee for sending an object from the sender to itself, guaranteeing that it does not leave\n the shard.')
}).describe('Costs associated with an object that can only be sent over the network (and executed\n by the receiver).\n NOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\n And `execution` fee is burned when the item is being executed.').describe('Cost per byte of method name and arguments of calling a function.'),
  "stake_cost": zod.object({
  "execution": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigStakeCostExecutionMin).describe('Fee for executing the object.'),
  "send_not_sir": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigStakeCostSendNotSirMin).describe('Fee for sending an object potentially across the shards.'),
  "send_sir": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigStakeCostSendSirMin).describe('Fee for sending an object from the sender to itself, guaranteeing that it does not leave\n the shard.')
}).describe('Costs associated with an object that can only be sent over the network (and executed\n by the receiver).\n NOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\n And `execution` fee is burned when the item is being executed.').describe('Base cost of staking.'),
  "transfer_cost": zod.object({
  "execution": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigTransferCostExecutionMin).describe('Fee for executing the object.'),
  "send_not_sir": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigTransferCostSendNotSirMin).describe('Fee for sending an object potentially across the shards.'),
  "send_sir": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionCreationConfigTransferCostSendSirMin).describe('Fee for sending an object from the sender to itself, guaranteeing that it does not leave\n the shard.')
}).describe('Costs associated with an object that can only be sent over the network (and executed\n by the receiver).\n NOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\n And `execution` fee is burned when the item is being executed.').describe('Base cost of making a transfer.')
}).describe('Describes the cost of creating a specific action, `Action`. Includes all variants.').describe('Describes the cost of creating a certain action, `Action`. Includes all variants.'),
  "action_receipt_creation_config": zod.object({
  "execution": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionReceiptCreationConfigExecutionMin).describe('Fee for executing the object.'),
  "send_not_sir": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionReceiptCreationConfigSendNotSirMin).describe('Fee for sending an object potentially across the shards.'),
  "send_sir": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsActionReceiptCreationConfigSendSirMin).describe('Fee for sending an object from the sender to itself, guaranteeing that it does not leave\n the shard.')
}).describe('Costs associated with an object that can only be sent over the network (and executed\n by the receiver).\n NOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\n And `execution` fee is burned when the item is being executed.').describe('Describes the cost of creating an action receipt, `ActionReceipt`, excluding the actual cost\n of actions.\n - `send` cost is burned when a receipt is created using `promise_create` or\n     `promise_batch_create`\n - `exec` cost is burned when the receipt is being executed.'),
  "burnt_gas_reward": zod.array(zod.number()).min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsBurntGasRewardMin).max(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsBurntGasRewardMax).describe('Fraction of the burnt gas to reward to the contract account for execution.'),
  "data_receipt_creation_config": zod.object({
  "base_cost": zod.object({
  "execution": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsDataReceiptCreationConfigBaseCostExecutionMin).describe('Fee for executing the object.'),
  "send_not_sir": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsDataReceiptCreationConfigBaseCostSendNotSirMin).describe('Fee for sending an object potentially across the shards.'),
  "send_sir": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsDataReceiptCreationConfigBaseCostSendSirMin).describe('Fee for sending an object from the sender to itself, guaranteeing that it does not leave\n the shard.')
}).describe('Costs associated with an object that can only be sent over the network (and executed\n by the receiver).\n NOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\n And `execution` fee is burned when the item is being executed.').describe('Base cost of creating a data receipt.\n Both `send` and `exec` costs are burned when a new receipt has input dependencies. The gas\n is charged for each input dependency. The dependencies are specified when a receipt is\n created using `promise_then` and `promise_batch_then`.\n NOTE: Any receipt with output dependencies will produce data receipts. Even if it fails.\n Even if the last action is not a function call (in case of success it will return empty\n value).'),
  "cost_per_byte": zod.object({
  "execution": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsDataReceiptCreationConfigCostPerByteExecutionMin).describe('Fee for executing the object.'),
  "send_not_sir": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsDataReceiptCreationConfigCostPerByteSendNotSirMin).describe('Fee for sending an object potentially across the shards.'),
  "send_sir": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsDataReceiptCreationConfigCostPerByteSendSirMin).describe('Fee for sending an object from the sender to itself, guaranteeing that it does not leave\n the shard.')
}).describe('Costs associated with an object that can only be sent over the network (and executed\n by the receiver).\n NOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\n And `execution` fee is burned when the item is being executed.').describe('Additional cost per byte sent.\n Both `send` and `exec` costs are burned when a function call finishes execution and returns\n `N` bytes of data to every output dependency. For each output dependency the cost is\n `(send(sir) + exec()) * N`.')
}).describe('Describes the cost of creating a data receipt, `DataReceipt`.'),
  "pessimistic_gas_price_inflation_ratio": zod.array(zod.number()).min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsPessimisticGasPriceInflationRatioMin).max(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsPessimisticGasPriceInflationRatioMax).describe('Pessimistic gas price inflation ratio.'),
  "storage_usage_config": zod.object({
  "num_bytes_account": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsStorageUsageConfigNumBytesAccountMin).describe('Number of bytes for an account record, including rounding up for account id.'),
  "num_extra_bytes_record": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigTransactionCostsStorageUsageConfigNumExtraBytesRecordMin).describe('Additional number of bytes for a k/v record')
}).describe('Describes cost of storage per block').describe('Describes fees for storage.')
}).describe('Costs of different actions that need to be performed when sending and\n processing transaction and receipts.'),
  "wasm_config": zod.object({
  "discard_custom_sections": zod.boolean().describe('See [VMConfig::discard_custom_sections](crate::vm::Config::discard_custom_sections).'),
  "eth_implicit_accounts": zod.boolean().describe('See [VMConfig::eth_implicit_accounts](crate::vm::Config::eth_implicit_accounts).'),
  "ext_costs": zod.object({
  "alt_bn128_g1_multiexp_base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsAltBn128G1MultiexpBaseMin).describe('Base cost for multiexp'),
  "alt_bn128_g1_multiexp_element": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsAltBn128G1MultiexpElementMin).describe('Per element cost for multiexp'),
  "alt_bn128_g1_sum_base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsAltBn128G1SumBaseMin).describe('Base cost for sum'),
  "alt_bn128_g1_sum_element": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsAltBn128G1SumElementMin).describe('Per element cost for sum'),
  "alt_bn128_pairing_check_base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsAltBn128PairingCheckBaseMin).describe('Base cost for pairing check'),
  "alt_bn128_pairing_check_element": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsAltBn128PairingCheckElementMin).describe('Per element cost for pairing check'),
  "base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsBaseMin).describe('Base cost for calling a host function.'),
  "bls12381_g1_multiexp_base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsBls12381G1MultiexpBaseMin),
  "bls12381_g1_multiexp_element": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsBls12381G1MultiexpElementMin),
  "bls12381_g2_multiexp_base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsBls12381G2MultiexpBaseMin),
  "bls12381_g2_multiexp_element": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsBls12381G2MultiexpElementMin),
  "bls12381_map_fp2_to_g2_base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsBls12381MapFp2ToG2BaseMin),
  "bls12381_map_fp2_to_g2_element": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsBls12381MapFp2ToG2ElementMin),
  "bls12381_map_fp_to_g1_base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsBls12381MapFpToG1BaseMin),
  "bls12381_map_fp_to_g1_element": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsBls12381MapFpToG1ElementMin),
  "bls12381_p1_decompress_base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsBls12381P1DecompressBaseMin),
  "bls12381_p1_decompress_element": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsBls12381P1DecompressElementMin),
  "bls12381_p1_sum_base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsBls12381P1SumBaseMin),
  "bls12381_p1_sum_element": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsBls12381P1SumElementMin),
  "bls12381_p2_decompress_base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsBls12381P2DecompressBaseMin),
  "bls12381_p2_decompress_element": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsBls12381P2DecompressElementMin),
  "bls12381_p2_sum_base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsBls12381P2SumBaseMin),
  "bls12381_p2_sum_element": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsBls12381P2SumElementMin),
  "bls12381_pairing_base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsBls12381PairingBaseMin),
  "bls12381_pairing_element": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsBls12381PairingElementMin),
  "contract_compile_base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsContractCompileBaseMin),
  "contract_compile_bytes": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsContractCompileBytesMin),
  "contract_loading_base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsContractLoadingBaseMin).describe('Base cost of loading a pre-compiled contract'),
  "contract_loading_bytes": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsContractLoadingBytesMin).describe('Cost per byte of loading a pre-compiled contract'),
  "ecrecover_base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsEcrecoverBaseMin).describe('Cost of calling ecrecover'),
  "ed25519_verify_base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsEd25519VerifyBaseMin).describe('Cost of getting ed25519 base'),
  "ed25519_verify_byte": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsEd25519VerifyByteMin).describe('Cost of getting ed25519 per byte'),
  "keccak256_base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsKeccak256BaseMin).describe('Cost of getting sha256 base'),
  "keccak256_byte": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsKeccak256ByteMin).describe('Cost of getting sha256 per byte'),
  "keccak512_base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsKeccak512BaseMin).describe('Cost of getting sha256 base'),
  "keccak512_byte": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsKeccak512ByteMin).describe('Cost of getting sha256 per byte'),
  "log_base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsLogBaseMin).describe('Cost for calling logging.'),
  "log_byte": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsLogByteMin).describe('Cost for logging per byte'),
  "promise_and_base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsPromiseAndBaseMin).describe('Cost for calling `promise_and`'),
  "promise_and_per_promise": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsPromiseAndPerPromiseMin).describe('Cost for calling `promise_and` for each promise'),
  "promise_return": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsPromiseReturnMin).describe('Cost for calling `promise_return`'),
  "read_cached_trie_node": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsReadCachedTrieNodeMin).describe('Cost for reading trie node from memory'),
  "read_memory_base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsReadMemoryBaseMin).describe('Base cost for guest memory read'),
  "read_memory_byte": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsReadMemoryByteMin).describe('Cost for guest memory read'),
  "read_register_base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsReadRegisterBaseMin).describe('Base cost for reading from register'),
  "read_register_byte": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsReadRegisterByteMin).describe('Cost for reading byte from register'),
  "ripemd160_base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsRipemd160BaseMin).describe('Cost of getting ripemd160 base'),
  "ripemd160_block": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsRipemd160BlockMin).describe('Cost of getting ripemd160 per message block'),
  "sha256_base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsSha256BaseMin).describe('Cost of getting sha256 base'),
  "sha256_byte": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsSha256ByteMin).describe('Cost of getting sha256 per byte'),
  "storage_has_key_base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageHasKeyBaseMin).describe('Storage trie check for key existence cost base'),
  "storage_has_key_byte": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageHasKeyByteMin).describe('Storage trie check for key existence per key byte'),
  "storage_iter_create_from_byte": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageIterCreateFromByteMin).describe('Create trie range iterator cost per byte of from key.'),
  "storage_iter_create_prefix_base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageIterCreatePrefixBaseMin).describe('Create trie prefix iterator cost base'),
  "storage_iter_create_prefix_byte": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageIterCreatePrefixByteMin).describe('Create trie prefix iterator cost per byte.'),
  "storage_iter_create_range_base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageIterCreateRangeBaseMin).describe('Create trie range iterator cost base'),
  "storage_iter_create_to_byte": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageIterCreateToByteMin).describe('Create trie range iterator cost per byte of to key.'),
  "storage_iter_next_base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageIterNextBaseMin).describe('Trie iterator per key base cost'),
  "storage_iter_next_key_byte": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageIterNextKeyByteMin).describe('Trie iterator next key byte cost'),
  "storage_iter_next_value_byte": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageIterNextValueByteMin).describe('Trie iterator next key byte cost'),
  "storage_large_read_overhead_base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageLargeReadOverheadBaseMin).describe('Storage trie read key overhead base cost, when doing large reads'),
  "storage_large_read_overhead_byte": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageLargeReadOverheadByteMin).describe('Storage trie read key overhead  per-byte cost, when doing large reads'),
  "storage_read_base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageReadBaseMin).describe('Storage trie read key base cost'),
  "storage_read_key_byte": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageReadKeyByteMin).describe('Storage trie read key per byte cost'),
  "storage_read_value_byte": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageReadValueByteMin).describe('Storage trie read value cost per byte cost'),
  "storage_remove_base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageRemoveBaseMin).describe('Remove key from trie base cost'),
  "storage_remove_key_byte": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageRemoveKeyByteMin).describe('Remove key from trie per byte cost'),
  "storage_remove_ret_value_byte": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageRemoveRetValueByteMin).describe('Remove key from trie ret value byte cost'),
  "storage_write_base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageWriteBaseMin).describe('Storage trie write key base cost'),
  "storage_write_evicted_byte": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageWriteEvictedByteMin).describe('Storage trie write cost per byte of evicted value.'),
  "storage_write_key_byte": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageWriteKeyByteMin).describe('Storage trie write key per byte cost'),
  "storage_write_value_byte": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsStorageWriteValueByteMin).describe('Storage trie write value per byte cost'),
  "touching_trie_node": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsTouchingTrieNodeMin).describe('Cost per reading trie node from DB'),
  "utf16_decoding_base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsUtf16DecodingBaseMin).describe('Base cost of decoding utf16. It\'s used for `log_utf16`.'),
  "utf16_decoding_byte": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsUtf16DecodingByteMin).describe('Cost per byte of decoding utf16. It\'s used for `log_utf16`.'),
  "utf8_decoding_base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsUtf8DecodingBaseMin).describe('Base cost of decoding utf8. It\'s used for `log_utf8` and `panic_utf8`.'),
  "utf8_decoding_byte": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsUtf8DecodingByteMin).describe('Cost per byte of decoding utf8. It\'s used for `log_utf8` and `panic_utf8`.'),
  "validator_stake_base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsValidatorStakeBaseMin).describe('Cost of calling `validator_stake`.'),
  "validator_total_stake_base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsValidatorTotalStakeBaseMin).describe('Cost of calling `validator_total_stake`.'),
  "write_memory_base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsWriteMemoryBaseMin).describe('Base cost for guest memory write'),
  "write_memory_byte": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsWriteMemoryByteMin).describe('Cost for guest memory write per byte'),
  "write_register_base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsWriteRegisterBaseMin).describe('Base cost for writing into register'),
  "write_register_byte": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsWriteRegisterByteMin).describe('Cost for writing byte into register'),
  "yield_create_base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsYieldCreateBaseMin).describe('Base cost for creating a yield promise.'),
  "yield_create_byte": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsYieldCreateByteMin).describe('Per byte cost of arguments and method name.'),
  "yield_resume_base": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsYieldResumeBaseMin).describe('Base cost for resuming a yield receipt.'),
  "yield_resume_byte": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigExtCostsYieldResumeByteMin).describe('Per byte cost of resume payload.')
}).describe('Typed view of ExtCostsConfig to preserve JSON output field names in protocol\n config RPC output.').describe('Costs for runtime externals'),
  "fix_contract_loading_cost": zod.boolean().describe('See [VMConfig::fix_contract_loading_cost](crate::vm::Config::fix_contract_loading_cost).'),
  "global_contract_host_fns": zod.boolean().describe('See [VMConfig::global_contract_host_fns](crate::vm::Config::global_contract_host_fns).'),
  "grow_mem_cost": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigGrowMemCostMin).describe('Gas cost of a growing memory by single page.'),
  "implicit_account_creation": zod.boolean().describe('See [VMConfig::implicit_account_creation](crate::vm::Config::implicit_account_creation).'),
  "limit_config": zod.object({
  "account_id_validity_rules_version": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigAccountIdValidityRulesVersionMinOne).optional().describe('Whether to enforce account_id well-formed-ness where it wasn\'t enforced\n historically.'),
  "initial_memory_pages": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigInitialMemoryPagesMin).describe('The initial number of memory pages.\n NOTE: It\'s not a limiter itself, but it\'s a value we use for initial_memory_pages.'),
  "max_actions_per_receipt": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxActionsPerReceiptMin).describe('Max number of actions per receipt.'),
  "max_arguments_length": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxArgumentsLengthMin).describe('Max length of arguments in a function call action.'),
  "max_contract_size": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxContractSizeMin).describe('Max contract size'),
  "max_functions_number_per_contract": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxFunctionsNumberPerContractMin).nullish().describe('If present, stores max number of functions in one contract'),
  "max_gas_burnt": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxGasBurntMin).describe('Max amount of gas that can be used, excluding gas attached to promises.'),
  "max_length_method_name": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxLengthMethodNameMin).describe('Max length of any method name (without terminating character).'),
  "max_length_returned_data": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxLengthReturnedDataMin).describe('Max length of returned data'),
  "max_length_storage_key": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxLengthStorageKeyMin).describe('Max storage key size'),
  "max_length_storage_value": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxLengthStorageValueMin).describe('Max storage value size'),
  "max_locals_per_contract": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxLocalsPerContractMin).nullish().describe('If present, stores max number of locals declared globally in one contract'),
  "max_memory_pages": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxMemoryPagesMin).describe('What is the maximal memory pages amount is allowed to have for a contract.'),
  "max_number_bytes_method_names": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxNumberBytesMethodNamesMin).describe('Max total length of all method names (including terminating character) for a function call\n permission access key.'),
  "max_number_input_data_dependencies": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxNumberInputDataDependenciesMin).describe('Max number of input data dependencies'),
  "max_number_logs": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxNumberLogsMin).describe('Maximum number of log entries.'),
  "max_number_registers": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxNumberRegistersMin).describe('Maximum number of registers that can be used simultaneously.\n\n Note that due to an implementation quirk [read: a bug] in VMLogic, if we\n have this number of registers, no subsequent writes to the registers\n will succeed even if they replace an existing register.'),
  "max_promises_per_function_call_action": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxPromisesPerFunctionCallActionMin).describe('Max number of promises that a function call can create'),
  "max_receipt_size": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxReceiptSizeMin).describe('Max receipt size'),
  "max_register_size": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxRegisterSizeMin).describe('Maximum number of bytes that can be stored in a single register.'),
  "max_stack_height": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxStackHeightMin).describe('How tall the stack is allowed to grow?\n\n See <https://wiki.parity.io/WebAssembly-StackHeight> to find out how the stack frame cost\n is calculated.'),
  "max_total_log_length": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxTotalLogLengthMin).describe('Maximum total length in bytes of all log messages.'),
  "max_total_prepaid_gas": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxTotalPrepaidGasMin).describe('Max total prepaid gas for all function call actions per receipt.'),
  "max_transaction_size": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxTransactionSizeMin).describe('Max transaction size'),
  "max_yield_payload_size": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigMaxYieldPayloadSizeMin).describe('Maximum number of bytes for payload passed over a yield resume.'),
  "per_receipt_storage_proof_size_limit": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigPerReceiptStorageProofSizeLimitMin).describe('Hard limit on the size of storage proof generated while executing a single receipt.'),
  "registers_memory_limit": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigRegistersMemoryLimitMin).describe('Limit of memory used by registers.'),
  "yield_timeout_length_in_blocks": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigLimitConfigYieldTimeoutLengthInBlocksMin).describe('Number of blocks after which a yielded promise times out.')
}).describe('Describes limits for VM and Runtime.\n TODO #4139: consider switching to strongly-typed wrappers instead of raw quantities').describe('Describes limits for VM and Runtime.\n\n TODO: Consider changing this to `VMLimitConfigView` to avoid dependency\n on runtime.'),
  "reftypes_bulk_memory": zod.boolean().describe('See [VMConfig::reftypes_bulk_memory](crate::vm::Config::reftypes_bulk_memory).'),
  "regular_op_cost": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWasmConfigRegularOpCostMin).describe('Gas cost of a regular operation.'),
  "saturating_float_to_int": zod.boolean().describe('See [VMConfig::saturating_float_to_int](crate::vm::Config::saturating_float_to_int).'),
  "storage_get_mode": zod.enum(['FlatStorage', 'Trie']).describe('This enum represents if a storage_get call will be performed through flat storage or trie').describe('See [VMConfig::storage_get_mode](crate::vm::Config::storage_get_mode).'),
  "vm_kind": zod.enum(['Wasmer0']).describe('Wasmer 0.17.x VM. Gone now.').or(zod.enum(['Wasmtime']).describe('Wasmtime VM.')).or(zod.enum(['Wasmer2']).describe('Wasmer 2.x VM.')).or(zod.enum(['NearVm']).describe('NearVM.')).or(zod.enum(['NearVm2']).describe('NearVM. Exists temporarily while bulk memory and reftypes are getting enabled.')).describe('See [VMConfig::vm_kind](crate::vm::Config::vm_kind).')
}).describe('Config of wasm operations.'),
  "witness_config": zod.object({
  "combined_transactions_size_limit": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWitnessConfigCombinedTransactionsSizeLimitMin).describe('Maximum size of transactions contained inside ChunkStateWitness.\n\n A witness contains transactions from both the previous chunk and the current one.\n This parameter limits the sum of sizes of transactions from both of those chunks.'),
  "main_storage_proof_size_soft_limit": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWitnessConfigMainStorageProofSizeSoftLimitMin).describe('Size limit for storage proof generated while executing receipts in a chunk.\n After this limit is reached we defer execution of any new receipts.'),
  "new_transactions_validation_state_size_soft_limit": zod.number().min(eXPERIMENTALProtocolConfigResponseResultRuntimeConfigWitnessConfigNewTransactionsValidationStateSizeSoftLimitMin).describe('Soft size limit of storage proof used to validate new transactions in ChunkStateWitness.')
}).describe('Configuration specific to ChunkStateWitness.').describe('Configuration specific to ChunkStateWitness.')
}).describe('View that preserves JSON format of the runtime config.').describe('Runtime configuration (mostly economics constants).'),
  "shard_layout": zod.object({
  "V0": zod.object({
  "num_shards": zod.number().min(eXPERIMENTALProtocolConfigResponseResultShardLayoutV0NumShardsMin).describe('Map accounts evenly across all shards'),
  "version": zod.number().min(eXPERIMENTALProtocolConfigResponseResultShardLayoutV0VersionMin).describe('Version of the shard layout, this is useful for uniquely identify the shard layout')
}).describe('A shard layout that maps accounts evenly across all shards -- by calculate the hash of account\n id and mod number of shards. This is added to capture the old `account_id_to_shard_id` algorithm,\n to keep backward compatibility for some existing tests.\n `parent_shards` for `ShardLayoutV1` is always `None`, meaning it can only be the first shard layout\n a chain uses.')
}).or(zod.object({
  "V1": zod.object({
  "boundary_accounts": zod.array(zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')).describe('The boundary accounts are the accounts on boundaries between shards.\n Each shard contains a range of accounts from one boundary account to\n another - or the smallest or largest account possible. The total\n number of shards is equal to the number of boundary accounts plus 1.'),
  "shards_split_map": zod.array(zod.array(zod.number().min(eXPERIMENTALProtocolConfigResponseResultShardLayoutV1ShardsSplitMapItemItemMin).describe('The shard identifier. It may be an arbitrary number - it does not need to be\n a number in the range 0..NUM_SHARDS. The shard ids do not need to be\n sequential or contiguous.\n\n The shard id is wrapped in a new type to prevent the old pattern of using\n indices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\n if fully complete it potentially may be simplified to a regular type alias.'))).nullish().describe('Maps shards from the last shard layout to shards that it splits to in this shard layout,\n Useful for constructing states for the shards.\n None for the genesis shard layout'),
  "to_parent_shard_map": zod.array(zod.number().min(eXPERIMENTALProtocolConfigResponseResultShardLayoutV1ToParentShardMapItemMin).describe('The shard identifier. It may be an arbitrary number - it does not need to be\n a number in the range 0..NUM_SHARDS. The shard ids do not need to be\n sequential or contiguous.\n\n The shard id is wrapped in a new type to prevent the old pattern of using\n indices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\n if fully complete it potentially may be simplified to a regular type alias.')).nullish().describe('Maps shard in this shard layout to their parent shard\n Since shard_ids always range from 0 to num_shards - 1, we use vec instead of a hashmap'),
  "version": zod.number().min(eXPERIMENTALProtocolConfigResponseResultShardLayoutV1VersionMin).describe('Version of the shard layout, this is useful for uniquely identify the shard layout')
})
})).or(zod.object({
  "V2": zod.object({
  "boundary_accounts": zod.array(zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')),
  "id_to_index_map": zod.record(zod.string(), zod.number().min(eXPERIMENTALProtocolConfigResponseResultShardLayoutV2IdToIndexMapMinOne)),
  "index_to_id_map": zod.record(zod.string(), zod.number().min(eXPERIMENTALProtocolConfigResponseResultShardLayoutV2IndexToIdMapMinOne).describe('The shard identifier. It may be an arbitrary number - it does not need to be\n a number in the range 0..NUM_SHARDS. The shard ids do not need to be\n sequential or contiguous.\n\n The shard id is wrapped in a new type to prevent the old pattern of using\n indices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\n if fully complete it potentially may be simplified to a regular type alias.')),
  "shard_ids": zod.array(zod.number().min(eXPERIMENTALProtocolConfigResponseResultShardLayoutV2ShardIdsItemMin).describe('The shard identifier. It may be an arbitrary number - it does not need to be\n a number in the range 0..NUM_SHARDS. The shard ids do not need to be\n sequential or contiguous.\n\n The shard id is wrapped in a new type to prevent the old pattern of using\n indices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\n if fully complete it potentially may be simplified to a regular type alias.')),
  "shards_parent_map": zod.record(zod.string(), zod.number().min(eXPERIMENTALProtocolConfigResponseResultShardLayoutV2ShardsParentMapMinOne).describe('The shard identifier. It may be an arbitrary number - it does not need to be\n a number in the range 0..NUM_SHARDS. The shard ids do not need to be\n sequential or contiguous.\n\n The shard id is wrapped in a new type to prevent the old pattern of using\n indices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\n if fully complete it potentially may be simplified to a regular type alias.')).nullish(),
  "shards_split_map": zod.record(zod.string(), zod.array(zod.number().min(eXPERIMENTALProtocolConfigResponseResultShardLayoutV2ShardsSplitMapItemMin).describe('The shard identifier. It may be an arbitrary number - it does not need to be\n a number in the range 0..NUM_SHARDS. The shard ids do not need to be\n sequential or contiguous.\n\n The shard id is wrapped in a new type to prevent the old pattern of using\n indices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\n if fully complete it potentially may be simplified to a regular type alias.'))).nullish(),
  "version": zod.number().min(eXPERIMENTALProtocolConfigResponseResultShardLayoutV2VersionMin)
}).describe('Counterpart to `ShardLayoutV2` composed of maps with string keys to aid\n serde serialization.')
})).describe('A versioned struct that contains all information needed to assign accounts to shards.\n\n Because of re-sharding, the chain may use different shard layout to split shards at different\n times. Currently, `ShardLayout` is stored as part of `EpochConfig`, which is generated each\n epoch given the epoch protocol version. In mainnet/testnet, we use two shard layouts since\n re-sharding has only happened once. It is stored as part of genesis config, see\n default_simple_nightshade_shard_layout() Below is an overview for some important\n functionalities of ShardLayout interface.').describe('Layout information regarding how to split accounts to shards'),
  "shuffle_shard_assignment_for_chunk_producers": zod.boolean().describe('If true, shuffle the chunk producers across shards. In other words, if\n the shard assignments were `[S_0, S_1, S_2, S_3]` where `S_i` represents\n the set of chunk producers for shard `i`, if this flag were true, the\n shard assignments might become, for example, `[S_2, S_0, S_3, S_1]`.'),
  "target_validator_mandates_per_shard": zod.number().min(eXPERIMENTALProtocolConfigResponseResultTargetValidatorMandatesPerShardMin).describe('Number of target chunk validator mandates for each shard.'),
  "transaction_validity_period": zod.number().min(eXPERIMENTALProtocolConfigResponseResultTransactionValidityPeriodMin).describe('Number of blocks for which a given transaction is valid')
})
}).or(zod.object({
  "error": zod.object({
  "cause": zod.object({
  "info": zod.object({
  "method_name": zod.string()
}),
  "name": zod.enum(['METHOD_NOT_FOUND'])
}).or(zod.object({
  "info": zod.object({
  "error_message": zod.string()
}),
  "name": zod.enum(['PARSE_ERROR'])
})),
  "name": zod.enum(['REQUEST_VALIDATION_ERROR'])
}).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['HANDLER_ERROR'])
})).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['INTERNAL_ERROR'])
})).describe('This struct may be returned from JSON RPC server in case of error\n It is expected that this struct has impl From<_> all other RPC errors\n like [RpcBlockError](crate::types::blocks::RpcBlockError)')
}))


export const eXPERIMENTALReceiptBody = zod.object({
  "id": zod.string(),
  "jsonrpc": zod.string(),
  "method": zod.enum(['EXPERIMENTAL_receipt']),
  "params": zod.object({
  "receipt_id": zod.string()
})
})

export const eXPERIMENTALReceiptResponseResultPriorityDefault = 0;
export const eXPERIMENTALReceiptResponseResultPriorityMin = 0;
export const eXPERIMENTALReceiptResponseResultReceiptActionActionsItemFunctionCallGasMin = 0;
export const eXPERIMENTALReceiptResponseResultReceiptActionActionsItemAddKeyAccessKeyNonceMin = 0;
export const eXPERIMENTALReceiptResponseResultReceiptActionActionsItemDelegateDelegateActionActionsItemFunctionCallGasMin = 0;
export const eXPERIMENTALReceiptResponseResultReceiptActionActionsItemDelegateDelegateActionActionsItemAddKeyAccessKeyNonceMin = 0;
export const eXPERIMENTALReceiptResponseResultReceiptActionActionsItemDelegateDelegateActionMaxBlockHeightMin = 0;
export const eXPERIMENTALReceiptResponseResultReceiptActionActionsItemDelegateDelegateActionNonceMin = 0;
export const eXPERIMENTALReceiptResponseResultReceiptActionIsPromiseYieldDefault = false;export const eXPERIMENTALReceiptResponseResultReceiptDataDataDefault = null;export const eXPERIMENTALReceiptResponseResultReceiptDataIsPromiseResumeDefault = false;export const eXPERIMENTALReceiptResponseResultReceiptGlobalContractDistributionAlreadyDeliveredShardsItemMin = 0;
export const eXPERIMENTALReceiptResponseResultReceiptGlobalContractDistributionTargetShardMin = 0;


export const eXPERIMENTALReceiptResponse = zod.object({
  "result": zod.object({
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "priority": zod.number().min(eXPERIMENTALReceiptResponseResultPriorityMin).optional(),
  "receipt": zod.object({
  "Action": zod.object({
  "actions": zod.array(zod.enum(['CreateAccount']).or(zod.object({
  "DeployContract": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "FunctionCall": zod.object({
  "args": zod.string(),
  "deposit": zod.string(),
  "gas": zod.number().min(eXPERIMENTALReceiptResponseResultReceiptActionActionsItemFunctionCallGasMin),
  "method_name": zod.string()
})
})).or(zod.object({
  "Transfer": zod.object({
  "deposit": zod.string()
})
})).or(zod.object({
  "Stake": zod.object({
  "public_key": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "AddKey": zod.object({
  "access_key": zod.object({
  "nonce": zod.number().min(eXPERIMENTALReceiptResponseResultReceiptActionActionsItemAddKeyAccessKeyNonceMin),
  "permission": zod.enum(['FullAccess']).or(zod.object({
  "FunctionCall": zod.object({
  "allowance": zod.string().nullish(),
  "method_names": zod.array(zod.string()),
  "receiver_id": zod.string()
})
}))
}),
  "public_key": zod.string()
})
})).or(zod.object({
  "DeleteKey": zod.object({
  "public_key": zod.string()
})
})).or(zod.object({
  "DeleteAccount": zod.object({
  "beneficiary_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
})).or(zod.object({
  "Delegate": zod.object({
  "delegate_action": zod.object({
  "actions": zod.array(zod.object({
  "CreateAccount": zod.object({

}).describe('Create account action')
}).describe('Create an (sub)account using a transaction `receiver_id` as an ID for\n a new account ID must pass validation rules described here\n <http://nomicon.io/Primitives/Account.html>.').or(zod.object({
  "DeployContract": zod.object({
  "code": zod.string().describe('WebAssembly binary')
}).describe('Deploy contract action')
}).describe('Sets a Wasm code to a receiver_id')).or(zod.object({
  "FunctionCall": zod.object({
  "args": zod.string(),
  "deposit": zod.string(),
  "gas": zod.number().min(eXPERIMENTALReceiptResponseResultReceiptActionActionsItemDelegateDelegateActionActionsItemFunctionCallGasMin),
  "method_name": zod.string()
})
})).or(zod.object({
  "Transfer": zod.object({
  "deposit": zod.string()
})
})).or(zod.object({
  "Stake": zod.object({
  "public_key": zod.string().describe('Validator key which will be used to sign transactions on behalf of signer_id'),
  "stake": zod.string().describe('Amount of tokens to stake.')
}).describe('An action which stakes signer_id tokens and setup\'s validator public key')
})).or(zod.object({
  "AddKey": zod.object({
  "access_key": zod.object({
  "nonce": zod.number().min(eXPERIMENTALReceiptResponseResultReceiptActionActionsItemDelegateDelegateActionActionsItemAddKeyAccessKeyNonceMin).describe('Nonce for this access key, used for tx nonce generation. When access key is created, nonce\n is set to `(block_height - 1) * 1e6` to avoid tx hash collision on access key re-creation.\n See <https://github.com/near/nearcore/issues/3779> for more details.'),
  "permission": zod.object({
  "FunctionCall": zod.object({
  "allowance": zod.string().nullish().describe('Allowance is a balance limit to use by this access key to pay for function call gas and\n transaction fees. When this access key is used, both account balance and the allowance is\n decreased by the same value.\n `None` means unlimited allowance.\n NOTE: To change or increase the allowance, the old access key needs to be deleted and a new\n access key should be created.'),
  "method_names": zod.array(zod.string()).describe('A list of method names that can be used. The access key only allows transactions with the\n function call of one of the given method names.\n Empty list means any method name can be used.'),
  "receiver_id": zod.string().describe('The access key only allows transactions with the given receiver\'s account id.')
}).describe('Grants limited permission to make transactions with FunctionCallActions\n The permission can limit the allowed balance to be spent on the prepaid gas.\n It also restrict the account ID of the receiver for this function call.\n It also can restrict the method name for the allowed function calls.')
}).or(zod.enum(['FullAccess']).describe('Grants full access to the account.\n NOTE: It\'s used to replace account-level public keys.')).describe('Defines permissions for AccessKey').describe('Defines permissions for this access key.')
}).describe('Access key provides limited access to an account. Each access key belongs to some account and\n is identified by a unique (within the account) public key. One account may have large number of\n access keys. Access keys allow to act on behalf of the account by restricting transactions\n that can be issued.\n `account_id,public_key` is a key in the state').describe('An access key with the permission'),
  "public_key": zod.string().describe('A public key which will be associated with an access_key')
})
})).or(zod.object({
  "DeleteKey": zod.object({
  "public_key": zod.string().describe('A public key associated with the access_key to be deleted.')
})
})).or(zod.object({
  "DeleteAccount": zod.object({
  "beneficiary_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
})).or(zod.object({
  "Delegate": zod.object({
  "delegate_action": zod.any(),
  "signature": zod.string()
})
})).or(zod.object({
  "DeployGlobalContract": zod.object({
  "code": zod.string().describe('WebAssembly binary'),
  "deploy_mode": zod.enum(['CodeHash']).describe('Contract is deployed under its code hash.\n Users will be able reference it by that hash.\n This effectively makes the contract immutable.').or(zod.enum(['AccountId']).describe('Contract is deployed under the owner account id.\n Users will be able reference it by that account id.\n This allows the owner to update the contract for all its users.'))
}).describe('Deploy global contract action')
})).or(zod.object({
  "UseGlobalContract": zod.object({
  "contract_identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
}).describe('Use global contract action')
})).describe('This is Action which mustn\'t contain DelegateAction.\n\n This struct is needed to avoid the recursion when Action/DelegateAction is deserialized.\n\n Important: Don\'t make the inner Action public, this must only be constructed\n through the correct interface that ensures the inner Action is actually not\n a delegate action. That would break an assumption of this type, which we use\n in several places. For example, borsh de-/serialization relies on it. If the\n invariant is broken, we may end up with a `Transaction` or `Receipt` that we\n can serialize but deserializing it back causes a parsing error.')).describe('List of actions to be executed.\n\n With the meta transactions MVP defined in NEP-366, nested\n DelegateActions are not allowed. A separate type is used to enforce it.'),
  "max_block_height": zod.number().min(eXPERIMENTALReceiptResponseResultReceiptActionActionsItemDelegateDelegateActionMaxBlockHeightMin).describe('The maximal height of the block in the blockchain below which the given DelegateAction is valid.'),
  "nonce": zod.number().min(eXPERIMENTALReceiptResponseResultReceiptActionActionsItemDelegateDelegateActionNonceMin).describe('Nonce to ensure that the same delegate action is not sent twice by a\n relayer and should match for given account\'s `public_key`.\n After this action is processed it will increment.'),
  "public_key": zod.string().describe('Public key used to sign this delegated action.'),
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('Receiver of the delegated actions.'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('Signer of the delegated actions')
}).describe('This action allows to execute the inner actions behalf of the defined sender.'),
  "signature": zod.string()
})
})).or(zod.object({
  "DeployGlobalContract": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "DeployGlobalContractByAccountId": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "UseGlobalContract": zod.object({
  "code_hash": zod.string()
})
})).or(zod.object({
  "UseGlobalContractByAccountId": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}))),
  "gas_price": zod.string(),
  "input_data_ids": zod.array(zod.string()),
  "is_promise_yield": zod.boolean().optional(),
  "output_data_receivers": zod.array(zod.object({
  "data_id": zod.string(),
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "signer_public_key": zod.string()
})
}).or(zod.object({
  "Data": zod.object({
  "data": zod.string().nullish(),
  "data_id": zod.string(),
  "is_promise_resume": zod.boolean().optional()
})
})).or(zod.object({
  "GlobalContractDistribution": zod.object({
  "already_delivered_shards": zod.array(zod.number().min(eXPERIMENTALReceiptResponseResultReceiptGlobalContractDistributionAlreadyDeliveredShardsItemMin).describe('The shard identifier. It may be an arbitrary number - it does not need to be\n a number in the range 0..NUM_SHARDS. The shard ids do not need to be\n sequential or contiguous.\n\n The shard id is wrapped in a new type to prevent the old pattern of using\n indices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\n if fully complete it potentially may be simplified to a regular type alias.')),
  "code": zod.string(),
  "id": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})),
  "target_shard": zod.number().min(eXPERIMENTALReceiptResponseResultReceiptGlobalContractDistributionTargetShardMin).describe('The shard identifier. It may be an arbitrary number - it does not need to be\n a number in the range 0..NUM_SHARDS. The shard ids do not need to be\n sequential or contiguous.\n\n The shard id is wrapped in a new type to prevent the old pattern of using\n indices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\n if fully complete it potentially may be simplified to a regular type alias.')
})
})),
  "receipt_id": zod.string(),
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).or(zod.object({
  "error": zod.object({
  "cause": zod.object({
  "info": zod.object({
  "method_name": zod.string()
}),
  "name": zod.enum(['METHOD_NOT_FOUND'])
}).or(zod.object({
  "info": zod.object({
  "error_message": zod.string()
}),
  "name": zod.enum(['PARSE_ERROR'])
})),
  "name": zod.enum(['REQUEST_VALIDATION_ERROR'])
}).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['HANDLER_ERROR'])
})).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['INTERNAL_ERROR'])
})).describe('This struct may be returned from JSON RPC server in case of error\n It is expected that this struct has impl From<_> all other RPC errors\n like [RpcBlockError](crate::types::blocks::RpcBlockError)')
}))


export const eXPERIMENTALSplitStorageInfoBody = zod.object({
  "id": zod.string(),
  "jsonrpc": zod.string(),
  "method": zod.enum(['EXPERIMENTAL_split_storage_info']),
  "params": zod.object({

})
})

export const eXPERIMENTALSplitStorageInfoResponseResultColdHeadHeightMin = 0;
export const eXPERIMENTALSplitStorageInfoResponseResultFinalHeadHeightMin = 0;
export const eXPERIMENTALSplitStorageInfoResponseResultHeadHeightMin = 0;


export const eXPERIMENTALSplitStorageInfoResponse = zod.object({
  "result": zod.object({
  "cold_head_height": zod.number().min(eXPERIMENTALSplitStorageInfoResponseResultColdHeadHeightMin).nullish(),
  "final_head_height": zod.number().min(eXPERIMENTALSplitStorageInfoResponseResultFinalHeadHeightMin).nullish(),
  "head_height": zod.number().min(eXPERIMENTALSplitStorageInfoResponseResultHeadHeightMin).nullish(),
  "hot_db_kind": zod.string().nullish()
}).describe('Contains the split storage information.')
}).or(zod.object({
  "error": zod.object({
  "cause": zod.object({
  "info": zod.object({
  "method_name": zod.string()
}),
  "name": zod.enum(['METHOD_NOT_FOUND'])
}).or(zod.object({
  "info": zod.object({
  "error_message": zod.string()
}),
  "name": zod.enum(['PARSE_ERROR'])
})),
  "name": zod.enum(['REQUEST_VALIDATION_ERROR'])
}).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['HANDLER_ERROR'])
})).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['INTERNAL_ERROR'])
})).describe('This struct may be returned from JSON RPC server in case of error\n It is expected that this struct has impl From<_> all other RPC errors\n like [RpcBlockError](crate::types::blocks::RpcBlockError)')
}))


export const eXPERIMENTALTxStatusBody = zod.object({
  "id": zod.string(),
  "jsonrpc": zod.string(),
  "method": zod.enum(['EXPERIMENTAL_tx_status']),
  "params": zod.object({
  "signed_tx_base64": zod.string()
}).or(zod.object({
  "sender_account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "tx_hash": zod.string()
}))
})

export const eXPERIMENTALTxStatusResponseResultReceiptsItemPriorityDefault = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsItemPriorityMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsItemReceiptActionActionsItemFunctionCallGasMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsItemReceiptActionActionsItemAddKeyAccessKeyNonceMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsItemReceiptActionActionsItemDelegateDelegateActionActionsItemFunctionCallGasMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsItemReceiptActionActionsItemDelegateDelegateActionActionsItemAddKeyAccessKeyNonceMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsItemReceiptActionActionsItemDelegateDelegateActionMaxBlockHeightMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsItemReceiptActionActionsItemDelegateDelegateActionNonceMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsItemReceiptActionIsPromiseYieldDefault = false;export const eXPERIMENTALTxStatusResponseResultReceiptsItemReceiptDataDataDefault = null;export const eXPERIMENTALTxStatusResponseResultReceiptsItemReceiptDataIsPromiseResumeDefault = false;export const eXPERIMENTALTxStatusResponseResultReceiptsItemReceiptGlobalContractDistributionAlreadyDeliveredShardsItemMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsItemReceiptGlobalContractDistributionTargetShardMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeGasBurntMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeMetadataVersionMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeMetadataDefault = { version: 1 };export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorIndexMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorInvalidNonceAkNonceMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorInvalidNonceTxNonceMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorNonceTooLargeTxNonceMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededSizeMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardCongestedShardIdMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardStuckMissedChunksMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardStuckShardIdMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorIndexMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorInvalidNonceAkNonceMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorInvalidNonceTxNonceMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorNonceTooLargeTxNonceMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorTransactionSizeExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorTransactionSizeExceededSizeMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorShardCongestedShardIdMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorShardStuckMissedChunksMin = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorShardStuckShardIdMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionActionsItemFunctionCallGasMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionActionsItemAddKeyAccessKeyNonceMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionActionsItemDelegateDelegateActionActionsItemFunctionCallGasMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionActionsItemDelegateDelegateActionActionsItemAddKeyAccessKeyNonceMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionActionsItemDelegateDelegateActionMaxBlockHeightMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionActionsItemDelegateDelegateActionNonceMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionNonceMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionPriorityFeeDefault = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionPriorityFeeMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeGasBurntMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeMetadataVersionMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeMetadataDefault = { version: 1 };export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorIndexMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorInvalidNonceAkNonceMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorInvalidNonceTxNonceMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorNonceTooLargeTxNonceMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededLimitMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededSizeMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardCongestedShardIdMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardStuckMissedChunksMin = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardStuckShardIdMin = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeGasBurntMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeMetadataVersionMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeMetadataDefaultTwo = { version: 1 };export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorIndexMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorInvalidNonceAkNonceMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorInvalidNonceTxNonceMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorNonceTooLargeTxNonceMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededSizeMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardCongestedShardIdMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardStuckMissedChunksMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardStuckShardIdMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorIndexMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorInvalidNonceAkNonceMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorInvalidNonceTxNonceMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorNonceTooLargeTxNonceMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorTransactionSizeExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorTransactionSizeExceededSizeMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorShardCongestedShardIdMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorShardStuckMissedChunksMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorShardStuckShardIdMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionActionsItemFunctionCallGasMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionActionsItemAddKeyAccessKeyNonceMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionActionsItemDelegateDelegateActionActionsItemFunctionCallGasMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionActionsItemDelegateDelegateActionActionsItemAddKeyAccessKeyNonceMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionActionsItemDelegateDelegateActionMaxBlockHeightMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionActionsItemDelegateDelegateActionNonceMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionNonceMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionPriorityFeeDefaultOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionPriorityFeeMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeGasBurntMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeMetadataVersionMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeMetadataDefaultTwo = { version: 1 };export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorIndexMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorInvalidNonceAkNonceMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorInvalidNonceTxNonceMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorNonceTooLargeTxNonceMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededLimitMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededSizeMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardCongestedShardIdMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardStuckMissedChunksMinOne = 0;
export const eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardStuckShardIdMinOne = 0;


export const eXPERIMENTALTxStatusResponse = zod.object({
  "result": zod.object({
  "receipts": zod.array(zod.object({
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "priority": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsItemPriorityMin).optional(),
  "receipt": zod.object({
  "Action": zod.object({
  "actions": zod.array(zod.enum(['CreateAccount']).or(zod.object({
  "DeployContract": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "FunctionCall": zod.object({
  "args": zod.string(),
  "deposit": zod.string(),
  "gas": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsItemReceiptActionActionsItemFunctionCallGasMin),
  "method_name": zod.string()
})
})).or(zod.object({
  "Transfer": zod.object({
  "deposit": zod.string()
})
})).or(zod.object({
  "Stake": zod.object({
  "public_key": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "AddKey": zod.object({
  "access_key": zod.object({
  "nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsItemReceiptActionActionsItemAddKeyAccessKeyNonceMin),
  "permission": zod.enum(['FullAccess']).or(zod.object({
  "FunctionCall": zod.object({
  "allowance": zod.string().nullish(),
  "method_names": zod.array(zod.string()),
  "receiver_id": zod.string()
})
}))
}),
  "public_key": zod.string()
})
})).or(zod.object({
  "DeleteKey": zod.object({
  "public_key": zod.string()
})
})).or(zod.object({
  "DeleteAccount": zod.object({
  "beneficiary_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
})).or(zod.object({
  "Delegate": zod.object({
  "delegate_action": zod.object({
  "actions": zod.array(zod.object({
  "CreateAccount": zod.object({

}).describe('Create account action')
}).describe('Create an (sub)account using a transaction `receiver_id` as an ID for\n a new account ID must pass validation rules described here\n <http://nomicon.io/Primitives/Account.html>.').or(zod.object({
  "DeployContract": zod.object({
  "code": zod.string().describe('WebAssembly binary')
}).describe('Deploy contract action')
}).describe('Sets a Wasm code to a receiver_id')).or(zod.object({
  "FunctionCall": zod.object({
  "args": zod.string(),
  "deposit": zod.string(),
  "gas": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsItemReceiptActionActionsItemDelegateDelegateActionActionsItemFunctionCallGasMin),
  "method_name": zod.string()
})
})).or(zod.object({
  "Transfer": zod.object({
  "deposit": zod.string()
})
})).or(zod.object({
  "Stake": zod.object({
  "public_key": zod.string().describe('Validator key which will be used to sign transactions on behalf of signer_id'),
  "stake": zod.string().describe('Amount of tokens to stake.')
}).describe('An action which stakes signer_id tokens and setup\'s validator public key')
})).or(zod.object({
  "AddKey": zod.object({
  "access_key": zod.object({
  "nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsItemReceiptActionActionsItemDelegateDelegateActionActionsItemAddKeyAccessKeyNonceMin).describe('Nonce for this access key, used for tx nonce generation. When access key is created, nonce\n is set to `(block_height - 1) * 1e6` to avoid tx hash collision on access key re-creation.\n See <https://github.com/near/nearcore/issues/3779> for more details.'),
  "permission": zod.object({
  "FunctionCall": zod.object({
  "allowance": zod.string().nullish().describe('Allowance is a balance limit to use by this access key to pay for function call gas and\n transaction fees. When this access key is used, both account balance and the allowance is\n decreased by the same value.\n `None` means unlimited allowance.\n NOTE: To change or increase the allowance, the old access key needs to be deleted and a new\n access key should be created.'),
  "method_names": zod.array(zod.string()).describe('A list of method names that can be used. The access key only allows transactions with the\n function call of one of the given method names.\n Empty list means any method name can be used.'),
  "receiver_id": zod.string().describe('The access key only allows transactions with the given receiver\'s account id.')
}).describe('Grants limited permission to make transactions with FunctionCallActions\n The permission can limit the allowed balance to be spent on the prepaid gas.\n It also restrict the account ID of the receiver for this function call.\n It also can restrict the method name for the allowed function calls.')
}).or(zod.enum(['FullAccess']).describe('Grants full access to the account.\n NOTE: It\'s used to replace account-level public keys.')).describe('Defines permissions for AccessKey').describe('Defines permissions for this access key.')
}).describe('Access key provides limited access to an account. Each access key belongs to some account and\n is identified by a unique (within the account) public key. One account may have large number of\n access keys. Access keys allow to act on behalf of the account by restricting transactions\n that can be issued.\n `account_id,public_key` is a key in the state').describe('An access key with the permission'),
  "public_key": zod.string().describe('A public key which will be associated with an access_key')
})
})).or(zod.object({
  "DeleteKey": zod.object({
  "public_key": zod.string().describe('A public key associated with the access_key to be deleted.')
})
})).or(zod.object({
  "DeleteAccount": zod.object({
  "beneficiary_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
})).or(zod.object({
  "Delegate": zod.object({
  "delegate_action": zod.any(),
  "signature": zod.string()
})
})).or(zod.object({
  "DeployGlobalContract": zod.object({
  "code": zod.string().describe('WebAssembly binary'),
  "deploy_mode": zod.enum(['CodeHash']).describe('Contract is deployed under its code hash.\n Users will be able reference it by that hash.\n This effectively makes the contract immutable.').or(zod.enum(['AccountId']).describe('Contract is deployed under the owner account id.\n Users will be able reference it by that account id.\n This allows the owner to update the contract for all its users.'))
}).describe('Deploy global contract action')
})).or(zod.object({
  "UseGlobalContract": zod.object({
  "contract_identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
}).describe('Use global contract action')
})).describe('This is Action which mustn\'t contain DelegateAction.\n\n This struct is needed to avoid the recursion when Action/DelegateAction is deserialized.\n\n Important: Don\'t make the inner Action public, this must only be constructed\n through the correct interface that ensures the inner Action is actually not\n a delegate action. That would break an assumption of this type, which we use\n in several places. For example, borsh de-/serialization relies on it. If the\n invariant is broken, we may end up with a `Transaction` or `Receipt` that we\n can serialize but deserializing it back causes a parsing error.')).describe('List of actions to be executed.\n\n With the meta transactions MVP defined in NEP-366, nested\n DelegateActions are not allowed. A separate type is used to enforce it.'),
  "max_block_height": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsItemReceiptActionActionsItemDelegateDelegateActionMaxBlockHeightMin).describe('The maximal height of the block in the blockchain below which the given DelegateAction is valid.'),
  "nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsItemReceiptActionActionsItemDelegateDelegateActionNonceMin).describe('Nonce to ensure that the same delegate action is not sent twice by a\n relayer and should match for given account\'s `public_key`.\n After this action is processed it will increment.'),
  "public_key": zod.string().describe('Public key used to sign this delegated action.'),
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('Receiver of the delegated actions.'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('Signer of the delegated actions')
}).describe('This action allows to execute the inner actions behalf of the defined sender.'),
  "signature": zod.string()
})
})).or(zod.object({
  "DeployGlobalContract": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "DeployGlobalContractByAccountId": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "UseGlobalContract": zod.object({
  "code_hash": zod.string()
})
})).or(zod.object({
  "UseGlobalContractByAccountId": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}))),
  "gas_price": zod.string(),
  "input_data_ids": zod.array(zod.string()),
  "is_promise_yield": zod.boolean().optional(),
  "output_data_receivers": zod.array(zod.object({
  "data_id": zod.string(),
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "signer_public_key": zod.string()
})
}).or(zod.object({
  "Data": zod.object({
  "data": zod.string().nullish(),
  "data_id": zod.string(),
  "is_promise_resume": zod.boolean().optional()
})
})).or(zod.object({
  "GlobalContractDistribution": zod.object({
  "already_delivered_shards": zod.array(zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsItemReceiptGlobalContractDistributionAlreadyDeliveredShardsItemMin).describe('The shard identifier. It may be an arbitrary number - it does not need to be\n a number in the range 0..NUM_SHARDS. The shard ids do not need to be\n sequential or contiguous.\n\n The shard id is wrapped in a new type to prevent the old pattern of using\n indices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\n if fully complete it potentially may be simplified to a regular type alias.')),
  "code": zod.string(),
  "id": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})),
  "target_shard": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsItemReceiptGlobalContractDistributionTargetShardMin).describe('The shard identifier. It may be an arbitrary number - it does not need to be\n a number in the range 0..NUM_SHARDS. The shard ids do not need to be\n sequential or contiguous.\n\n The shard id is wrapped in a new type to prevent the old pattern of using\n indices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\n if fully complete it potentially may be simplified to a regular type alias.')
})
})),
  "receipt_id": zod.string(),
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})).describe('Receipts generated from the transaction'),
  "receipts_outcome": zod.array(zod.object({
  "block_hash": zod.string(),
  "id": zod.string(),
  "outcome": zod.object({
  "executor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('The id of the account on which the execution happens. For transaction this is signer_id,\n for receipt this is receiver_id.'),
  "gas_burnt": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeGasBurntMin).describe('The amount of the gas burnt by the given transaction or receipt.'),
  "logs": zod.array(zod.string()).describe('Logs from this transaction or receipt.'),
  "metadata": zod.object({
  "gas_profile": zod.array(zod.object({
  "cost": zod.string(),
  "cost_category": zod.string(),
  "gas_used": zod.string()
})).nullish(),
  "version": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeMetadataVersionMin)
}).default(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeMetadataDefault).describe('Execution metadata, versioned'),
  "receipt_ids": zod.array(zod.string()).describe('Receipt IDs generated by this transaction or receipt.'),
  "status": zod.enum(['Unknown']).describe('The execution is pending or unknown.').or(zod.object({
  "Failure": zod.object({
  "ActionError": zod.object({
  "index": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorIndexMin).nullish().describe('Index of the failed action in the transaction.\n Action index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`'),
  "kind": zod.object({
  "AccountAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage').or(zod.object({
  "AccountDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when TX receiver_id doesn\'t exist (but action is not Action::CreateAccount)')).or(zod.object({
  "CreateAccountOnlyByRegistrar": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "registrar_account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A top-level account ID can only be created by registrar.')).or(zod.object({
  "CreateAccountNotAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A newly created account must be under a namespace of the creator account')).or(zod.object({
  "ActorNoPermission": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "actor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\n or the first TX action is a `CreateAccount` action')).or(zod.object({
  "DeleteKeyDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('Account tries to remove an access key that doesn\'t exist')).or(zod.object({
  "AddKeyAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The public key is already used for an existing access key')).or(zod.object({
  "DeleteAccountStaking": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is staking and can not be deleted')).or(zod.object({
  "LackBalanceForState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which needs balance'),
  "amount": zod.string().describe('Balance required to complete an action.')
})
}).describe('ActionReceipt can\'t be completed, because the remaining balance will not be enough to cover storage.')).or(zod.object({
  "TriesToUnstake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is not yet staked, but tries to unstake')).or(zod.object({
  "TriesToStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "balance": zod.string(),
  "locked": zod.string(),
  "stake": zod.string()
})
}).describe('The account doesn\'t have enough balance to increase the stake.')).or(zod.object({
  "InsufficientStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "minimum_stake": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "FunctionCallError": zod.enum(['WasmUnknownError', '_EVMError']).or(zod.object({
  "CompilationError": zod.object({
  "CodeDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).or(zod.object({
  "PrepareError": zod.enum(['Serialization']).describe('Error happened while serializing the module.').or(zod.enum(['Deserialization']).describe('Error happened while deserializing the module.')).or(zod.enum(['InternalMemoryDeclared']).describe('Internal memory declaration has been found in the module.')).or(zod.enum(['GasInstrumentation']).describe('Gas instrumentation failed.\n\n This most likely indicates the module isn\'t valid.')).or(zod.enum(['StackHeightInstrumentation']).describe('Stack instrumentation failed.\n\n This  most likely indicates the module isn\'t valid.')).or(zod.enum(['Instantiate']).describe('Error happened during instantiation.\n\n This might indicate that `start` function trapped, or module isn\'t\n instantiable and/or un-linkable.')).or(zod.enum(['Memory']).describe('Error creating memory.')).or(zod.enum(['TooManyFunctions']).describe('Contract contains too many functions.')).or(zod.enum(['TooManyLocals']).describe('Contract contains too many locals.')).describe('Error that can occur while preparing or executing Wasm smart-contract.')
})).or(zod.object({
  "WasmerCompileError": zod.object({
  "msg": zod.string()
})
}).describe('This is for defense in depth.\n We expect our runtime-independent preparation code to fully catch all invalid wasms,\n but, if it ever misses something we‚Äôll emit this error'))
}).describe('Wasm compilation error')).or(zod.object({
  "LinkError": zod.object({
  "msg": zod.string()
})
}).describe('Wasm binary env link error\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "MethodResolveError": zod.enum(['MethodEmptyName', 'MethodNotFound', 'MethodInvalidSignature'])
}).describe('Import/export resolve error')).or(zod.object({
  "WasmTrap": zod.enum(['Unreachable']).describe('An `unreachable` opcode was executed.').or(zod.enum(['IncorrectCallIndirectSignature']).describe('Call indirect incorrect signature trap.')).or(zod.enum(['MemoryOutOfBounds']).describe('Memory out of bounds trap.')).or(zod.enum(['CallIndirectOOB']).describe('Call indirect out of bounds trap.')).or(zod.enum(['IllegalArithmetic']).describe('An arithmetic exception, e.g. divided by zero.')).or(zod.enum(['MisalignedAtomicAccess']).describe('Misaligned atomic access trap.')).or(zod.enum(['IndirectCallToNull']).describe('Indirect call to null.')).or(zod.enum(['StackOverflow']).describe('Stack overflow.')).or(zod.enum(['GenericTrap']).describe('Generic trap.')).describe('A kind of a trap happened during execution of a binary')
}).describe('A trap happened during execution of a binary\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "HostError": zod.enum(['BadUTF16']).describe('String encoding is bad UTF-16 sequence').or(zod.enum(['BadUTF8']).describe('String encoding is bad UTF-8 sequence')).or(zod.enum(['GasExceeded']).describe('Exceeded the prepaid gas')).or(zod.enum(['GasLimitExceeded']).describe('Exceeded the maximum amount of gas allowed to burn per contract')).or(zod.enum(['BalanceExceeded']).describe('Exceeded the account balance')).or(zod.enum(['EmptyMethodName']).describe('Tried to call an empty method name')).or(zod.object({
  "GuestPanic": zod.object({
  "panic_msg": zod.string()
})
}).describe('Smart contract panicked')).or(zod.enum(['IntegerOverflow']).describe('IntegerOverflow happened during a contract execution')).or(zod.object({
  "InvalidPromiseIndex": zod.object({
  "promise_idx": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMin)
})
}).describe('`promise_idx` does not correspond to existing promises')).or(zod.enum(['CannotAppendActionToJointPromise']).describe('Actions can only be appended to non-joint promise.')).or(zod.enum(['CannotReturnJointPromise']).describe('Returning joint promise is currently prohibited')).or(zod.object({
  "InvalidPromiseResultIndex": zod.object({
  "result_idx": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMin)
})
}).describe('Accessed invalid promise result index')).or(zod.object({
  "InvalidRegisterId": zod.object({
  "register_id": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMin)
})
}).describe('Accessed invalid register id')).or(zod.object({
  "IteratorWasInvalidated": zod.object({
  "iterator_index": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMin)
})
}).describe('Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie')).or(zod.enum(['MemoryAccessViolation']).describe('Accessed memory outside the bounds')).or(zod.object({
  "InvalidReceiptIndex": zod.object({
  "receipt_index": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMin)
})
}).describe('VM Logic returned an invalid receipt index')).or(zod.object({
  "InvalidIteratorIndex": zod.object({
  "iterator_index": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMin)
})
}).describe('Iterator index `iterator_index` does not exist')).or(zod.enum(['InvalidAccountId']).describe('VM Logic returned an invalid account id')).or(zod.enum(['InvalidMethodName']).describe('VM Logic returned an invalid method name')).or(zod.enum(['InvalidPublicKey']).describe('VM Logic provided an invalid public key')).or(zod.object({
  "ProhibitedInView": zod.object({
  "method_name": zod.string()
})
}).describe('`method_name` is not allowed in view calls')).or(zod.object({
  "NumberOfLogsExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMin)
})
}).describe('The total number of logs will exceed the limit.')).or(zod.object({
  "KeyLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMin)
})
}).describe('The storage key length exceeded the limit.')).or(zod.object({
  "ValueLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMin)
})
}).describe('The storage value length exceeded the limit.')).or(zod.object({
  "TotalLogLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMin)
})
}).describe('The total log length exceeded the limit.')).or(zod.object({
  "NumberPromisesExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMin),
  "number_of_promises": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMin)
})
}).describe('The maximum number of promises within a FunctionCall exceeded the limit.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMin),
  "number_of_input_data_dependencies": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin)
})
}).describe('The maximum number of input data dependencies exceeded the limit.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMin)
})
}).describe('The returned value length exceeded the limit.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMin),
  "size": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMin)
})
}).describe('The contract size for DeployContract action exceeded the limit.')).or(zod.object({
  "Deprecated": zod.object({
  "method_name": zod.string()
})
}).describe('The host function was deprecated.')).or(zod.object({
  "ECRecoverError": zod.object({
  "msg": zod.string()
})
}).describe('General errors for ECDSA recover.')).or(zod.object({
  "AltBn128InvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to alt_bn128 family of functions (e.g., point which isn\'t\n on the curve).')).or(zod.object({
  "Ed25519VerifyInvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to ed25519 signature verification function (e.g. signature cannot be\n derived from bytes).'))
}).describe('Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "ExecutionError": zod.string()
})).describe('Serializable version of `near-vm-runner::FunctionCallError`.\n\n Must never reorder/remove elements, can only add new variants at the end (but do that very\n carefully). It describes stable serialization format, and only used by serialization logic.')
}).describe('An error occurred during a `FunctionCall` Action, parameter is debug message.')).or(zod.object({
  "NewReceiptValidationError": zod.object({
  "InvalidPredecessorId": zod.object({
  "account_id": zod.string()
})
}).describe('The `predecessor_id` of a Receipt is not valid.').or(zod.object({
  "InvalidReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a Receipt is not valid.')).or(zod.object({
  "InvalidSignerId": zod.object({
  "account_id": zod.string()
})
}).describe('The `signer_id` of an ActionReceipt is not valid.')).or(zod.object({
  "InvalidDataReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a DataReceiver within an ActionReceipt is not valid.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMin)
})
}).describe('The length of the returned data exceeded the limit in a DataReceipt.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMin),
  "number_of_input_data_dependencies": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin)
})
}).describe('The number of input data dependencies exceeds the limit in an ActionReceipt.')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMin),
  "total_prepaid_gas": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMin),
  "total_number_of_actions": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin),
  "total_number_of_bytes": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMin),
  "size": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMin)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMin)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of an ActionReceipt.')).or(zod.object({
  "ReceiptSizeExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMin),
  "size": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMin)
})
}).describe('Receipt is bigger than the limit.')).describe('Describes the error for validating a receipt.')
}).describe('Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\n receipt validation.')).or(zod.object({
  "OnlyImplicitAccountCreationAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\n See NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\n Also, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\n TODO(#8598): This error is named very poorly. A better name would be\n `OnlyNamedAccountCreationAllowed`.')).or(zod.object({
  "DeleteAccountWithLargeState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Delete account whose state is large is temporarily banned.')).or(zod.enum(['DelegateActionInvalidSignature']).describe('Signature does not match the provided actions and given signer public key.')).or(zod.object({
  "DelegateActionSenderDoesNotMatchTxReceiver": zod.object({
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Receiver of the transaction doesn\'t match Sender of the delegate action')).or(zod.enum(['DelegateActionExpired']).describe('Delegate action has expired. `max_block_height` is less than actual block height.')).or(zod.object({
  "DelegateActionAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('The given public key doesn\'t exist for Sender account')).or(zod.object({
  "DelegateActionInvalidNonce": zod.object({
  "ak_nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMin),
  "delegate_nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMin)
})
}).describe('DelegateAction nonce must be greater sender[public_key].nonce')).or(zod.object({
  "DelegateActionNonceTooLarge": zod.object({
  "delegate_nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMin),
  "upper_bound": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMin)
})
}).describe('DelegateAction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "GlobalContractDoesNotExist": zod.object({
  "identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
})
})).describe('The kind of ActionError happened')
}).describe('An error happened during Action execution')
}).describe('An error happened during Action execution').or(zod.object({
  "InvalidTxError": zod.object({
  "InvalidAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('Happens if a wrong AccessKey used or AccessKey has not enough permissions').or(zod.object({
  "InvalidSignerId": zod.object({
  "signer_id": zod.string()
})
}).describe('TX signer_id is not a valid [`AccountId`]')).or(zod.object({
  "SignerDoesNotExist": zod.object({
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('TX signer_id is not found in a storage')).or(zod.object({
  "InvalidNonce": zod.object({
  "ak_nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorInvalidNonceAkNonceMin),
  "tx_nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorInvalidNonceTxNonceMin)
})
}).describe('Transaction nonce must be strictly greater than `account[access_key].nonce`.')).or(zod.object({
  "NonceTooLarge": zod.object({
  "tx_nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorNonceTooLargeTxNonceMin),
  "upper_bound": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMin)
})
}).describe('Transaction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "InvalidReceiverId": zod.object({
  "receiver_id": zod.string()
})
}).describe('TX receiver_id is not a valid AccountId')).or(zod.enum(['InvalidSignature']).describe('TX signature is not valid')).or(zod.object({
  "NotEnoughBalance": zod.object({
  "balance": zod.string(),
  "cost": zod.string(),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account does not have enough balance to cover TX cost')).or(zod.object({
  "LackBalanceForState": zod.object({
  "amount": zod.string().describe('Required balance to cover the state.'),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which doesn\'t have enough balance to cover storage.')
})
}).describe('Signer account doesn\'t have enough balance after transaction.')).or(zod.enum(['CostOverflow']).describe('An integer overflow occurred during transaction cost estimation.')).or(zod.enum(['InvalidChain']).describe('Transaction parent block hash doesn\'t belong to the current chain')).or(zod.enum(['Expired']).describe('Transaction has expired')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMin),
  "total_prepaid_gas": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMin),
  "total_number_of_actions": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin),
  "total_number_of_bytes": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMin),
  "size": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMin)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMin)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of a Transaction.')).or(zod.object({
  "TransactionSizeExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededLimitMin),
  "size": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededSizeMin)
})
}).describe('The size of serialized transaction exceeded the limit.')).or(zod.enum(['InvalidTransactionVersion']).describe('Transaction version is invalid.')).or(zod.object({
  "StorageError": zod.enum(['StorageInternalError']).describe('Key-value db internal failure').or(zod.object({
  "MissingTrieValue": zod.object({
  "context": zod.enum(['TrieIterator']).describe('Missing trie value when reading from TrieIterator.').or(zod.enum(['TriePrefetchingStorage']).describe('Missing trie value when reading from TriePrefetchingStorage.')).or(zod.enum(['TrieMemoryPartialStorage']).describe('Missing trie value when reading from TrieMemoryPartialStorage.')).or(zod.enum(['TrieStorage']).describe('Missing trie value when reading from TrieStorage.')).describe('Contexts in which `StorageError::MissingTrieValue` error might occur.'),
  "hash": zod.string()
})
}).describe('Requested trie value by its hash which is missing in storage.')).or(zod.enum(['UnexpectedTrieValue']).describe('Found trie node which shouldn\'t be part of state. Raised during\n validation of state sync parts where incorrect node was passed.\n TODO (#8997): consider including hash of trie node.')).or(zod.object({
  "StorageInconsistentState": zod.string()
}).describe('Either invalid state or key-value db is corrupted.\n For PartialStorage it cannot be corrupted.\n Error message is unreliable and for debugging purposes only. It\'s also probably ok to\n panic in every place that produces this error.\n We can check if db is corrupted by verifying everything in the state trie.')).or(zod.object({
  "FlatStorageBlockNotSupported": zod.string()
}).describe('Flat storage error, meaning that it doesn\'t support some block anymore.\n We guarantee that such block cannot become final, thus block processing\n must resume normally.')).or(zod.object({
  "MemTrieLoadingError": zod.string()
}).describe('In-memory trie could not be loaded for some reason.')).describe('Errors which may occur during working with trie storages, storing\n trie values (trie nodes and state values) by their hashes.')
})).or(zod.object({
  "ShardCongested": zod.object({
  "congestion_level": zod.number().describe('A value between 0 (no congestion) and 1 (max congestion).'),
  "shard_id": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardCongestedShardIdMin).describe('The congested shard.')
})
}).describe('The receiver shard of the transaction is too congested to accept new\n transactions at the moment.')).or(zod.object({
  "ShardStuck": zod.object({
  "missed_chunks": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardStuckMissedChunksMin).describe('The number of blocks since the last included chunk of the shard.'),
  "shard_id": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardStuckShardIdMin).describe('The shard that fails making progress.')
})
}).describe('The receiver shard of the transaction missed several chunks and rejects\n new transaction until it can make progress again.')).describe('An error happened during TX execution')
}).describe('An error happened during Transaction execution')).describe('Error returned in the ExecutionOutcome in case of failure')
}).describe('The execution has failed.')).or(zod.object({
  "SuccessValue": zod.string()
}).describe('The final action succeeded and returned some value or an empty vec encoded in base64.')).or(zod.object({
  "SuccessReceiptId": zod.string()
}).describe('The final action of the receipt returned a promise or the signed transaction was converted\n to a receipt. Contains the receipt_id of the generated receipt.')).describe('Execution status. Contains the result in case of successful execution.'),
  "tokens_burnt": zod.string().describe('The amount of tokens burnt corresponding to the burnt gas amount.\n This value doesn\'t always equal to the `gas_burnt` multiplied by the gas price, because\n the prepaid gas price might be lower than the actual gas price and it creates a deficit.\n `tokens_burnt` also contains the penalty subtracted from refunds, while\n `gas_burnt` only contains the gas that we actually burn for the execution.')
}),
  "proof": zod.array(zod.object({
  "direction": zod.enum(['Left', 'Right']),
  "hash": zod.string()
}))
})).describe('The execution outcome of receipts.'),
  "status": zod.enum(['NotStarted']).describe('The execution has not yet started.').or(zod.enum(['Started']).describe('The execution has started and still going.')).or(zod.object({
  "Failure": zod.object({
  "ActionError": zod.object({
  "index": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorIndexMin).nullish().describe('Index of the failed action in the transaction.\n Action index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`'),
  "kind": zod.object({
  "AccountAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage').or(zod.object({
  "AccountDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when TX receiver_id doesn\'t exist (but action is not Action::CreateAccount)')).or(zod.object({
  "CreateAccountOnlyByRegistrar": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "registrar_account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A top-level account ID can only be created by registrar.')).or(zod.object({
  "CreateAccountNotAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A newly created account must be under a namespace of the creator account')).or(zod.object({
  "ActorNoPermission": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "actor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\n or the first TX action is a `CreateAccount` action')).or(zod.object({
  "DeleteKeyDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('Account tries to remove an access key that doesn\'t exist')).or(zod.object({
  "AddKeyAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The public key is already used for an existing access key')).or(zod.object({
  "DeleteAccountStaking": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is staking and can not be deleted')).or(zod.object({
  "LackBalanceForState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which needs balance'),
  "amount": zod.string().describe('Balance required to complete an action.')
})
}).describe('ActionReceipt can\'t be completed, because the remaining balance will not be enough to cover storage.')).or(zod.object({
  "TriesToUnstake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is not yet staked, but tries to unstake')).or(zod.object({
  "TriesToStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "balance": zod.string(),
  "locked": zod.string(),
  "stake": zod.string()
})
}).describe('The account doesn\'t have enough balance to increase the stake.')).or(zod.object({
  "InsufficientStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "minimum_stake": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "FunctionCallError": zod.enum(['WasmUnknownError', '_EVMError']).or(zod.object({
  "CompilationError": zod.object({
  "CodeDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).or(zod.object({
  "PrepareError": zod.enum(['Serialization']).describe('Error happened while serializing the module.').or(zod.enum(['Deserialization']).describe('Error happened while deserializing the module.')).or(zod.enum(['InternalMemoryDeclared']).describe('Internal memory declaration has been found in the module.')).or(zod.enum(['GasInstrumentation']).describe('Gas instrumentation failed.\n\n This most likely indicates the module isn\'t valid.')).or(zod.enum(['StackHeightInstrumentation']).describe('Stack instrumentation failed.\n\n This  most likely indicates the module isn\'t valid.')).or(zod.enum(['Instantiate']).describe('Error happened during instantiation.\n\n This might indicate that `start` function trapped, or module isn\'t\n instantiable and/or un-linkable.')).or(zod.enum(['Memory']).describe('Error creating memory.')).or(zod.enum(['TooManyFunctions']).describe('Contract contains too many functions.')).or(zod.enum(['TooManyLocals']).describe('Contract contains too many locals.')).describe('Error that can occur while preparing or executing Wasm smart-contract.')
})).or(zod.object({
  "WasmerCompileError": zod.object({
  "msg": zod.string()
})
}).describe('This is for defense in depth.\n We expect our runtime-independent preparation code to fully catch all invalid wasms,\n but, if it ever misses something we‚Äôll emit this error'))
}).describe('Wasm compilation error')).or(zod.object({
  "LinkError": zod.object({
  "msg": zod.string()
})
}).describe('Wasm binary env link error\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "MethodResolveError": zod.enum(['MethodEmptyName', 'MethodNotFound', 'MethodInvalidSignature'])
}).describe('Import/export resolve error')).or(zod.object({
  "WasmTrap": zod.enum(['Unreachable']).describe('An `unreachable` opcode was executed.').or(zod.enum(['IncorrectCallIndirectSignature']).describe('Call indirect incorrect signature trap.')).or(zod.enum(['MemoryOutOfBounds']).describe('Memory out of bounds trap.')).or(zod.enum(['CallIndirectOOB']).describe('Call indirect out of bounds trap.')).or(zod.enum(['IllegalArithmetic']).describe('An arithmetic exception, e.g. divided by zero.')).or(zod.enum(['MisalignedAtomicAccess']).describe('Misaligned atomic access trap.')).or(zod.enum(['IndirectCallToNull']).describe('Indirect call to null.')).or(zod.enum(['StackOverflow']).describe('Stack overflow.')).or(zod.enum(['GenericTrap']).describe('Generic trap.')).describe('A kind of a trap happened during execution of a binary')
}).describe('A trap happened during execution of a binary\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "HostError": zod.enum(['BadUTF16']).describe('String encoding is bad UTF-16 sequence').or(zod.enum(['BadUTF8']).describe('String encoding is bad UTF-8 sequence')).or(zod.enum(['GasExceeded']).describe('Exceeded the prepaid gas')).or(zod.enum(['GasLimitExceeded']).describe('Exceeded the maximum amount of gas allowed to burn per contract')).or(zod.enum(['BalanceExceeded']).describe('Exceeded the account balance')).or(zod.enum(['EmptyMethodName']).describe('Tried to call an empty method name')).or(zod.object({
  "GuestPanic": zod.object({
  "panic_msg": zod.string()
})
}).describe('Smart contract panicked')).or(zod.enum(['IntegerOverflow']).describe('IntegerOverflow happened during a contract execution')).or(zod.object({
  "InvalidPromiseIndex": zod.object({
  "promise_idx": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMin)
})
}).describe('`promise_idx` does not correspond to existing promises')).or(zod.enum(['CannotAppendActionToJointPromise']).describe('Actions can only be appended to non-joint promise.')).or(zod.enum(['CannotReturnJointPromise']).describe('Returning joint promise is currently prohibited')).or(zod.object({
  "InvalidPromiseResultIndex": zod.object({
  "result_idx": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMin)
})
}).describe('Accessed invalid promise result index')).or(zod.object({
  "InvalidRegisterId": zod.object({
  "register_id": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMin)
})
}).describe('Accessed invalid register id')).or(zod.object({
  "IteratorWasInvalidated": zod.object({
  "iterator_index": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMin)
})
}).describe('Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie')).or(zod.enum(['MemoryAccessViolation']).describe('Accessed memory outside the bounds')).or(zod.object({
  "InvalidReceiptIndex": zod.object({
  "receipt_index": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMin)
})
}).describe('VM Logic returned an invalid receipt index')).or(zod.object({
  "InvalidIteratorIndex": zod.object({
  "iterator_index": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMin)
})
}).describe('Iterator index `iterator_index` does not exist')).or(zod.enum(['InvalidAccountId']).describe('VM Logic returned an invalid account id')).or(zod.enum(['InvalidMethodName']).describe('VM Logic returned an invalid method name')).or(zod.enum(['InvalidPublicKey']).describe('VM Logic provided an invalid public key')).or(zod.object({
  "ProhibitedInView": zod.object({
  "method_name": zod.string()
})
}).describe('`method_name` is not allowed in view calls')).or(zod.object({
  "NumberOfLogsExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMin)
})
}).describe('The total number of logs will exceed the limit.')).or(zod.object({
  "KeyLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMin)
})
}).describe('The storage key length exceeded the limit.')).or(zod.object({
  "ValueLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMin)
})
}).describe('The storage value length exceeded the limit.')).or(zod.object({
  "TotalLogLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMin)
})
}).describe('The total log length exceeded the limit.')).or(zod.object({
  "NumberPromisesExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMin),
  "number_of_promises": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMin)
})
}).describe('The maximum number of promises within a FunctionCall exceeded the limit.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMin),
  "number_of_input_data_dependencies": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin)
})
}).describe('The maximum number of input data dependencies exceeded the limit.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMin)
})
}).describe('The returned value length exceeded the limit.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMin),
  "size": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMin)
})
}).describe('The contract size for DeployContract action exceeded the limit.')).or(zod.object({
  "Deprecated": zod.object({
  "method_name": zod.string()
})
}).describe('The host function was deprecated.')).or(zod.object({
  "ECRecoverError": zod.object({
  "msg": zod.string()
})
}).describe('General errors for ECDSA recover.')).or(zod.object({
  "AltBn128InvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to alt_bn128 family of functions (e.g., point which isn\'t\n on the curve).')).or(zod.object({
  "Ed25519VerifyInvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to ed25519 signature verification function (e.g. signature cannot be\n derived from bytes).'))
}).describe('Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "ExecutionError": zod.string()
})).describe('Serializable version of `near-vm-runner::FunctionCallError`.\n\n Must never reorder/remove elements, can only add new variants at the end (but do that very\n carefully). It describes stable serialization format, and only used by serialization logic.')
}).describe('An error occurred during a `FunctionCall` Action, parameter is debug message.')).or(zod.object({
  "NewReceiptValidationError": zod.object({
  "InvalidPredecessorId": zod.object({
  "account_id": zod.string()
})
}).describe('The `predecessor_id` of a Receipt is not valid.').or(zod.object({
  "InvalidReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a Receipt is not valid.')).or(zod.object({
  "InvalidSignerId": zod.object({
  "account_id": zod.string()
})
}).describe('The `signer_id` of an ActionReceipt is not valid.')).or(zod.object({
  "InvalidDataReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a DataReceiver within an ActionReceipt is not valid.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMin)
})
}).describe('The length of the returned data exceeded the limit in a DataReceipt.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMin),
  "number_of_input_data_dependencies": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin)
})
}).describe('The number of input data dependencies exceeds the limit in an ActionReceipt.')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMin),
  "total_prepaid_gas": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMin),
  "total_number_of_actions": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin),
  "total_number_of_bytes": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMin),
  "size": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMin)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMin)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of an ActionReceipt.')).or(zod.object({
  "ReceiptSizeExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMin),
  "size": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMin)
})
}).describe('Receipt is bigger than the limit.')).describe('Describes the error for validating a receipt.')
}).describe('Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\n receipt validation.')).or(zod.object({
  "OnlyImplicitAccountCreationAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\n See NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\n Also, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\n TODO(#8598): This error is named very poorly. A better name would be\n `OnlyNamedAccountCreationAllowed`.')).or(zod.object({
  "DeleteAccountWithLargeState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Delete account whose state is large is temporarily banned.')).or(zod.enum(['DelegateActionInvalidSignature']).describe('Signature does not match the provided actions and given signer public key.')).or(zod.object({
  "DelegateActionSenderDoesNotMatchTxReceiver": zod.object({
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Receiver of the transaction doesn\'t match Sender of the delegate action')).or(zod.enum(['DelegateActionExpired']).describe('Delegate action has expired. `max_block_height` is less than actual block height.')).or(zod.object({
  "DelegateActionAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('The given public key doesn\'t exist for Sender account')).or(zod.object({
  "DelegateActionInvalidNonce": zod.object({
  "ak_nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMin),
  "delegate_nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMin)
})
}).describe('DelegateAction nonce must be greater sender[public_key].nonce')).or(zod.object({
  "DelegateActionNonceTooLarge": zod.object({
  "delegate_nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMin),
  "upper_bound": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMin)
})
}).describe('DelegateAction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "GlobalContractDoesNotExist": zod.object({
  "identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
})
})).describe('The kind of ActionError happened')
}).describe('An error happened during Action execution')
}).describe('An error happened during Action execution').or(zod.object({
  "InvalidTxError": zod.object({
  "InvalidAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('Happens if a wrong AccessKey used or AccessKey has not enough permissions').or(zod.object({
  "InvalidSignerId": zod.object({
  "signer_id": zod.string()
})
}).describe('TX signer_id is not a valid [`AccountId`]')).or(zod.object({
  "SignerDoesNotExist": zod.object({
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('TX signer_id is not found in a storage')).or(zod.object({
  "InvalidNonce": zod.object({
  "ak_nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorInvalidNonceAkNonceMin),
  "tx_nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorInvalidNonceTxNonceMin)
})
}).describe('Transaction nonce must be strictly greater than `account[access_key].nonce`.')).or(zod.object({
  "NonceTooLarge": zod.object({
  "tx_nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorNonceTooLargeTxNonceMin),
  "upper_bound": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMin)
})
}).describe('Transaction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "InvalidReceiverId": zod.object({
  "receiver_id": zod.string()
})
}).describe('TX receiver_id is not a valid AccountId')).or(zod.enum(['InvalidSignature']).describe('TX signature is not valid')).or(zod.object({
  "NotEnoughBalance": zod.object({
  "balance": zod.string(),
  "cost": zod.string(),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account does not have enough balance to cover TX cost')).or(zod.object({
  "LackBalanceForState": zod.object({
  "amount": zod.string().describe('Required balance to cover the state.'),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which doesn\'t have enough balance to cover storage.')
})
}).describe('Signer account doesn\'t have enough balance after transaction.')).or(zod.enum(['CostOverflow']).describe('An integer overflow occurred during transaction cost estimation.')).or(zod.enum(['InvalidChain']).describe('Transaction parent block hash doesn\'t belong to the current chain')).or(zod.enum(['Expired']).describe('Transaction has expired')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMin),
  "total_prepaid_gas": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMin),
  "total_number_of_actions": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin),
  "total_number_of_bytes": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMin),
  "size": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMin)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMin)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of a Transaction.')).or(zod.object({
  "TransactionSizeExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorTransactionSizeExceededLimitMin),
  "size": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorTransactionSizeExceededSizeMin)
})
}).describe('The size of serialized transaction exceeded the limit.')).or(zod.enum(['InvalidTransactionVersion']).describe('Transaction version is invalid.')).or(zod.object({
  "StorageError": zod.enum(['StorageInternalError']).describe('Key-value db internal failure').or(zod.object({
  "MissingTrieValue": zod.object({
  "context": zod.enum(['TrieIterator']).describe('Missing trie value when reading from TrieIterator.').or(zod.enum(['TriePrefetchingStorage']).describe('Missing trie value when reading from TriePrefetchingStorage.')).or(zod.enum(['TrieMemoryPartialStorage']).describe('Missing trie value when reading from TrieMemoryPartialStorage.')).or(zod.enum(['TrieStorage']).describe('Missing trie value when reading from TrieStorage.')).describe('Contexts in which `StorageError::MissingTrieValue` error might occur.'),
  "hash": zod.string()
})
}).describe('Requested trie value by its hash which is missing in storage.')).or(zod.enum(['UnexpectedTrieValue']).describe('Found trie node which shouldn\'t be part of state. Raised during\n validation of state sync parts where incorrect node was passed.\n TODO (#8997): consider including hash of trie node.')).or(zod.object({
  "StorageInconsistentState": zod.string()
}).describe('Either invalid state or key-value db is corrupted.\n For PartialStorage it cannot be corrupted.\n Error message is unreliable and for debugging purposes only. It\'s also probably ok to\n panic in every place that produces this error.\n We can check if db is corrupted by verifying everything in the state trie.')).or(zod.object({
  "FlatStorageBlockNotSupported": zod.string()
}).describe('Flat storage error, meaning that it doesn\'t support some block anymore.\n We guarantee that such block cannot become final, thus block processing\n must resume normally.')).or(zod.object({
  "MemTrieLoadingError": zod.string()
}).describe('In-memory trie could not be loaded for some reason.')).describe('Errors which may occur during working with trie storages, storing\n trie values (trie nodes and state values) by their hashes.')
})).or(zod.object({
  "ShardCongested": zod.object({
  "congestion_level": zod.number().describe('A value between 0 (no congestion) and 1 (max congestion).'),
  "shard_id": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorShardCongestedShardIdMin).describe('The congested shard.')
})
}).describe('The receiver shard of the transaction is too congested to accept new\n transactions at the moment.')).or(zod.object({
  "ShardStuck": zod.object({
  "missed_chunks": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorShardStuckMissedChunksMin).describe('The number of blocks since the last included chunk of the shard.'),
  "shard_id": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorShardStuckShardIdMin).describe('The shard that fails making progress.')
})
}).describe('The receiver shard of the transaction missed several chunks and rejects\n new transaction until it can make progress again.')).describe('An error happened during TX execution')
}).describe('An error happened during Transaction execution')).describe('Error returned in the ExecutionOutcome in case of failure')
}).describe('The execution has failed with the given error.')).or(zod.object({
  "SuccessValue": zod.string()
}).describe('The execution has succeeded and returned some value or an empty vec encoded in base64.')).describe('Execution status defined by chain.rs:get_final_transaction_result\n FinalExecutionStatus::NotStarted - the tx is not converted to the receipt yet\n FinalExecutionStatus::Started - we have at least 1 receipt, but the first leaf receipt_id (using dfs) hasn\'t finished the execution\n FinalExecutionStatus::Failure - the result of the first leaf receipt_id\n FinalExecutionStatus::SuccessValue - the result of the first leaf receipt_id'),
  "transaction": zod.object({
  "actions": zod.array(zod.enum(['CreateAccount']).or(zod.object({
  "DeployContract": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "FunctionCall": zod.object({
  "args": zod.string(),
  "deposit": zod.string(),
  "gas": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionActionsItemFunctionCallGasMin),
  "method_name": zod.string()
})
})).or(zod.object({
  "Transfer": zod.object({
  "deposit": zod.string()
})
})).or(zod.object({
  "Stake": zod.object({
  "public_key": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "AddKey": zod.object({
  "access_key": zod.object({
  "nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionActionsItemAddKeyAccessKeyNonceMin),
  "permission": zod.enum(['FullAccess']).or(zod.object({
  "FunctionCall": zod.object({
  "allowance": zod.string().nullish(),
  "method_names": zod.array(zod.string()),
  "receiver_id": zod.string()
})
}))
}),
  "public_key": zod.string()
})
})).or(zod.object({
  "DeleteKey": zod.object({
  "public_key": zod.string()
})
})).or(zod.object({
  "DeleteAccount": zod.object({
  "beneficiary_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
})).or(zod.object({
  "Delegate": zod.object({
  "delegate_action": zod.object({
  "actions": zod.array(zod.object({
  "CreateAccount": zod.object({

}).describe('Create account action')
}).describe('Create an (sub)account using a transaction `receiver_id` as an ID for\n a new account ID must pass validation rules described here\n <http://nomicon.io/Primitives/Account.html>.').or(zod.object({
  "DeployContract": zod.object({
  "code": zod.string().describe('WebAssembly binary')
}).describe('Deploy contract action')
}).describe('Sets a Wasm code to a receiver_id')).or(zod.object({
  "FunctionCall": zod.object({
  "args": zod.string(),
  "deposit": zod.string(),
  "gas": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionActionsItemDelegateDelegateActionActionsItemFunctionCallGasMin),
  "method_name": zod.string()
})
})).or(zod.object({
  "Transfer": zod.object({
  "deposit": zod.string()
})
})).or(zod.object({
  "Stake": zod.object({
  "public_key": zod.string().describe('Validator key which will be used to sign transactions on behalf of signer_id'),
  "stake": zod.string().describe('Amount of tokens to stake.')
}).describe('An action which stakes signer_id tokens and setup\'s validator public key')
})).or(zod.object({
  "AddKey": zod.object({
  "access_key": zod.object({
  "nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionActionsItemDelegateDelegateActionActionsItemAddKeyAccessKeyNonceMin).describe('Nonce for this access key, used for tx nonce generation. When access key is created, nonce\n is set to `(block_height - 1) * 1e6` to avoid tx hash collision on access key re-creation.\n See <https://github.com/near/nearcore/issues/3779> for more details.'),
  "permission": zod.object({
  "FunctionCall": zod.object({
  "allowance": zod.string().nullish().describe('Allowance is a balance limit to use by this access key to pay for function call gas and\n transaction fees. When this access key is used, both account balance and the allowance is\n decreased by the same value.\n `None` means unlimited allowance.\n NOTE: To change or increase the allowance, the old access key needs to be deleted and a new\n access key should be created.'),
  "method_names": zod.array(zod.string()).describe('A list of method names that can be used. The access key only allows transactions with the\n function call of one of the given method names.\n Empty list means any method name can be used.'),
  "receiver_id": zod.string().describe('The access key only allows transactions with the given receiver\'s account id.')
}).describe('Grants limited permission to make transactions with FunctionCallActions\n The permission can limit the allowed balance to be spent on the prepaid gas.\n It also restrict the account ID of the receiver for this function call.\n It also can restrict the method name for the allowed function calls.')
}).or(zod.enum(['FullAccess']).describe('Grants full access to the account.\n NOTE: It\'s used to replace account-level public keys.')).describe('Defines permissions for AccessKey').describe('Defines permissions for this access key.')
}).describe('Access key provides limited access to an account. Each access key belongs to some account and\n is identified by a unique (within the account) public key. One account may have large number of\n access keys. Access keys allow to act on behalf of the account by restricting transactions\n that can be issued.\n `account_id,public_key` is a key in the state').describe('An access key with the permission'),
  "public_key": zod.string().describe('A public key which will be associated with an access_key')
})
})).or(zod.object({
  "DeleteKey": zod.object({
  "public_key": zod.string().describe('A public key associated with the access_key to be deleted.')
})
})).or(zod.object({
  "DeleteAccount": zod.object({
  "beneficiary_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
})).or(zod.object({
  "Delegate": zod.object({
  "delegate_action": zod.any(),
  "signature": zod.string()
})
})).or(zod.object({
  "DeployGlobalContract": zod.object({
  "code": zod.string().describe('WebAssembly binary'),
  "deploy_mode": zod.enum(['CodeHash']).describe('Contract is deployed under its code hash.\n Users will be able reference it by that hash.\n This effectively makes the contract immutable.').or(zod.enum(['AccountId']).describe('Contract is deployed under the owner account id.\n Users will be able reference it by that account id.\n This allows the owner to update the contract for all its users.'))
}).describe('Deploy global contract action')
})).or(zod.object({
  "UseGlobalContract": zod.object({
  "contract_identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
}).describe('Use global contract action')
})).describe('This is Action which mustn\'t contain DelegateAction.\n\n This struct is needed to avoid the recursion when Action/DelegateAction is deserialized.\n\n Important: Don\'t make the inner Action public, this must only be constructed\n through the correct interface that ensures the inner Action is actually not\n a delegate action. That would break an assumption of this type, which we use\n in several places. For example, borsh de-/serialization relies on it. If the\n invariant is broken, we may end up with a `Transaction` or `Receipt` that we\n can serialize but deserializing it back causes a parsing error.')).describe('List of actions to be executed.\n\n With the meta transactions MVP defined in NEP-366, nested\n DelegateActions are not allowed. A separate type is used to enforce it.'),
  "max_block_height": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionActionsItemDelegateDelegateActionMaxBlockHeightMin).describe('The maximal height of the block in the blockchain below which the given DelegateAction is valid.'),
  "nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionActionsItemDelegateDelegateActionNonceMin).describe('Nonce to ensure that the same delegate action is not sent twice by a\n relayer and should match for given account\'s `public_key`.\n After this action is processed it will increment.'),
  "public_key": zod.string().describe('Public key used to sign this delegated action.'),
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('Receiver of the delegated actions.'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('Signer of the delegated actions')
}).describe('This action allows to execute the inner actions behalf of the defined sender.'),
  "signature": zod.string()
})
})).or(zod.object({
  "DeployGlobalContract": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "DeployGlobalContractByAccountId": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "UseGlobalContract": zod.object({
  "code_hash": zod.string()
})
})).or(zod.object({
  "UseGlobalContractByAccountId": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}))),
  "hash": zod.string(),
  "nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionNonceMin),
  "priority_fee": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionPriorityFeeMin).optional(),
  "public_key": zod.string(),
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "signature": zod.string(),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}).describe('Signed Transaction'),
  "transaction_outcome": zod.object({
  "block_hash": zod.string(),
  "id": zod.string(),
  "outcome": zod.object({
  "executor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('The id of the account on which the execution happens. For transaction this is signer_id,\n for receipt this is receiver_id.'),
  "gas_burnt": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeGasBurntMin).describe('The amount of the gas burnt by the given transaction or receipt.'),
  "logs": zod.array(zod.string()).describe('Logs from this transaction or receipt.'),
  "metadata": zod.object({
  "gas_profile": zod.array(zod.object({
  "cost": zod.string(),
  "cost_category": zod.string(),
  "gas_used": zod.string()
})).nullish(),
  "version": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeMetadataVersionMin)
}).default(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeMetadataDefault).describe('Execution metadata, versioned'),
  "receipt_ids": zod.array(zod.string()).describe('Receipt IDs generated by this transaction or receipt.'),
  "status": zod.enum(['Unknown']).describe('The execution is pending or unknown.').or(zod.object({
  "Failure": zod.object({
  "ActionError": zod.object({
  "index": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorIndexMin).nullish().describe('Index of the failed action in the transaction.\n Action index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`'),
  "kind": zod.object({
  "AccountAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage').or(zod.object({
  "AccountDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when TX receiver_id doesn\'t exist (but action is not Action::CreateAccount)')).or(zod.object({
  "CreateAccountOnlyByRegistrar": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "registrar_account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A top-level account ID can only be created by registrar.')).or(zod.object({
  "CreateAccountNotAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A newly created account must be under a namespace of the creator account')).or(zod.object({
  "ActorNoPermission": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "actor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\n or the first TX action is a `CreateAccount` action')).or(zod.object({
  "DeleteKeyDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('Account tries to remove an access key that doesn\'t exist')).or(zod.object({
  "AddKeyAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The public key is already used for an existing access key')).or(zod.object({
  "DeleteAccountStaking": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is staking and can not be deleted')).or(zod.object({
  "LackBalanceForState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which needs balance'),
  "amount": zod.string().describe('Balance required to complete an action.')
})
}).describe('ActionReceipt can\'t be completed, because the remaining balance will not be enough to cover storage.')).or(zod.object({
  "TriesToUnstake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is not yet staked, but tries to unstake')).or(zod.object({
  "TriesToStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "balance": zod.string(),
  "locked": zod.string(),
  "stake": zod.string()
})
}).describe('The account doesn\'t have enough balance to increase the stake.')).or(zod.object({
  "InsufficientStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "minimum_stake": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "FunctionCallError": zod.enum(['WasmUnknownError', '_EVMError']).or(zod.object({
  "CompilationError": zod.object({
  "CodeDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).or(zod.object({
  "PrepareError": zod.enum(['Serialization']).describe('Error happened while serializing the module.').or(zod.enum(['Deserialization']).describe('Error happened while deserializing the module.')).or(zod.enum(['InternalMemoryDeclared']).describe('Internal memory declaration has been found in the module.')).or(zod.enum(['GasInstrumentation']).describe('Gas instrumentation failed.\n\n This most likely indicates the module isn\'t valid.')).or(zod.enum(['StackHeightInstrumentation']).describe('Stack instrumentation failed.\n\n This  most likely indicates the module isn\'t valid.')).or(zod.enum(['Instantiate']).describe('Error happened during instantiation.\n\n This might indicate that `start` function trapped, or module isn\'t\n instantiable and/or un-linkable.')).or(zod.enum(['Memory']).describe('Error creating memory.')).or(zod.enum(['TooManyFunctions']).describe('Contract contains too many functions.')).or(zod.enum(['TooManyLocals']).describe('Contract contains too many locals.')).describe('Error that can occur while preparing or executing Wasm smart-contract.')
})).or(zod.object({
  "WasmerCompileError": zod.object({
  "msg": zod.string()
})
}).describe('This is for defense in depth.\n We expect our runtime-independent preparation code to fully catch all invalid wasms,\n but, if it ever misses something we‚Äôll emit this error'))
}).describe('Wasm compilation error')).or(zod.object({
  "LinkError": zod.object({
  "msg": zod.string()
})
}).describe('Wasm binary env link error\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "MethodResolveError": zod.enum(['MethodEmptyName', 'MethodNotFound', 'MethodInvalidSignature'])
}).describe('Import/export resolve error')).or(zod.object({
  "WasmTrap": zod.enum(['Unreachable']).describe('An `unreachable` opcode was executed.').or(zod.enum(['IncorrectCallIndirectSignature']).describe('Call indirect incorrect signature trap.')).or(zod.enum(['MemoryOutOfBounds']).describe('Memory out of bounds trap.')).or(zod.enum(['CallIndirectOOB']).describe('Call indirect out of bounds trap.')).or(zod.enum(['IllegalArithmetic']).describe('An arithmetic exception, e.g. divided by zero.')).or(zod.enum(['MisalignedAtomicAccess']).describe('Misaligned atomic access trap.')).or(zod.enum(['IndirectCallToNull']).describe('Indirect call to null.')).or(zod.enum(['StackOverflow']).describe('Stack overflow.')).or(zod.enum(['GenericTrap']).describe('Generic trap.')).describe('A kind of a trap happened during execution of a binary')
}).describe('A trap happened during execution of a binary\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "HostError": zod.enum(['BadUTF16']).describe('String encoding is bad UTF-16 sequence').or(zod.enum(['BadUTF8']).describe('String encoding is bad UTF-8 sequence')).or(zod.enum(['GasExceeded']).describe('Exceeded the prepaid gas')).or(zod.enum(['GasLimitExceeded']).describe('Exceeded the maximum amount of gas allowed to burn per contract')).or(zod.enum(['BalanceExceeded']).describe('Exceeded the account balance')).or(zod.enum(['EmptyMethodName']).describe('Tried to call an empty method name')).or(zod.object({
  "GuestPanic": zod.object({
  "panic_msg": zod.string()
})
}).describe('Smart contract panicked')).or(zod.enum(['IntegerOverflow']).describe('IntegerOverflow happened during a contract execution')).or(zod.object({
  "InvalidPromiseIndex": zod.object({
  "promise_idx": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMin)
})
}).describe('`promise_idx` does not correspond to existing promises')).or(zod.enum(['CannotAppendActionToJointPromise']).describe('Actions can only be appended to non-joint promise.')).or(zod.enum(['CannotReturnJointPromise']).describe('Returning joint promise is currently prohibited')).or(zod.object({
  "InvalidPromiseResultIndex": zod.object({
  "result_idx": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMin)
})
}).describe('Accessed invalid promise result index')).or(zod.object({
  "InvalidRegisterId": zod.object({
  "register_id": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMin)
})
}).describe('Accessed invalid register id')).or(zod.object({
  "IteratorWasInvalidated": zod.object({
  "iterator_index": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMin)
})
}).describe('Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie')).or(zod.enum(['MemoryAccessViolation']).describe('Accessed memory outside the bounds')).or(zod.object({
  "InvalidReceiptIndex": zod.object({
  "receipt_index": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMin)
})
}).describe('VM Logic returned an invalid receipt index')).or(zod.object({
  "InvalidIteratorIndex": zod.object({
  "iterator_index": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMin)
})
}).describe('Iterator index `iterator_index` does not exist')).or(zod.enum(['InvalidAccountId']).describe('VM Logic returned an invalid account id')).or(zod.enum(['InvalidMethodName']).describe('VM Logic returned an invalid method name')).or(zod.enum(['InvalidPublicKey']).describe('VM Logic provided an invalid public key')).or(zod.object({
  "ProhibitedInView": zod.object({
  "method_name": zod.string()
})
}).describe('`method_name` is not allowed in view calls')).or(zod.object({
  "NumberOfLogsExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMin)
})
}).describe('The total number of logs will exceed the limit.')).or(zod.object({
  "KeyLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMin)
})
}).describe('The storage key length exceeded the limit.')).or(zod.object({
  "ValueLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMin)
})
}).describe('The storage value length exceeded the limit.')).or(zod.object({
  "TotalLogLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMin)
})
}).describe('The total log length exceeded the limit.')).or(zod.object({
  "NumberPromisesExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMin),
  "number_of_promises": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMin)
})
}).describe('The maximum number of promises within a FunctionCall exceeded the limit.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMin),
  "number_of_input_data_dependencies": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin)
})
}).describe('The maximum number of input data dependencies exceeded the limit.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMin)
})
}).describe('The returned value length exceeded the limit.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMin),
  "size": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMin)
})
}).describe('The contract size for DeployContract action exceeded the limit.')).or(zod.object({
  "Deprecated": zod.object({
  "method_name": zod.string()
})
}).describe('The host function was deprecated.')).or(zod.object({
  "ECRecoverError": zod.object({
  "msg": zod.string()
})
}).describe('General errors for ECDSA recover.')).or(zod.object({
  "AltBn128InvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to alt_bn128 family of functions (e.g., point which isn\'t\n on the curve).')).or(zod.object({
  "Ed25519VerifyInvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to ed25519 signature verification function (e.g. signature cannot be\n derived from bytes).'))
}).describe('Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "ExecutionError": zod.string()
})).describe('Serializable version of `near-vm-runner::FunctionCallError`.\n\n Must never reorder/remove elements, can only add new variants at the end (but do that very\n carefully). It describes stable serialization format, and only used by serialization logic.')
}).describe('An error occurred during a `FunctionCall` Action, parameter is debug message.')).or(zod.object({
  "NewReceiptValidationError": zod.object({
  "InvalidPredecessorId": zod.object({
  "account_id": zod.string()
})
}).describe('The `predecessor_id` of a Receipt is not valid.').or(zod.object({
  "InvalidReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a Receipt is not valid.')).or(zod.object({
  "InvalidSignerId": zod.object({
  "account_id": zod.string()
})
}).describe('The `signer_id` of an ActionReceipt is not valid.')).or(zod.object({
  "InvalidDataReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a DataReceiver within an ActionReceipt is not valid.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMin)
})
}).describe('The length of the returned data exceeded the limit in a DataReceipt.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMin),
  "number_of_input_data_dependencies": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin)
})
}).describe('The number of input data dependencies exceeds the limit in an ActionReceipt.')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMin),
  "total_prepaid_gas": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMin),
  "total_number_of_actions": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin),
  "total_number_of_bytes": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMin),
  "size": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMin)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMin)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of an ActionReceipt.')).or(zod.object({
  "ReceiptSizeExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMin),
  "size": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMin)
})
}).describe('Receipt is bigger than the limit.')).describe('Describes the error for validating a receipt.')
}).describe('Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\n receipt validation.')).or(zod.object({
  "OnlyImplicitAccountCreationAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\n See NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\n Also, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\n TODO(#8598): This error is named very poorly. A better name would be\n `OnlyNamedAccountCreationAllowed`.')).or(zod.object({
  "DeleteAccountWithLargeState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Delete account whose state is large is temporarily banned.')).or(zod.enum(['DelegateActionInvalidSignature']).describe('Signature does not match the provided actions and given signer public key.')).or(zod.object({
  "DelegateActionSenderDoesNotMatchTxReceiver": zod.object({
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Receiver of the transaction doesn\'t match Sender of the delegate action')).or(zod.enum(['DelegateActionExpired']).describe('Delegate action has expired. `max_block_height` is less than actual block height.')).or(zod.object({
  "DelegateActionAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('The given public key doesn\'t exist for Sender account')).or(zod.object({
  "DelegateActionInvalidNonce": zod.object({
  "ak_nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMin),
  "delegate_nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMin)
})
}).describe('DelegateAction nonce must be greater sender[public_key].nonce')).or(zod.object({
  "DelegateActionNonceTooLarge": zod.object({
  "delegate_nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMin),
  "upper_bound": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMin)
})
}).describe('DelegateAction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "GlobalContractDoesNotExist": zod.object({
  "identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
})
})).describe('The kind of ActionError happened')
}).describe('An error happened during Action execution')
}).describe('An error happened during Action execution').or(zod.object({
  "InvalidTxError": zod.object({
  "InvalidAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('Happens if a wrong AccessKey used or AccessKey has not enough permissions').or(zod.object({
  "InvalidSignerId": zod.object({
  "signer_id": zod.string()
})
}).describe('TX signer_id is not a valid [`AccountId`]')).or(zod.object({
  "SignerDoesNotExist": zod.object({
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('TX signer_id is not found in a storage')).or(zod.object({
  "InvalidNonce": zod.object({
  "ak_nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorInvalidNonceAkNonceMin),
  "tx_nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorInvalidNonceTxNonceMin)
})
}).describe('Transaction nonce must be strictly greater than `account[access_key].nonce`.')).or(zod.object({
  "NonceTooLarge": zod.object({
  "tx_nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorNonceTooLargeTxNonceMin),
  "upper_bound": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMin)
})
}).describe('Transaction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "InvalidReceiverId": zod.object({
  "receiver_id": zod.string()
})
}).describe('TX receiver_id is not a valid AccountId')).or(zod.enum(['InvalidSignature']).describe('TX signature is not valid')).or(zod.object({
  "NotEnoughBalance": zod.object({
  "balance": zod.string(),
  "cost": zod.string(),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account does not have enough balance to cover TX cost')).or(zod.object({
  "LackBalanceForState": zod.object({
  "amount": zod.string().describe('Required balance to cover the state.'),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which doesn\'t have enough balance to cover storage.')
})
}).describe('Signer account doesn\'t have enough balance after transaction.')).or(zod.enum(['CostOverflow']).describe('An integer overflow occurred during transaction cost estimation.')).or(zod.enum(['InvalidChain']).describe('Transaction parent block hash doesn\'t belong to the current chain')).or(zod.enum(['Expired']).describe('Transaction has expired')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMin),
  "total_prepaid_gas": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMin),
  "total_number_of_actions": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin),
  "total_number_of_bytes": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMin),
  "size": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMin)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMin)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of a Transaction.')).or(zod.object({
  "TransactionSizeExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededLimitMin),
  "size": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededSizeMin)
})
}).describe('The size of serialized transaction exceeded the limit.')).or(zod.enum(['InvalidTransactionVersion']).describe('Transaction version is invalid.')).or(zod.object({
  "StorageError": zod.enum(['StorageInternalError']).describe('Key-value db internal failure').or(zod.object({
  "MissingTrieValue": zod.object({
  "context": zod.enum(['TrieIterator']).describe('Missing trie value when reading from TrieIterator.').or(zod.enum(['TriePrefetchingStorage']).describe('Missing trie value when reading from TriePrefetchingStorage.')).or(zod.enum(['TrieMemoryPartialStorage']).describe('Missing trie value when reading from TrieMemoryPartialStorage.')).or(zod.enum(['TrieStorage']).describe('Missing trie value when reading from TrieStorage.')).describe('Contexts in which `StorageError::MissingTrieValue` error might occur.'),
  "hash": zod.string()
})
}).describe('Requested trie value by its hash which is missing in storage.')).or(zod.enum(['UnexpectedTrieValue']).describe('Found trie node which shouldn\'t be part of state. Raised during\n validation of state sync parts where incorrect node was passed.\n TODO (#8997): consider including hash of trie node.')).or(zod.object({
  "StorageInconsistentState": zod.string()
}).describe('Either invalid state or key-value db is corrupted.\n For PartialStorage it cannot be corrupted.\n Error message is unreliable and for debugging purposes only. It\'s also probably ok to\n panic in every place that produces this error.\n We can check if db is corrupted by verifying everything in the state trie.')).or(zod.object({
  "FlatStorageBlockNotSupported": zod.string()
}).describe('Flat storage error, meaning that it doesn\'t support some block anymore.\n We guarantee that such block cannot become final, thus block processing\n must resume normally.')).or(zod.object({
  "MemTrieLoadingError": zod.string()
}).describe('In-memory trie could not be loaded for some reason.')).describe('Errors which may occur during working with trie storages, storing\n trie values (trie nodes and state values) by their hashes.')
})).or(zod.object({
  "ShardCongested": zod.object({
  "congestion_level": zod.number().describe('A value between 0 (no congestion) and 1 (max congestion).'),
  "shard_id": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardCongestedShardIdMin).describe('The congested shard.')
})
}).describe('The receiver shard of the transaction is too congested to accept new\n transactions at the moment.')).or(zod.object({
  "ShardStuck": zod.object({
  "missed_chunks": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardStuckMissedChunksMin).describe('The number of blocks since the last included chunk of the shard.'),
  "shard_id": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardStuckShardIdMin).describe('The shard that fails making progress.')
})
}).describe('The receiver shard of the transaction missed several chunks and rejects\n new transaction until it can make progress again.')).describe('An error happened during TX execution')
}).describe('An error happened during Transaction execution')).describe('Error returned in the ExecutionOutcome in case of failure')
}).describe('The execution has failed.')).or(zod.object({
  "SuccessValue": zod.string()
}).describe('The final action succeeded and returned some value or an empty vec encoded in base64.')).or(zod.object({
  "SuccessReceiptId": zod.string()
}).describe('The final action of the receipt returned a promise or the signed transaction was converted\n to a receipt. Contains the receipt_id of the generated receipt.')).describe('Execution status. Contains the result in case of successful execution.'),
  "tokens_burnt": zod.string().describe('The amount of tokens burnt corresponding to the burnt gas amount.\n This value doesn\'t always equal to the `gas_burnt` multiplied by the gas price, because\n the prepaid gas price might be lower than the actual gas price and it creates a deficit.\n `tokens_burnt` also contains the penalty subtracted from refunds, while\n `gas_burnt` only contains the gas that we actually burn for the execution.')
}),
  "proof": zod.array(zod.object({
  "direction": zod.enum(['Left', 'Right']),
  "hash": zod.string()
}))
}).describe('The execution outcome of the signed transaction.')
}).describe('Final execution outcome of the transaction and all of subsequent the receipts. Also includes\n the generated receipt.').or(zod.object({
  "receipts_outcome": zod.array(zod.object({
  "block_hash": zod.string(),
  "id": zod.string(),
  "outcome": zod.object({
  "executor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('The id of the account on which the execution happens. For transaction this is signer_id,\n for receipt this is receiver_id.'),
  "gas_burnt": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeGasBurntMinOne).describe('The amount of the gas burnt by the given transaction or receipt.'),
  "logs": zod.array(zod.string()).describe('Logs from this transaction or receipt.'),
  "metadata": zod.object({
  "gas_profile": zod.array(zod.object({
  "cost": zod.string(),
  "cost_category": zod.string(),
  "gas_used": zod.string()
})).nullish(),
  "version": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeMetadataVersionMinOne)
}).default(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeMetadataDefaultTwo).describe('Execution metadata, versioned'),
  "receipt_ids": zod.array(zod.string()).describe('Receipt IDs generated by this transaction or receipt.'),
  "status": zod.enum(['Unknown']).describe('The execution is pending or unknown.').or(zod.object({
  "Failure": zod.object({
  "ActionError": zod.object({
  "index": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorIndexMinOne).nullish().describe('Index of the failed action in the transaction.\n Action index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`'),
  "kind": zod.object({
  "AccountAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage').or(zod.object({
  "AccountDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when TX receiver_id doesn\'t exist (but action is not Action::CreateAccount)')).or(zod.object({
  "CreateAccountOnlyByRegistrar": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "registrar_account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A top-level account ID can only be created by registrar.')).or(zod.object({
  "CreateAccountNotAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A newly created account must be under a namespace of the creator account')).or(zod.object({
  "ActorNoPermission": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "actor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\n or the first TX action is a `CreateAccount` action')).or(zod.object({
  "DeleteKeyDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('Account tries to remove an access key that doesn\'t exist')).or(zod.object({
  "AddKeyAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The public key is already used for an existing access key')).or(zod.object({
  "DeleteAccountStaking": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is staking and can not be deleted')).or(zod.object({
  "LackBalanceForState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which needs balance'),
  "amount": zod.string().describe('Balance required to complete an action.')
})
}).describe('ActionReceipt can\'t be completed, because the remaining balance will not be enough to cover storage.')).or(zod.object({
  "TriesToUnstake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is not yet staked, but tries to unstake')).or(zod.object({
  "TriesToStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "balance": zod.string(),
  "locked": zod.string(),
  "stake": zod.string()
})
}).describe('The account doesn\'t have enough balance to increase the stake.')).or(zod.object({
  "InsufficientStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "minimum_stake": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "FunctionCallError": zod.enum(['WasmUnknownError', '_EVMError']).or(zod.object({
  "CompilationError": zod.object({
  "CodeDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).or(zod.object({
  "PrepareError": zod.enum(['Serialization']).describe('Error happened while serializing the module.').or(zod.enum(['Deserialization']).describe('Error happened while deserializing the module.')).or(zod.enum(['InternalMemoryDeclared']).describe('Internal memory declaration has been found in the module.')).or(zod.enum(['GasInstrumentation']).describe('Gas instrumentation failed.\n\n This most likely indicates the module isn\'t valid.')).or(zod.enum(['StackHeightInstrumentation']).describe('Stack instrumentation failed.\n\n This  most likely indicates the module isn\'t valid.')).or(zod.enum(['Instantiate']).describe('Error happened during instantiation.\n\n This might indicate that `start` function trapped, or module isn\'t\n instantiable and/or un-linkable.')).or(zod.enum(['Memory']).describe('Error creating memory.')).or(zod.enum(['TooManyFunctions']).describe('Contract contains too many functions.')).or(zod.enum(['TooManyLocals']).describe('Contract contains too many locals.')).describe('Error that can occur while preparing or executing Wasm smart-contract.')
})).or(zod.object({
  "WasmerCompileError": zod.object({
  "msg": zod.string()
})
}).describe('This is for defense in depth.\n We expect our runtime-independent preparation code to fully catch all invalid wasms,\n but, if it ever misses something we‚Äôll emit this error'))
}).describe('Wasm compilation error')).or(zod.object({
  "LinkError": zod.object({
  "msg": zod.string()
})
}).describe('Wasm binary env link error\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "MethodResolveError": zod.enum(['MethodEmptyName', 'MethodNotFound', 'MethodInvalidSignature'])
}).describe('Import/export resolve error')).or(zod.object({
  "WasmTrap": zod.enum(['Unreachable']).describe('An `unreachable` opcode was executed.').or(zod.enum(['IncorrectCallIndirectSignature']).describe('Call indirect incorrect signature trap.')).or(zod.enum(['MemoryOutOfBounds']).describe('Memory out of bounds trap.')).or(zod.enum(['CallIndirectOOB']).describe('Call indirect out of bounds trap.')).or(zod.enum(['IllegalArithmetic']).describe('An arithmetic exception, e.g. divided by zero.')).or(zod.enum(['MisalignedAtomicAccess']).describe('Misaligned atomic access trap.')).or(zod.enum(['IndirectCallToNull']).describe('Indirect call to null.')).or(zod.enum(['StackOverflow']).describe('Stack overflow.')).or(zod.enum(['GenericTrap']).describe('Generic trap.')).describe('A kind of a trap happened during execution of a binary')
}).describe('A trap happened during execution of a binary\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "HostError": zod.enum(['BadUTF16']).describe('String encoding is bad UTF-16 sequence').or(zod.enum(['BadUTF8']).describe('String encoding is bad UTF-8 sequence')).or(zod.enum(['GasExceeded']).describe('Exceeded the prepaid gas')).or(zod.enum(['GasLimitExceeded']).describe('Exceeded the maximum amount of gas allowed to burn per contract')).or(zod.enum(['BalanceExceeded']).describe('Exceeded the account balance')).or(zod.enum(['EmptyMethodName']).describe('Tried to call an empty method name')).or(zod.object({
  "GuestPanic": zod.object({
  "panic_msg": zod.string()
})
}).describe('Smart contract panicked')).or(zod.enum(['IntegerOverflow']).describe('IntegerOverflow happened during a contract execution')).or(zod.object({
  "InvalidPromiseIndex": zod.object({
  "promise_idx": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMinOne)
})
}).describe('`promise_idx` does not correspond to existing promises')).or(zod.enum(['CannotAppendActionToJointPromise']).describe('Actions can only be appended to non-joint promise.')).or(zod.enum(['CannotReturnJointPromise']).describe('Returning joint promise is currently prohibited')).or(zod.object({
  "InvalidPromiseResultIndex": zod.object({
  "result_idx": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMinOne)
})
}).describe('Accessed invalid promise result index')).or(zod.object({
  "InvalidRegisterId": zod.object({
  "register_id": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMinOne)
})
}).describe('Accessed invalid register id')).or(zod.object({
  "IteratorWasInvalidated": zod.object({
  "iterator_index": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMinOne)
})
}).describe('Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie')).or(zod.enum(['MemoryAccessViolation']).describe('Accessed memory outside the bounds')).or(zod.object({
  "InvalidReceiptIndex": zod.object({
  "receipt_index": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMinOne)
})
}).describe('VM Logic returned an invalid receipt index')).or(zod.object({
  "InvalidIteratorIndex": zod.object({
  "iterator_index": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMinOne)
})
}).describe('Iterator index `iterator_index` does not exist')).or(zod.enum(['InvalidAccountId']).describe('VM Logic returned an invalid account id')).or(zod.enum(['InvalidMethodName']).describe('VM Logic returned an invalid method name')).or(zod.enum(['InvalidPublicKey']).describe('VM Logic provided an invalid public key')).or(zod.object({
  "ProhibitedInView": zod.object({
  "method_name": zod.string()
})
}).describe('`method_name` is not allowed in view calls')).or(zod.object({
  "NumberOfLogsExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMinOne)
})
}).describe('The total number of logs will exceed the limit.')).or(zod.object({
  "KeyLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMinOne),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMinOne)
})
}).describe('The storage key length exceeded the limit.')).or(zod.object({
  "ValueLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMinOne),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMinOne)
})
}).describe('The storage value length exceeded the limit.')).or(zod.object({
  "TotalLogLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMinOne),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMinOne)
})
}).describe('The total log length exceeded the limit.')).or(zod.object({
  "NumberPromisesExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMinOne),
  "number_of_promises": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMinOne)
})
}).describe('The maximum number of promises within a FunctionCall exceeded the limit.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMinOne),
  "number_of_input_data_dependencies": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne)
})
}).describe('The maximum number of input data dependencies exceeded the limit.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMinOne),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMinOne)
})
}).describe('The returned value length exceeded the limit.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMinOne),
  "size": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMinOne)
})
}).describe('The contract size for DeployContract action exceeded the limit.')).or(zod.object({
  "Deprecated": zod.object({
  "method_name": zod.string()
})
}).describe('The host function was deprecated.')).or(zod.object({
  "ECRecoverError": zod.object({
  "msg": zod.string()
})
}).describe('General errors for ECDSA recover.')).or(zod.object({
  "AltBn128InvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to alt_bn128 family of functions (e.g., point which isn\'t\n on the curve).')).or(zod.object({
  "Ed25519VerifyInvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to ed25519 signature verification function (e.g. signature cannot be\n derived from bytes).'))
}).describe('Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "ExecutionError": zod.string()
})).describe('Serializable version of `near-vm-runner::FunctionCallError`.\n\n Must never reorder/remove elements, can only add new variants at the end (but do that very\n carefully). It describes stable serialization format, and only used by serialization logic.')
}).describe('An error occurred during a `FunctionCall` Action, parameter is debug message.')).or(zod.object({
  "NewReceiptValidationError": zod.object({
  "InvalidPredecessorId": zod.object({
  "account_id": zod.string()
})
}).describe('The `predecessor_id` of a Receipt is not valid.').or(zod.object({
  "InvalidReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a Receipt is not valid.')).or(zod.object({
  "InvalidSignerId": zod.object({
  "account_id": zod.string()
})
}).describe('The `signer_id` of an ActionReceipt is not valid.')).or(zod.object({
  "InvalidDataReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a DataReceiver within an ActionReceipt is not valid.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMinOne),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMinOne)
})
}).describe('The length of the returned data exceeded the limit in a DataReceipt.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMinOne),
  "number_of_input_data_dependencies": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne)
})
}).describe('The number of input data dependencies exceeds the limit in an ActionReceipt.')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMinOne),
  "total_prepaid_gas": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne),
  "total_number_of_actions": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne),
  "total_number_of_bytes": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMinOne),
  "size": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMinOne)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of an ActionReceipt.')).or(zod.object({
  "ReceiptSizeExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMinOne),
  "size": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMinOne)
})
}).describe('Receipt is bigger than the limit.')).describe('Describes the error for validating a receipt.')
}).describe('Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\n receipt validation.')).or(zod.object({
  "OnlyImplicitAccountCreationAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\n See NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\n Also, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\n TODO(#8598): This error is named very poorly. A better name would be\n `OnlyNamedAccountCreationAllowed`.')).or(zod.object({
  "DeleteAccountWithLargeState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Delete account whose state is large is temporarily banned.')).or(zod.enum(['DelegateActionInvalidSignature']).describe('Signature does not match the provided actions and given signer public key.')).or(zod.object({
  "DelegateActionSenderDoesNotMatchTxReceiver": zod.object({
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Receiver of the transaction doesn\'t match Sender of the delegate action')).or(zod.enum(['DelegateActionExpired']).describe('Delegate action has expired. `max_block_height` is less than actual block height.')).or(zod.object({
  "DelegateActionAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('The given public key doesn\'t exist for Sender account')).or(zod.object({
  "DelegateActionInvalidNonce": zod.object({
  "ak_nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMinOne),
  "delegate_nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMinOne)
})
}).describe('DelegateAction nonce must be greater sender[public_key].nonce')).or(zod.object({
  "DelegateActionNonceTooLarge": zod.object({
  "delegate_nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMinOne),
  "upper_bound": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMinOne)
})
}).describe('DelegateAction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "GlobalContractDoesNotExist": zod.object({
  "identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
})
})).describe('The kind of ActionError happened')
}).describe('An error happened during Action execution')
}).describe('An error happened during Action execution').or(zod.object({
  "InvalidTxError": zod.object({
  "InvalidAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('Happens if a wrong AccessKey used or AccessKey has not enough permissions').or(zod.object({
  "InvalidSignerId": zod.object({
  "signer_id": zod.string()
})
}).describe('TX signer_id is not a valid [`AccountId`]')).or(zod.object({
  "SignerDoesNotExist": zod.object({
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('TX signer_id is not found in a storage')).or(zod.object({
  "InvalidNonce": zod.object({
  "ak_nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorInvalidNonceAkNonceMinOne),
  "tx_nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorInvalidNonceTxNonceMinOne)
})
}).describe('Transaction nonce must be strictly greater than `account[access_key].nonce`.')).or(zod.object({
  "NonceTooLarge": zod.object({
  "tx_nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorNonceTooLargeTxNonceMinOne),
  "upper_bound": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMinOne)
})
}).describe('Transaction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "InvalidReceiverId": zod.object({
  "receiver_id": zod.string()
})
}).describe('TX receiver_id is not a valid AccountId')).or(zod.enum(['InvalidSignature']).describe('TX signature is not valid')).or(zod.object({
  "NotEnoughBalance": zod.object({
  "balance": zod.string(),
  "cost": zod.string(),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account does not have enough balance to cover TX cost')).or(zod.object({
  "LackBalanceForState": zod.object({
  "amount": zod.string().describe('Required balance to cover the state.'),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which doesn\'t have enough balance to cover storage.')
})
}).describe('Signer account doesn\'t have enough balance after transaction.')).or(zod.enum(['CostOverflow']).describe('An integer overflow occurred during transaction cost estimation.')).or(zod.enum(['InvalidChain']).describe('Transaction parent block hash doesn\'t belong to the current chain')).or(zod.enum(['Expired']).describe('Transaction has expired')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMinOne),
  "total_prepaid_gas": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne),
  "total_number_of_actions": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne),
  "total_number_of_bytes": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMinOne),
  "size": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMinOne)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of a Transaction.')).or(zod.object({
  "TransactionSizeExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededLimitMinOne),
  "size": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededSizeMinOne)
})
}).describe('The size of serialized transaction exceeded the limit.')).or(zod.enum(['InvalidTransactionVersion']).describe('Transaction version is invalid.')).or(zod.object({
  "StorageError": zod.enum(['StorageInternalError']).describe('Key-value db internal failure').or(zod.object({
  "MissingTrieValue": zod.object({
  "context": zod.enum(['TrieIterator']).describe('Missing trie value when reading from TrieIterator.').or(zod.enum(['TriePrefetchingStorage']).describe('Missing trie value when reading from TriePrefetchingStorage.')).or(zod.enum(['TrieMemoryPartialStorage']).describe('Missing trie value when reading from TrieMemoryPartialStorage.')).or(zod.enum(['TrieStorage']).describe('Missing trie value when reading from TrieStorage.')).describe('Contexts in which `StorageError::MissingTrieValue` error might occur.'),
  "hash": zod.string()
})
}).describe('Requested trie value by its hash which is missing in storage.')).or(zod.enum(['UnexpectedTrieValue']).describe('Found trie node which shouldn\'t be part of state. Raised during\n validation of state sync parts where incorrect node was passed.\n TODO (#8997): consider including hash of trie node.')).or(zod.object({
  "StorageInconsistentState": zod.string()
}).describe('Either invalid state or key-value db is corrupted.\n For PartialStorage it cannot be corrupted.\n Error message is unreliable and for debugging purposes only. It\'s also probably ok to\n panic in every place that produces this error.\n We can check if db is corrupted by verifying everything in the state trie.')).or(zod.object({
  "FlatStorageBlockNotSupported": zod.string()
}).describe('Flat storage error, meaning that it doesn\'t support some block anymore.\n We guarantee that such block cannot become final, thus block processing\n must resume normally.')).or(zod.object({
  "MemTrieLoadingError": zod.string()
}).describe('In-memory trie could not be loaded for some reason.')).describe('Errors which may occur during working with trie storages, storing\n trie values (trie nodes and state values) by their hashes.')
})).or(zod.object({
  "ShardCongested": zod.object({
  "congestion_level": zod.number().describe('A value between 0 (no congestion) and 1 (max congestion).'),
  "shard_id": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardCongestedShardIdMinOne).describe('The congested shard.')
})
}).describe('The receiver shard of the transaction is too congested to accept new\n transactions at the moment.')).or(zod.object({
  "ShardStuck": zod.object({
  "missed_chunks": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardStuckMissedChunksMinOne).describe('The number of blocks since the last included chunk of the shard.'),
  "shard_id": zod.number().min(eXPERIMENTALTxStatusResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardStuckShardIdMinOne).describe('The shard that fails making progress.')
})
}).describe('The receiver shard of the transaction missed several chunks and rejects\n new transaction until it can make progress again.')).describe('An error happened during TX execution')
}).describe('An error happened during Transaction execution')).describe('Error returned in the ExecutionOutcome in case of failure')
}).describe('The execution has failed.')).or(zod.object({
  "SuccessValue": zod.string()
}).describe('The final action succeeded and returned some value or an empty vec encoded in base64.')).or(zod.object({
  "SuccessReceiptId": zod.string()
}).describe('The final action of the receipt returned a promise or the signed transaction was converted\n to a receipt. Contains the receipt_id of the generated receipt.')).describe('Execution status. Contains the result in case of successful execution.'),
  "tokens_burnt": zod.string().describe('The amount of tokens burnt corresponding to the burnt gas amount.\n This value doesn\'t always equal to the `gas_burnt` multiplied by the gas price, because\n the prepaid gas price might be lower than the actual gas price and it creates a deficit.\n `tokens_burnt` also contains the penalty subtracted from refunds, while\n `gas_burnt` only contains the gas that we actually burn for the execution.')
}),
  "proof": zod.array(zod.object({
  "direction": zod.enum(['Left', 'Right']),
  "hash": zod.string()
}))
})).describe('The execution outcome of receipts.'),
  "status": zod.enum(['NotStarted']).describe('The execution has not yet started.').or(zod.enum(['Started']).describe('The execution has started and still going.')).or(zod.object({
  "Failure": zod.object({
  "ActionError": zod.object({
  "index": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorIndexMinOne).nullish().describe('Index of the failed action in the transaction.\n Action index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`'),
  "kind": zod.object({
  "AccountAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage').or(zod.object({
  "AccountDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when TX receiver_id doesn\'t exist (but action is not Action::CreateAccount)')).or(zod.object({
  "CreateAccountOnlyByRegistrar": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "registrar_account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A top-level account ID can only be created by registrar.')).or(zod.object({
  "CreateAccountNotAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A newly created account must be under a namespace of the creator account')).or(zod.object({
  "ActorNoPermission": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "actor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\n or the first TX action is a `CreateAccount` action')).or(zod.object({
  "DeleteKeyDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('Account tries to remove an access key that doesn\'t exist')).or(zod.object({
  "AddKeyAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The public key is already used for an existing access key')).or(zod.object({
  "DeleteAccountStaking": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is staking and can not be deleted')).or(zod.object({
  "LackBalanceForState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which needs balance'),
  "amount": zod.string().describe('Balance required to complete an action.')
})
}).describe('ActionReceipt can\'t be completed, because the remaining balance will not be enough to cover storage.')).or(zod.object({
  "TriesToUnstake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is not yet staked, but tries to unstake')).or(zod.object({
  "TriesToStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "balance": zod.string(),
  "locked": zod.string(),
  "stake": zod.string()
})
}).describe('The account doesn\'t have enough balance to increase the stake.')).or(zod.object({
  "InsufficientStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "minimum_stake": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "FunctionCallError": zod.enum(['WasmUnknownError', '_EVMError']).or(zod.object({
  "CompilationError": zod.object({
  "CodeDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).or(zod.object({
  "PrepareError": zod.enum(['Serialization']).describe('Error happened while serializing the module.').or(zod.enum(['Deserialization']).describe('Error happened while deserializing the module.')).or(zod.enum(['InternalMemoryDeclared']).describe('Internal memory declaration has been found in the module.')).or(zod.enum(['GasInstrumentation']).describe('Gas instrumentation failed.\n\n This most likely indicates the module isn\'t valid.')).or(zod.enum(['StackHeightInstrumentation']).describe('Stack instrumentation failed.\n\n This  most likely indicates the module isn\'t valid.')).or(zod.enum(['Instantiate']).describe('Error happened during instantiation.\n\n This might indicate that `start` function trapped, or module isn\'t\n instantiable and/or un-linkable.')).or(zod.enum(['Memory']).describe('Error creating memory.')).or(zod.enum(['TooManyFunctions']).describe('Contract contains too many functions.')).or(zod.enum(['TooManyLocals']).describe('Contract contains too many locals.')).describe('Error that can occur while preparing or executing Wasm smart-contract.')
})).or(zod.object({
  "WasmerCompileError": zod.object({
  "msg": zod.string()
})
}).describe('This is for defense in depth.\n We expect our runtime-independent preparation code to fully catch all invalid wasms,\n but, if it ever misses something we‚Äôll emit this error'))
}).describe('Wasm compilation error')).or(zod.object({
  "LinkError": zod.object({
  "msg": zod.string()
})
}).describe('Wasm binary env link error\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "MethodResolveError": zod.enum(['MethodEmptyName', 'MethodNotFound', 'MethodInvalidSignature'])
}).describe('Import/export resolve error')).or(zod.object({
  "WasmTrap": zod.enum(['Unreachable']).describe('An `unreachable` opcode was executed.').or(zod.enum(['IncorrectCallIndirectSignature']).describe('Call indirect incorrect signature trap.')).or(zod.enum(['MemoryOutOfBounds']).describe('Memory out of bounds trap.')).or(zod.enum(['CallIndirectOOB']).describe('Call indirect out of bounds trap.')).or(zod.enum(['IllegalArithmetic']).describe('An arithmetic exception, e.g. divided by zero.')).or(zod.enum(['MisalignedAtomicAccess']).describe('Misaligned atomic access trap.')).or(zod.enum(['IndirectCallToNull']).describe('Indirect call to null.')).or(zod.enum(['StackOverflow']).describe('Stack overflow.')).or(zod.enum(['GenericTrap']).describe('Generic trap.')).describe('A kind of a trap happened during execution of a binary')
}).describe('A trap happened during execution of a binary\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "HostError": zod.enum(['BadUTF16']).describe('String encoding is bad UTF-16 sequence').or(zod.enum(['BadUTF8']).describe('String encoding is bad UTF-8 sequence')).or(zod.enum(['GasExceeded']).describe('Exceeded the prepaid gas')).or(zod.enum(['GasLimitExceeded']).describe('Exceeded the maximum amount of gas allowed to burn per contract')).or(zod.enum(['BalanceExceeded']).describe('Exceeded the account balance')).or(zod.enum(['EmptyMethodName']).describe('Tried to call an empty method name')).or(zod.object({
  "GuestPanic": zod.object({
  "panic_msg": zod.string()
})
}).describe('Smart contract panicked')).or(zod.enum(['IntegerOverflow']).describe('IntegerOverflow happened during a contract execution')).or(zod.object({
  "InvalidPromiseIndex": zod.object({
  "promise_idx": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMinOne)
})
}).describe('`promise_idx` does not correspond to existing promises')).or(zod.enum(['CannotAppendActionToJointPromise']).describe('Actions can only be appended to non-joint promise.')).or(zod.enum(['CannotReturnJointPromise']).describe('Returning joint promise is currently prohibited')).or(zod.object({
  "InvalidPromiseResultIndex": zod.object({
  "result_idx": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMinOne)
})
}).describe('Accessed invalid promise result index')).or(zod.object({
  "InvalidRegisterId": zod.object({
  "register_id": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMinOne)
})
}).describe('Accessed invalid register id')).or(zod.object({
  "IteratorWasInvalidated": zod.object({
  "iterator_index": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMinOne)
})
}).describe('Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie')).or(zod.enum(['MemoryAccessViolation']).describe('Accessed memory outside the bounds')).or(zod.object({
  "InvalidReceiptIndex": zod.object({
  "receipt_index": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMinOne)
})
}).describe('VM Logic returned an invalid receipt index')).or(zod.object({
  "InvalidIteratorIndex": zod.object({
  "iterator_index": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMinOne)
})
}).describe('Iterator index `iterator_index` does not exist')).or(zod.enum(['InvalidAccountId']).describe('VM Logic returned an invalid account id')).or(zod.enum(['InvalidMethodName']).describe('VM Logic returned an invalid method name')).or(zod.enum(['InvalidPublicKey']).describe('VM Logic provided an invalid public key')).or(zod.object({
  "ProhibitedInView": zod.object({
  "method_name": zod.string()
})
}).describe('`method_name` is not allowed in view calls')).or(zod.object({
  "NumberOfLogsExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMinOne)
})
}).describe('The total number of logs will exceed the limit.')).or(zod.object({
  "KeyLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMinOne),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMinOne)
})
}).describe('The storage key length exceeded the limit.')).or(zod.object({
  "ValueLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMinOne),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMinOne)
})
}).describe('The storage value length exceeded the limit.')).or(zod.object({
  "TotalLogLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMinOne),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMinOne)
})
}).describe('The total log length exceeded the limit.')).or(zod.object({
  "NumberPromisesExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMinOne),
  "number_of_promises": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMinOne)
})
}).describe('The maximum number of promises within a FunctionCall exceeded the limit.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMinOne),
  "number_of_input_data_dependencies": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne)
})
}).describe('The maximum number of input data dependencies exceeded the limit.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMinOne),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMinOne)
})
}).describe('The returned value length exceeded the limit.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMinOne),
  "size": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMinOne)
})
}).describe('The contract size for DeployContract action exceeded the limit.')).or(zod.object({
  "Deprecated": zod.object({
  "method_name": zod.string()
})
}).describe('The host function was deprecated.')).or(zod.object({
  "ECRecoverError": zod.object({
  "msg": zod.string()
})
}).describe('General errors for ECDSA recover.')).or(zod.object({
  "AltBn128InvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to alt_bn128 family of functions (e.g., point which isn\'t\n on the curve).')).or(zod.object({
  "Ed25519VerifyInvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to ed25519 signature verification function (e.g. signature cannot be\n derived from bytes).'))
}).describe('Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "ExecutionError": zod.string()
})).describe('Serializable version of `near-vm-runner::FunctionCallError`.\n\n Must never reorder/remove elements, can only add new variants at the end (but do that very\n carefully). It describes stable serialization format, and only used by serialization logic.')
}).describe('An error occurred during a `FunctionCall` Action, parameter is debug message.')).or(zod.object({
  "NewReceiptValidationError": zod.object({
  "InvalidPredecessorId": zod.object({
  "account_id": zod.string()
})
}).describe('The `predecessor_id` of a Receipt is not valid.').or(zod.object({
  "InvalidReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a Receipt is not valid.')).or(zod.object({
  "InvalidSignerId": zod.object({
  "account_id": zod.string()
})
}).describe('The `signer_id` of an ActionReceipt is not valid.')).or(zod.object({
  "InvalidDataReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a DataReceiver within an ActionReceipt is not valid.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMinOne),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMinOne)
})
}).describe('The length of the returned data exceeded the limit in a DataReceipt.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMinOne),
  "number_of_input_data_dependencies": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne)
})
}).describe('The number of input data dependencies exceeds the limit in an ActionReceipt.')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMinOne),
  "total_prepaid_gas": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne),
  "total_number_of_actions": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne),
  "total_number_of_bytes": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMinOne),
  "size": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMinOne)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of an ActionReceipt.')).or(zod.object({
  "ReceiptSizeExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMinOne),
  "size": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMinOne)
})
}).describe('Receipt is bigger than the limit.')).describe('Describes the error for validating a receipt.')
}).describe('Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\n receipt validation.')).or(zod.object({
  "OnlyImplicitAccountCreationAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\n See NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\n Also, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\n TODO(#8598): This error is named very poorly. A better name would be\n `OnlyNamedAccountCreationAllowed`.')).or(zod.object({
  "DeleteAccountWithLargeState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Delete account whose state is large is temporarily banned.')).or(zod.enum(['DelegateActionInvalidSignature']).describe('Signature does not match the provided actions and given signer public key.')).or(zod.object({
  "DelegateActionSenderDoesNotMatchTxReceiver": zod.object({
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Receiver of the transaction doesn\'t match Sender of the delegate action')).or(zod.enum(['DelegateActionExpired']).describe('Delegate action has expired. `max_block_height` is less than actual block height.')).or(zod.object({
  "DelegateActionAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('The given public key doesn\'t exist for Sender account')).or(zod.object({
  "DelegateActionInvalidNonce": zod.object({
  "ak_nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMinOne),
  "delegate_nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMinOne)
})
}).describe('DelegateAction nonce must be greater sender[public_key].nonce')).or(zod.object({
  "DelegateActionNonceTooLarge": zod.object({
  "delegate_nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMinOne),
  "upper_bound": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMinOne)
})
}).describe('DelegateAction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "GlobalContractDoesNotExist": zod.object({
  "identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
})
})).describe('The kind of ActionError happened')
}).describe('An error happened during Action execution')
}).describe('An error happened during Action execution').or(zod.object({
  "InvalidTxError": zod.object({
  "InvalidAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('Happens if a wrong AccessKey used or AccessKey has not enough permissions').or(zod.object({
  "InvalidSignerId": zod.object({
  "signer_id": zod.string()
})
}).describe('TX signer_id is not a valid [`AccountId`]')).or(zod.object({
  "SignerDoesNotExist": zod.object({
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('TX signer_id is not found in a storage')).or(zod.object({
  "InvalidNonce": zod.object({
  "ak_nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorInvalidNonceAkNonceMinOne),
  "tx_nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorInvalidNonceTxNonceMinOne)
})
}).describe('Transaction nonce must be strictly greater than `account[access_key].nonce`.')).or(zod.object({
  "NonceTooLarge": zod.object({
  "tx_nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorNonceTooLargeTxNonceMinOne),
  "upper_bound": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMinOne)
})
}).describe('Transaction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "InvalidReceiverId": zod.object({
  "receiver_id": zod.string()
})
}).describe('TX receiver_id is not a valid AccountId')).or(zod.enum(['InvalidSignature']).describe('TX signature is not valid')).or(zod.object({
  "NotEnoughBalance": zod.object({
  "balance": zod.string(),
  "cost": zod.string(),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account does not have enough balance to cover TX cost')).or(zod.object({
  "LackBalanceForState": zod.object({
  "amount": zod.string().describe('Required balance to cover the state.'),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which doesn\'t have enough balance to cover storage.')
})
}).describe('Signer account doesn\'t have enough balance after transaction.')).or(zod.enum(['CostOverflow']).describe('An integer overflow occurred during transaction cost estimation.')).or(zod.enum(['InvalidChain']).describe('Transaction parent block hash doesn\'t belong to the current chain')).or(zod.enum(['Expired']).describe('Transaction has expired')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMinOne),
  "total_prepaid_gas": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne),
  "total_number_of_actions": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne),
  "total_number_of_bytes": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMinOne),
  "size": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMinOne)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of a Transaction.')).or(zod.object({
  "TransactionSizeExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorTransactionSizeExceededLimitMinOne),
  "size": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorTransactionSizeExceededSizeMinOne)
})
}).describe('The size of serialized transaction exceeded the limit.')).or(zod.enum(['InvalidTransactionVersion']).describe('Transaction version is invalid.')).or(zod.object({
  "StorageError": zod.enum(['StorageInternalError']).describe('Key-value db internal failure').or(zod.object({
  "MissingTrieValue": zod.object({
  "context": zod.enum(['TrieIterator']).describe('Missing trie value when reading from TrieIterator.').or(zod.enum(['TriePrefetchingStorage']).describe('Missing trie value when reading from TriePrefetchingStorage.')).or(zod.enum(['TrieMemoryPartialStorage']).describe('Missing trie value when reading from TrieMemoryPartialStorage.')).or(zod.enum(['TrieStorage']).describe('Missing trie value when reading from TrieStorage.')).describe('Contexts in which `StorageError::MissingTrieValue` error might occur.'),
  "hash": zod.string()
})
}).describe('Requested trie value by its hash which is missing in storage.')).or(zod.enum(['UnexpectedTrieValue']).describe('Found trie node which shouldn\'t be part of state. Raised during\n validation of state sync parts where incorrect node was passed.\n TODO (#8997): consider including hash of trie node.')).or(zod.object({
  "StorageInconsistentState": zod.string()
}).describe('Either invalid state or key-value db is corrupted.\n For PartialStorage it cannot be corrupted.\n Error message is unreliable and for debugging purposes only. It\'s also probably ok to\n panic in every place that produces this error.\n We can check if db is corrupted by verifying everything in the state trie.')).or(zod.object({
  "FlatStorageBlockNotSupported": zod.string()
}).describe('Flat storage error, meaning that it doesn\'t support some block anymore.\n We guarantee that such block cannot become final, thus block processing\n must resume normally.')).or(zod.object({
  "MemTrieLoadingError": zod.string()
}).describe('In-memory trie could not be loaded for some reason.')).describe('Errors which may occur during working with trie storages, storing\n trie values (trie nodes and state values) by their hashes.')
})).or(zod.object({
  "ShardCongested": zod.object({
  "congestion_level": zod.number().describe('A value between 0 (no congestion) and 1 (max congestion).'),
  "shard_id": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorShardCongestedShardIdMinOne).describe('The congested shard.')
})
}).describe('The receiver shard of the transaction is too congested to accept new\n transactions at the moment.')).or(zod.object({
  "ShardStuck": zod.object({
  "missed_chunks": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorShardStuckMissedChunksMinOne).describe('The number of blocks since the last included chunk of the shard.'),
  "shard_id": zod.number().min(eXPERIMENTALTxStatusResponseResultStatusFailureInvalidTxErrorShardStuckShardIdMinOne).describe('The shard that fails making progress.')
})
}).describe('The receiver shard of the transaction missed several chunks and rejects\n new transaction until it can make progress again.')).describe('An error happened during TX execution')
}).describe('An error happened during Transaction execution')).describe('Error returned in the ExecutionOutcome in case of failure')
}).describe('The execution has failed with the given error.')).or(zod.object({
  "SuccessValue": zod.string()
}).describe('The execution has succeeded and returned some value or an empty vec encoded in base64.')).describe('Execution status defined by chain.rs:get_final_transaction_result\n FinalExecutionStatus::NotStarted - the tx is not converted to the receipt yet\n FinalExecutionStatus::Started - we have at least 1 receipt, but the first leaf receipt_id (using dfs) hasn\'t finished the execution\n FinalExecutionStatus::Failure - the result of the first leaf receipt_id\n FinalExecutionStatus::SuccessValue - the result of the first leaf receipt_id'),
  "transaction": zod.object({
  "actions": zod.array(zod.enum(['CreateAccount']).or(zod.object({
  "DeployContract": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "FunctionCall": zod.object({
  "args": zod.string(),
  "deposit": zod.string(),
  "gas": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionActionsItemFunctionCallGasMinOne),
  "method_name": zod.string()
})
})).or(zod.object({
  "Transfer": zod.object({
  "deposit": zod.string()
})
})).or(zod.object({
  "Stake": zod.object({
  "public_key": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "AddKey": zod.object({
  "access_key": zod.object({
  "nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionActionsItemAddKeyAccessKeyNonceMinOne),
  "permission": zod.enum(['FullAccess']).or(zod.object({
  "FunctionCall": zod.object({
  "allowance": zod.string().nullish(),
  "method_names": zod.array(zod.string()),
  "receiver_id": zod.string()
})
}))
}),
  "public_key": zod.string()
})
})).or(zod.object({
  "DeleteKey": zod.object({
  "public_key": zod.string()
})
})).or(zod.object({
  "DeleteAccount": zod.object({
  "beneficiary_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
})).or(zod.object({
  "Delegate": zod.object({
  "delegate_action": zod.object({
  "actions": zod.array(zod.object({
  "CreateAccount": zod.object({

}).describe('Create account action')
}).describe('Create an (sub)account using a transaction `receiver_id` as an ID for\n a new account ID must pass validation rules described here\n <http://nomicon.io/Primitives/Account.html>.').or(zod.object({
  "DeployContract": zod.object({
  "code": zod.string().describe('WebAssembly binary')
}).describe('Deploy contract action')
}).describe('Sets a Wasm code to a receiver_id')).or(zod.object({
  "FunctionCall": zod.object({
  "args": zod.string(),
  "deposit": zod.string(),
  "gas": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionActionsItemDelegateDelegateActionActionsItemFunctionCallGasMinOne),
  "method_name": zod.string()
})
})).or(zod.object({
  "Transfer": zod.object({
  "deposit": zod.string()
})
})).or(zod.object({
  "Stake": zod.object({
  "public_key": zod.string().describe('Validator key which will be used to sign transactions on behalf of signer_id'),
  "stake": zod.string().describe('Amount of tokens to stake.')
}).describe('An action which stakes signer_id tokens and setup\'s validator public key')
})).or(zod.object({
  "AddKey": zod.object({
  "access_key": zod.object({
  "nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionActionsItemDelegateDelegateActionActionsItemAddKeyAccessKeyNonceMinOne).describe('Nonce for this access key, used for tx nonce generation. When access key is created, nonce\n is set to `(block_height - 1) * 1e6` to avoid tx hash collision on access key re-creation.\n See <https://github.com/near/nearcore/issues/3779> for more details.'),
  "permission": zod.object({
  "FunctionCall": zod.object({
  "allowance": zod.string().nullish().describe('Allowance is a balance limit to use by this access key to pay for function call gas and\n transaction fees. When this access key is used, both account balance and the allowance is\n decreased by the same value.\n `None` means unlimited allowance.\n NOTE: To change or increase the allowance, the old access key needs to be deleted and a new\n access key should be created.'),
  "method_names": zod.array(zod.string()).describe('A list of method names that can be used. The access key only allows transactions with the\n function call of one of the given method names.\n Empty list means any method name can be used.'),
  "receiver_id": zod.string().describe('The access key only allows transactions with the given receiver\'s account id.')
}).describe('Grants limited permission to make transactions with FunctionCallActions\n The permission can limit the allowed balance to be spent on the prepaid gas.\n It also restrict the account ID of the receiver for this function call.\n It also can restrict the method name for the allowed function calls.')
}).or(zod.enum(['FullAccess']).describe('Grants full access to the account.\n NOTE: It\'s used to replace account-level public keys.')).describe('Defines permissions for AccessKey').describe('Defines permissions for this access key.')
}).describe('Access key provides limited access to an account. Each access key belongs to some account and\n is identified by a unique (within the account) public key. One account may have large number of\n access keys. Access keys allow to act on behalf of the account by restricting transactions\n that can be issued.\n `account_id,public_key` is a key in the state').describe('An access key with the permission'),
  "public_key": zod.string().describe('A public key which will be associated with an access_key')
})
})).or(zod.object({
  "DeleteKey": zod.object({
  "public_key": zod.string().describe('A public key associated with the access_key to be deleted.')
})
})).or(zod.object({
  "DeleteAccount": zod.object({
  "beneficiary_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
})).or(zod.object({
  "Delegate": zod.object({
  "delegate_action": zod.any(),
  "signature": zod.string()
})
})).or(zod.object({
  "DeployGlobalContract": zod.object({
  "code": zod.string().describe('WebAssembly binary'),
  "deploy_mode": zod.enum(['CodeHash']).describe('Contract is deployed under its code hash.\n Users will be able reference it by that hash.\n This effectively makes the contract immutable.').or(zod.enum(['AccountId']).describe('Contract is deployed under the owner account id.\n Users will be able reference it by that account id.\n This allows the owner to update the contract for all its users.'))
}).describe('Deploy global contract action')
})).or(zod.object({
  "UseGlobalContract": zod.object({
  "contract_identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
}).describe('Use global contract action')
})).describe('This is Action which mustn\'t contain DelegateAction.\n\n This struct is needed to avoid the recursion when Action/DelegateAction is deserialized.\n\n Important: Don\'t make the inner Action public, this must only be constructed\n through the correct interface that ensures the inner Action is actually not\n a delegate action. That would break an assumption of this type, which we use\n in several places. For example, borsh de-/serialization relies on it. If the\n invariant is broken, we may end up with a `Transaction` or `Receipt` that we\n can serialize but deserializing it back causes a parsing error.')).describe('List of actions to be executed.\n\n With the meta transactions MVP defined in NEP-366, nested\n DelegateActions are not allowed. A separate type is used to enforce it.'),
  "max_block_height": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionActionsItemDelegateDelegateActionMaxBlockHeightMinOne).describe('The maximal height of the block in the blockchain below which the given DelegateAction is valid.'),
  "nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionActionsItemDelegateDelegateActionNonceMinOne).describe('Nonce to ensure that the same delegate action is not sent twice by a\n relayer and should match for given account\'s `public_key`.\n After this action is processed it will increment.'),
  "public_key": zod.string().describe('Public key used to sign this delegated action.'),
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('Receiver of the delegated actions.'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('Signer of the delegated actions')
}).describe('This action allows to execute the inner actions behalf of the defined sender.'),
  "signature": zod.string()
})
})).or(zod.object({
  "DeployGlobalContract": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "DeployGlobalContractByAccountId": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "UseGlobalContract": zod.object({
  "code_hash": zod.string()
})
})).or(zod.object({
  "UseGlobalContractByAccountId": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}))),
  "hash": zod.string(),
  "nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionNonceMinOne),
  "priority_fee": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionPriorityFeeMinOne).optional(),
  "public_key": zod.string(),
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "signature": zod.string(),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}).describe('Signed Transaction'),
  "transaction_outcome": zod.object({
  "block_hash": zod.string(),
  "id": zod.string(),
  "outcome": zod.object({
  "executor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('The id of the account on which the execution happens. For transaction this is signer_id,\n for receipt this is receiver_id.'),
  "gas_burnt": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeGasBurntMinOne).describe('The amount of the gas burnt by the given transaction or receipt.'),
  "logs": zod.array(zod.string()).describe('Logs from this transaction or receipt.'),
  "metadata": zod.object({
  "gas_profile": zod.array(zod.object({
  "cost": zod.string(),
  "cost_category": zod.string(),
  "gas_used": zod.string()
})).nullish(),
  "version": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeMetadataVersionMinOne)
}).default(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeMetadataDefaultTwo).describe('Execution metadata, versioned'),
  "receipt_ids": zod.array(zod.string()).describe('Receipt IDs generated by this transaction or receipt.'),
  "status": zod.enum(['Unknown']).describe('The execution is pending or unknown.').or(zod.object({
  "Failure": zod.object({
  "ActionError": zod.object({
  "index": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorIndexMinOne).nullish().describe('Index of the failed action in the transaction.\n Action index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`'),
  "kind": zod.object({
  "AccountAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage').or(zod.object({
  "AccountDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when TX receiver_id doesn\'t exist (but action is not Action::CreateAccount)')).or(zod.object({
  "CreateAccountOnlyByRegistrar": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "registrar_account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A top-level account ID can only be created by registrar.')).or(zod.object({
  "CreateAccountNotAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A newly created account must be under a namespace of the creator account')).or(zod.object({
  "ActorNoPermission": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "actor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\n or the first TX action is a `CreateAccount` action')).or(zod.object({
  "DeleteKeyDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('Account tries to remove an access key that doesn\'t exist')).or(zod.object({
  "AddKeyAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The public key is already used for an existing access key')).or(zod.object({
  "DeleteAccountStaking": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is staking and can not be deleted')).or(zod.object({
  "LackBalanceForState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which needs balance'),
  "amount": zod.string().describe('Balance required to complete an action.')
})
}).describe('ActionReceipt can\'t be completed, because the remaining balance will not be enough to cover storage.')).or(zod.object({
  "TriesToUnstake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is not yet staked, but tries to unstake')).or(zod.object({
  "TriesToStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "balance": zod.string(),
  "locked": zod.string(),
  "stake": zod.string()
})
}).describe('The account doesn\'t have enough balance to increase the stake.')).or(zod.object({
  "InsufficientStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "minimum_stake": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "FunctionCallError": zod.enum(['WasmUnknownError', '_EVMError']).or(zod.object({
  "CompilationError": zod.object({
  "CodeDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).or(zod.object({
  "PrepareError": zod.enum(['Serialization']).describe('Error happened while serializing the module.').or(zod.enum(['Deserialization']).describe('Error happened while deserializing the module.')).or(zod.enum(['InternalMemoryDeclared']).describe('Internal memory declaration has been found in the module.')).or(zod.enum(['GasInstrumentation']).describe('Gas instrumentation failed.\n\n This most likely indicates the module isn\'t valid.')).or(zod.enum(['StackHeightInstrumentation']).describe('Stack instrumentation failed.\n\n This  most likely indicates the module isn\'t valid.')).or(zod.enum(['Instantiate']).describe('Error happened during instantiation.\n\n This might indicate that `start` function trapped, or module isn\'t\n instantiable and/or un-linkable.')).or(zod.enum(['Memory']).describe('Error creating memory.')).or(zod.enum(['TooManyFunctions']).describe('Contract contains too many functions.')).or(zod.enum(['TooManyLocals']).describe('Contract contains too many locals.')).describe('Error that can occur while preparing or executing Wasm smart-contract.')
})).or(zod.object({
  "WasmerCompileError": zod.object({
  "msg": zod.string()
})
}).describe('This is for defense in depth.\n We expect our runtime-independent preparation code to fully catch all invalid wasms,\n but, if it ever misses something we‚Äôll emit this error'))
}).describe('Wasm compilation error')).or(zod.object({
  "LinkError": zod.object({
  "msg": zod.string()
})
}).describe('Wasm binary env link error\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "MethodResolveError": zod.enum(['MethodEmptyName', 'MethodNotFound', 'MethodInvalidSignature'])
}).describe('Import/export resolve error')).or(zod.object({
  "WasmTrap": zod.enum(['Unreachable']).describe('An `unreachable` opcode was executed.').or(zod.enum(['IncorrectCallIndirectSignature']).describe('Call indirect incorrect signature trap.')).or(zod.enum(['MemoryOutOfBounds']).describe('Memory out of bounds trap.')).or(zod.enum(['CallIndirectOOB']).describe('Call indirect out of bounds trap.')).or(zod.enum(['IllegalArithmetic']).describe('An arithmetic exception, e.g. divided by zero.')).or(zod.enum(['MisalignedAtomicAccess']).describe('Misaligned atomic access trap.')).or(zod.enum(['IndirectCallToNull']).describe('Indirect call to null.')).or(zod.enum(['StackOverflow']).describe('Stack overflow.')).or(zod.enum(['GenericTrap']).describe('Generic trap.')).describe('A kind of a trap happened during execution of a binary')
}).describe('A trap happened during execution of a binary\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "HostError": zod.enum(['BadUTF16']).describe('String encoding is bad UTF-16 sequence').or(zod.enum(['BadUTF8']).describe('String encoding is bad UTF-8 sequence')).or(zod.enum(['GasExceeded']).describe('Exceeded the prepaid gas')).or(zod.enum(['GasLimitExceeded']).describe('Exceeded the maximum amount of gas allowed to burn per contract')).or(zod.enum(['BalanceExceeded']).describe('Exceeded the account balance')).or(zod.enum(['EmptyMethodName']).describe('Tried to call an empty method name')).or(zod.object({
  "GuestPanic": zod.object({
  "panic_msg": zod.string()
})
}).describe('Smart contract panicked')).or(zod.enum(['IntegerOverflow']).describe('IntegerOverflow happened during a contract execution')).or(zod.object({
  "InvalidPromiseIndex": zod.object({
  "promise_idx": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMinOne)
})
}).describe('`promise_idx` does not correspond to existing promises')).or(zod.enum(['CannotAppendActionToJointPromise']).describe('Actions can only be appended to non-joint promise.')).or(zod.enum(['CannotReturnJointPromise']).describe('Returning joint promise is currently prohibited')).or(zod.object({
  "InvalidPromiseResultIndex": zod.object({
  "result_idx": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMinOne)
})
}).describe('Accessed invalid promise result index')).or(zod.object({
  "InvalidRegisterId": zod.object({
  "register_id": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMinOne)
})
}).describe('Accessed invalid register id')).or(zod.object({
  "IteratorWasInvalidated": zod.object({
  "iterator_index": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMinOne)
})
}).describe('Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie')).or(zod.enum(['MemoryAccessViolation']).describe('Accessed memory outside the bounds')).or(zod.object({
  "InvalidReceiptIndex": zod.object({
  "receipt_index": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMinOne)
})
}).describe('VM Logic returned an invalid receipt index')).or(zod.object({
  "InvalidIteratorIndex": zod.object({
  "iterator_index": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMinOne)
})
}).describe('Iterator index `iterator_index` does not exist')).or(zod.enum(['InvalidAccountId']).describe('VM Logic returned an invalid account id')).or(zod.enum(['InvalidMethodName']).describe('VM Logic returned an invalid method name')).or(zod.enum(['InvalidPublicKey']).describe('VM Logic provided an invalid public key')).or(zod.object({
  "ProhibitedInView": zod.object({
  "method_name": zod.string()
})
}).describe('`method_name` is not allowed in view calls')).or(zod.object({
  "NumberOfLogsExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMinOne)
})
}).describe('The total number of logs will exceed the limit.')).or(zod.object({
  "KeyLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMinOne),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMinOne)
})
}).describe('The storage key length exceeded the limit.')).or(zod.object({
  "ValueLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMinOne),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMinOne)
})
}).describe('The storage value length exceeded the limit.')).or(zod.object({
  "TotalLogLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMinOne),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMinOne)
})
}).describe('The total log length exceeded the limit.')).or(zod.object({
  "NumberPromisesExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMinOne),
  "number_of_promises": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMinOne)
})
}).describe('The maximum number of promises within a FunctionCall exceeded the limit.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMinOne),
  "number_of_input_data_dependencies": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne)
})
}).describe('The maximum number of input data dependencies exceeded the limit.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMinOne),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMinOne)
})
}).describe('The returned value length exceeded the limit.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMinOne),
  "size": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMinOne)
})
}).describe('The contract size for DeployContract action exceeded the limit.')).or(zod.object({
  "Deprecated": zod.object({
  "method_name": zod.string()
})
}).describe('The host function was deprecated.')).or(zod.object({
  "ECRecoverError": zod.object({
  "msg": zod.string()
})
}).describe('General errors for ECDSA recover.')).or(zod.object({
  "AltBn128InvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to alt_bn128 family of functions (e.g., point which isn\'t\n on the curve).')).or(zod.object({
  "Ed25519VerifyInvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to ed25519 signature verification function (e.g. signature cannot be\n derived from bytes).'))
}).describe('Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "ExecutionError": zod.string()
})).describe('Serializable version of `near-vm-runner::FunctionCallError`.\n\n Must never reorder/remove elements, can only add new variants at the end (but do that very\n carefully). It describes stable serialization format, and only used by serialization logic.')
}).describe('An error occurred during a `FunctionCall` Action, parameter is debug message.')).or(zod.object({
  "NewReceiptValidationError": zod.object({
  "InvalidPredecessorId": zod.object({
  "account_id": zod.string()
})
}).describe('The `predecessor_id` of a Receipt is not valid.').or(zod.object({
  "InvalidReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a Receipt is not valid.')).or(zod.object({
  "InvalidSignerId": zod.object({
  "account_id": zod.string()
})
}).describe('The `signer_id` of an ActionReceipt is not valid.')).or(zod.object({
  "InvalidDataReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a DataReceiver within an ActionReceipt is not valid.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMinOne),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMinOne)
})
}).describe('The length of the returned data exceeded the limit in a DataReceipt.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMinOne),
  "number_of_input_data_dependencies": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne)
})
}).describe('The number of input data dependencies exceeds the limit in an ActionReceipt.')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMinOne),
  "total_prepaid_gas": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne),
  "total_number_of_actions": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne),
  "total_number_of_bytes": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMinOne),
  "size": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMinOne)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of an ActionReceipt.')).or(zod.object({
  "ReceiptSizeExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMinOne),
  "size": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMinOne)
})
}).describe('Receipt is bigger than the limit.')).describe('Describes the error for validating a receipt.')
}).describe('Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\n receipt validation.')).or(zod.object({
  "OnlyImplicitAccountCreationAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\n See NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\n Also, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\n TODO(#8598): This error is named very poorly. A better name would be\n `OnlyNamedAccountCreationAllowed`.')).or(zod.object({
  "DeleteAccountWithLargeState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Delete account whose state is large is temporarily banned.')).or(zod.enum(['DelegateActionInvalidSignature']).describe('Signature does not match the provided actions and given signer public key.')).or(zod.object({
  "DelegateActionSenderDoesNotMatchTxReceiver": zod.object({
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Receiver of the transaction doesn\'t match Sender of the delegate action')).or(zod.enum(['DelegateActionExpired']).describe('Delegate action has expired. `max_block_height` is less than actual block height.')).or(zod.object({
  "DelegateActionAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('The given public key doesn\'t exist for Sender account')).or(zod.object({
  "DelegateActionInvalidNonce": zod.object({
  "ak_nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMinOne),
  "delegate_nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMinOne)
})
}).describe('DelegateAction nonce must be greater sender[public_key].nonce')).or(zod.object({
  "DelegateActionNonceTooLarge": zod.object({
  "delegate_nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMinOne),
  "upper_bound": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMinOne)
})
}).describe('DelegateAction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "GlobalContractDoesNotExist": zod.object({
  "identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
})
})).describe('The kind of ActionError happened')
}).describe('An error happened during Action execution')
}).describe('An error happened during Action execution').or(zod.object({
  "InvalidTxError": zod.object({
  "InvalidAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('Happens if a wrong AccessKey used or AccessKey has not enough permissions').or(zod.object({
  "InvalidSignerId": zod.object({
  "signer_id": zod.string()
})
}).describe('TX signer_id is not a valid [`AccountId`]')).or(zod.object({
  "SignerDoesNotExist": zod.object({
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('TX signer_id is not found in a storage')).or(zod.object({
  "InvalidNonce": zod.object({
  "ak_nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorInvalidNonceAkNonceMinOne),
  "tx_nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorInvalidNonceTxNonceMinOne)
})
}).describe('Transaction nonce must be strictly greater than `account[access_key].nonce`.')).or(zod.object({
  "NonceTooLarge": zod.object({
  "tx_nonce": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorNonceTooLargeTxNonceMinOne),
  "upper_bound": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMinOne)
})
}).describe('Transaction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "InvalidReceiverId": zod.object({
  "receiver_id": zod.string()
})
}).describe('TX receiver_id is not a valid AccountId')).or(zod.enum(['InvalidSignature']).describe('TX signature is not valid')).or(zod.object({
  "NotEnoughBalance": zod.object({
  "balance": zod.string(),
  "cost": zod.string(),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account does not have enough balance to cover TX cost')).or(zod.object({
  "LackBalanceForState": zod.object({
  "amount": zod.string().describe('Required balance to cover the state.'),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which doesn\'t have enough balance to cover storage.')
})
}).describe('Signer account doesn\'t have enough balance after transaction.')).or(zod.enum(['CostOverflow']).describe('An integer overflow occurred during transaction cost estimation.')).or(zod.enum(['InvalidChain']).describe('Transaction parent block hash doesn\'t belong to the current chain')).or(zod.enum(['Expired']).describe('Transaction has expired')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMinOne),
  "total_prepaid_gas": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne),
  "total_number_of_actions": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne),
  "total_number_of_bytes": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMinOne),
  "size": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMinOne)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne),
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of a Transaction.')).or(zod.object({
  "TransactionSizeExceeded": zod.object({
  "limit": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededLimitMinOne),
  "size": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededSizeMinOne)
})
}).describe('The size of serialized transaction exceeded the limit.')).or(zod.enum(['InvalidTransactionVersion']).describe('Transaction version is invalid.')).or(zod.object({
  "StorageError": zod.enum(['StorageInternalError']).describe('Key-value db internal failure').or(zod.object({
  "MissingTrieValue": zod.object({
  "context": zod.enum(['TrieIterator']).describe('Missing trie value when reading from TrieIterator.').or(zod.enum(['TriePrefetchingStorage']).describe('Missing trie value when reading from TriePrefetchingStorage.')).or(zod.enum(['TrieMemoryPartialStorage']).describe('Missing trie value when reading from TrieMemoryPartialStorage.')).or(zod.enum(['TrieStorage']).describe('Missing trie value when reading from TrieStorage.')).describe('Contexts in which `StorageError::MissingTrieValue` error might occur.'),
  "hash": zod.string()
})
}).describe('Requested trie value by its hash which is missing in storage.')).or(zod.enum(['UnexpectedTrieValue']).describe('Found trie node which shouldn\'t be part of state. Raised during\n validation of state sync parts where incorrect node was passed.\n TODO (#8997): consider including hash of trie node.')).or(zod.object({
  "StorageInconsistentState": zod.string()
}).describe('Either invalid state or key-value db is corrupted.\n For PartialStorage it cannot be corrupted.\n Error message is unreliable and for debugging purposes only. It\'s also probably ok to\n panic in every place that produces this error.\n We can check if db is corrupted by verifying everything in the state trie.')).or(zod.object({
  "FlatStorageBlockNotSupported": zod.string()
}).describe('Flat storage error, meaning that it doesn\'t support some block anymore.\n We guarantee that such block cannot become final, thus block processing\n must resume normally.')).or(zod.object({
  "MemTrieLoadingError": zod.string()
}).describe('In-memory trie could not be loaded for some reason.')).describe('Errors which may occur during working with trie storages, storing\n trie values (trie nodes and state values) by their hashes.')
})).or(zod.object({
  "ShardCongested": zod.object({
  "congestion_level": zod.number().describe('A value between 0 (no congestion) and 1 (max congestion).'),
  "shard_id": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardCongestedShardIdMinOne).describe('The congested shard.')
})
}).describe('The receiver shard of the transaction is too congested to accept new\n transactions at the moment.')).or(zod.object({
  "ShardStuck": zod.object({
  "missed_chunks": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardStuckMissedChunksMinOne).describe('The number of blocks since the last included chunk of the shard.'),
  "shard_id": zod.number().min(eXPERIMENTALTxStatusResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardStuckShardIdMinOne).describe('The shard that fails making progress.')
})
}).describe('The receiver shard of the transaction missed several chunks and rejects\n new transaction until it can make progress again.')).describe('An error happened during TX execution')
}).describe('An error happened during Transaction execution')).describe('Error returned in the ExecutionOutcome in case of failure')
}).describe('The execution has failed.')).or(zod.object({
  "SuccessValue": zod.string()
}).describe('The final action succeeded and returned some value or an empty vec encoded in base64.')).or(zod.object({
  "SuccessReceiptId": zod.string()
}).describe('The final action of the receipt returned a promise or the signed transaction was converted\n to a receipt. Contains the receipt_id of the generated receipt.')).describe('Execution status. Contains the result in case of successful execution.'),
  "tokens_burnt": zod.string().describe('The amount of tokens burnt corresponding to the burnt gas amount.\n This value doesn\'t always equal to the `gas_burnt` multiplied by the gas price, because\n the prepaid gas price might be lower than the actual gas price and it creates a deficit.\n `tokens_burnt` also contains the penalty subtracted from refunds, while\n `gas_burnt` only contains the gas that we actually burn for the execution.')
}),
  "proof": zod.array(zod.object({
  "direction": zod.enum(['Left', 'Right']),
  "hash": zod.string()
}))
}).describe('The execution outcome of the signed transaction.')
}).describe('Execution outcome of the transaction and all the subsequent receipts.\n Could be not finalized yet'))
}).or(zod.object({
  "error": zod.object({
  "cause": zod.object({
  "info": zod.object({
  "method_name": zod.string()
}),
  "name": zod.enum(['METHOD_NOT_FOUND'])
}).or(zod.object({
  "info": zod.object({
  "error_message": zod.string()
}),
  "name": zod.enum(['PARSE_ERROR'])
})),
  "name": zod.enum(['REQUEST_VALIDATION_ERROR'])
}).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['HANDLER_ERROR'])
})).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['INTERNAL_ERROR'])
})).describe('This struct may be returned from JSON RPC server in case of error\n It is expected that this struct has impl From<_> all other RPC errors\n like [RpcBlockError](crate::types::blocks::RpcBlockError)')
}))


export const eXPERIMENTALValidatorsOrderedBodyParamsBlockIdMinTwo = 0;


export const eXPERIMENTALValidatorsOrderedBody = zod.object({
  "id": zod.string(),
  "jsonrpc": zod.string(),
  "method": zod.enum(['EXPERIMENTAL_validators_ordered']),
  "params": zod.object({
  "block_id": zod.number().min(eXPERIMENTALValidatorsOrderedBodyParamsBlockIdMinTwo).or(zod.string()).nullish()
})
})

export const eXPERIMENTALValidatorsOrderedResponse = zod.object({
  "result": zod.array(zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string(),
  "stake": zod.string()
}))
}).or(zod.object({
  "error": zod.object({
  "cause": zod.object({
  "info": zod.object({
  "method_name": zod.string()
}),
  "name": zod.enum(['METHOD_NOT_FOUND'])
}).or(zod.object({
  "info": zod.object({
  "error_message": zod.string()
}),
  "name": zod.enum(['PARSE_ERROR'])
})),
  "name": zod.enum(['REQUEST_VALIDATION_ERROR'])
}).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['HANDLER_ERROR'])
})).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['INTERNAL_ERROR'])
})).describe('This struct may be returned from JSON RPC server in case of error\n It is expected that this struct has impl From<_> all other RPC errors\n like [RpcBlockError](crate::types::blocks::RpcBlockError)')
}))


export const blockBodyParamsBlockIdMinOne = 0;


export const blockBody = zod.object({
  "id": zod.string(),
  "jsonrpc": zod.string(),
  "method": zod.enum(['block']),
  "params": zod.object({
  "block_id": zod.number().min(blockBodyParamsBlockIdMinOne).or(zod.string())
}).or(zod.object({
  "finality": zod.enum(['optimistic', 'near-final', 'final']).describe('Different types of finality.')
})).or(zod.object({
  "sync_checkpoint": zod.enum(['genesis', 'earliest_available'])
}))
})

export const blockResponseResultChunksItemBandwidthRequestsV1RequestsItemRequestedValuesBitmapDataItemMin = 0;
export const blockResponseResultChunksItemBandwidthRequestsV1RequestsItemRequestedValuesBitmapDataMin = 5;

export const blockResponseResultChunksItemBandwidthRequestsV1RequestsItemRequestedValuesBitmapDataMax = 5;
export const blockResponseResultChunksItemBandwidthRequestsV1RequestsItemToShardMin = 0;
export const blockResponseResultChunksItemCongestionInfoAllowedShardMin = 0;
export const blockResponseResultChunksItemCongestionInfoReceiptBytesMin = 0;
export const blockResponseResultChunksItemEncodedLengthMin = 0;
export const blockResponseResultChunksItemGasLimitMin = 0;
export const blockResponseResultChunksItemGasUsedMin = 0;
export const blockResponseResultChunksItemHeightCreatedMin = 0;
export const blockResponseResultChunksItemHeightIncludedMin = 0;
export const blockResponseResultChunksItemShardIdMin = 0;
export const blockResponseResultHeaderBlockOrdinalMin = 0;
export const blockResponseResultHeaderChunkEndorsementsItemItemMin = 0;
export const blockResponseResultHeaderChunksIncludedMin = 0;
export const blockResponseResultHeaderHeightMin = 0;
export const blockResponseResultHeaderLatestProtocolVersionMin = 0;
export const blockResponseResultHeaderPrevHeightMin = 0;
export const blockResponseResultHeaderTimestampMin = 0;


export const blockResponse = zod.object({
  "result": zod.object({
  "author": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "chunks": zod.array(zod.object({
  "balance_burnt": zod.string(),
  "bandwidth_requests": zod.object({
  "V1": zod.object({
  "requests": zod.array(zod.object({
  "requested_values_bitmap": zod.object({
  "data": zod.array(zod.number().min(blockResponseResultChunksItemBandwidthRequestsV1RequestsItemRequestedValuesBitmapDataItemMin)).min(blockResponseResultChunksItemBandwidthRequestsV1RequestsItemRequestedValuesBitmapDataMin).max(blockResponseResultChunksItemBandwidthRequestsV1RequestsItemRequestedValuesBitmapDataMax)
}).describe('Bitmap which describes which values from the predefined list are being requested.\n The nth bit is set to 1 when the nth value from the list is being requested.').describe('Bitmap which describes what values of bandwidth are requested.'),
  "to_shard": zod.number().min(blockResponseResultChunksItemBandwidthRequestsV1RequestsItemToShardMin).describe('Requesting bandwidth to this shard.')
}).describe('`BandwidthRequest` describes the size of receipts that a shard would like to send to another shard.\n When a shard wants to send a lot of receipts to another shard, it needs to create a request and wait\n for a bandwidth grant from the bandwidth scheduler.'))
})
}).describe('A list of shard\'s bandwidth requests.\n Describes how much the shard would like to send to other shards.').nullish(),
  "chunk_hash": zod.string(),
  "congestion_info": zod.object({
  "allowed_shard": zod.number().min(blockResponseResultChunksItemCongestionInfoAllowedShardMin),
  "buffered_receipts_gas": zod.string(),
  "delayed_receipts_gas": zod.string(),
  "receipt_bytes": zod.number().min(blockResponseResultChunksItemCongestionInfoReceiptBytesMin)
}).nullish(),
  "encoded_length": zod.number().min(blockResponseResultChunksItemEncodedLengthMin),
  "encoded_merkle_root": zod.string(),
  "gas_limit": zod.number().min(blockResponseResultChunksItemGasLimitMin),
  "gas_used": zod.number().min(blockResponseResultChunksItemGasUsedMin),
  "height_created": zod.number().min(blockResponseResultChunksItemHeightCreatedMin),
  "height_included": zod.number().min(blockResponseResultChunksItemHeightIncludedMin),
  "outcome_root": zod.string(),
  "outgoing_receipts_root": zod.string(),
  "prev_block_hash": zod.string(),
  "prev_state_root": zod.string(),
  "rent_paid": zod.string().describe('TODO(2271): deprecated.'),
  "shard_id": zod.number().min(blockResponseResultChunksItemShardIdMin).describe('The shard identifier. It may be an arbitrary number - it does not need to be\n a number in the range 0..NUM_SHARDS. The shard ids do not need to be\n sequential or contiguous.\n\n The shard id is wrapped in a new type to prevent the old pattern of using\n indices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\n if fully complete it potentially may be simplified to a regular type alias.'),
  "signature": zod.string(),
  "tx_root": zod.string(),
  "validator_proposals": zod.array(zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string(),
  "stake": zod.string()
})),
  "validator_reward": zod.string().describe('TODO(2271): deprecated.')
})),
  "header": zod.object({
  "approvals": zod.array(zod.string().nullable()),
  "block_body_hash": zod.string().nullish(),
  "block_merkle_root": zod.string(),
  "block_ordinal": zod.number().min(blockResponseResultHeaderBlockOrdinalMin).nullish(),
  "challenges_result": zod.array(zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "is_double_sign": zod.boolean()
})),
  "challenges_root": zod.string(),
  "chunk_endorsements": zod.array(zod.array(zod.number().min(blockResponseResultHeaderChunkEndorsementsItemItemMin))).nullish(),
  "chunk_headers_root": zod.string(),
  "chunk_mask": zod.array(zod.boolean()),
  "chunk_receipts_root": zod.string(),
  "chunk_tx_root": zod.string(),
  "chunks_included": zod.number().min(blockResponseResultHeaderChunksIncludedMin),
  "epoch_id": zod.string(),
  "epoch_sync_data_hash": zod.string().nullish(),
  "gas_price": zod.string(),
  "hash": zod.string(),
  "height": zod.number().min(blockResponseResultHeaderHeightMin),
  "last_ds_final_block": zod.string(),
  "last_final_block": zod.string(),
  "latest_protocol_version": zod.number().min(blockResponseResultHeaderLatestProtocolVersionMin),
  "next_bp_hash": zod.string(),
  "next_epoch_id": zod.string(),
  "outcome_root": zod.string(),
  "prev_hash": zod.string(),
  "prev_height": zod.number().min(blockResponseResultHeaderPrevHeightMin).nullish(),
  "prev_state_root": zod.string(),
  "random_value": zod.string(),
  "rent_paid": zod.string().describe('TODO(2271): deprecated.'),
  "signature": zod.string(),
  "timestamp": zod.number().min(blockResponseResultHeaderTimestampMin).describe('Legacy json number. Should not be used.'),
  "timestamp_nanosec": zod.string(),
  "total_supply": zod.string(),
  "validator_proposals": zod.array(zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string(),
  "stake": zod.string()
})),
  "validator_reward": zod.string().describe('TODO(2271): deprecated.')
})
})
}).or(zod.object({
  "error": zod.object({
  "cause": zod.object({
  "info": zod.object({
  "method_name": zod.string()
}),
  "name": zod.enum(['METHOD_NOT_FOUND'])
}).or(zod.object({
  "info": zod.object({
  "error_message": zod.string()
}),
  "name": zod.enum(['PARSE_ERROR'])
})),
  "name": zod.enum(['REQUEST_VALIDATION_ERROR'])
}).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['HANDLER_ERROR'])
})).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['INTERNAL_ERROR'])
})).describe('This struct may be returned from JSON RPC server in case of error\n It is expected that this struct has impl From<_> all other RPC errors\n like [RpcBlockError](crate::types::blocks::RpcBlockError)')
}))


export const broadcastTxAsyncBodyParamsWaitUntilDefault = "EXECUTED_OPTIMISTIC";

export const broadcastTxAsyncBody = zod.object({
  "id": zod.string(),
  "jsonrpc": zod.string(),
  "method": zod.enum(['broadcast_tx_async']),
  "params": zod.object({
  "signed_tx_base64": zod.string(),
  "wait_until": zod.enum(['NONE']).describe('Transaction is waiting to be included into the block').or(zod.enum(['INCLUDED']).describe('Transaction is included into the block. The block may be not finalized yet')).or(zod.enum(['EXECUTED_OPTIMISTIC']).describe('Transaction is included into the block +\n All non-refund transaction receipts finished their execution.\n The corresponding blocks for tx and each receipt may be not finalized yet')).or(zod.enum(['INCLUDED_FINAL']).describe('Transaction is included into finalized block')).or(zod.enum(['EXECUTED']).describe('Transaction is included into finalized block +\n All non-refund transaction receipts finished their execution.\n The corresponding blocks for each receipt may be not finalized yet')).or(zod.enum(['FINAL']).describe('Transaction is included into finalized block +\n Execution of all transaction receipts is finalized, including refund receipts')).default(broadcastTxAsyncBodyParamsWaitUntilDefault)
})
})

export const broadcastTxAsyncResponse = zod.object({
  "result": zod.string()
}).or(zod.object({
  "error": zod.object({
  "cause": zod.object({
  "info": zod.object({
  "method_name": zod.string()
}),
  "name": zod.enum(['METHOD_NOT_FOUND'])
}).or(zod.object({
  "info": zod.object({
  "error_message": zod.string()
}),
  "name": zod.enum(['PARSE_ERROR'])
})),
  "name": zod.enum(['REQUEST_VALIDATION_ERROR'])
}).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['HANDLER_ERROR'])
})).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['INTERNAL_ERROR'])
})).describe('This struct may be returned from JSON RPC server in case of error\n It is expected that this struct has impl From<_> all other RPC errors\n like [RpcBlockError](crate::types::blocks::RpcBlockError)')
}))


export const broadcastTxCommitBodyParamsWaitUntilDefault = "EXECUTED_OPTIMISTIC";

export const broadcastTxCommitBody = zod.object({
  "id": zod.string(),
  "jsonrpc": zod.string(),
  "method": zod.enum(['broadcast_tx_commit']),
  "params": zod.object({
  "signed_tx_base64": zod.string(),
  "wait_until": zod.enum(['NONE']).describe('Transaction is waiting to be included into the block').or(zod.enum(['INCLUDED']).describe('Transaction is included into the block. The block may be not finalized yet')).or(zod.enum(['EXECUTED_OPTIMISTIC']).describe('Transaction is included into the block +\n All non-refund transaction receipts finished their execution.\n The corresponding blocks for tx and each receipt may be not finalized yet')).or(zod.enum(['INCLUDED_FINAL']).describe('Transaction is included into finalized block')).or(zod.enum(['EXECUTED']).describe('Transaction is included into finalized block +\n All non-refund transaction receipts finished their execution.\n The corresponding blocks for each receipt may be not finalized yet')).or(zod.enum(['FINAL']).describe('Transaction is included into finalized block +\n Execution of all transaction receipts is finalized, including refund receipts')).default(broadcastTxCommitBodyParamsWaitUntilDefault)
})
})

export const broadcastTxCommitResponseResultReceiptsItemPriorityDefault = 0;
export const broadcastTxCommitResponseResultReceiptsItemPriorityMin = 0;
export const broadcastTxCommitResponseResultReceiptsItemReceiptActionActionsItemFunctionCallGasMin = 0;
export const broadcastTxCommitResponseResultReceiptsItemReceiptActionActionsItemAddKeyAccessKeyNonceMin = 0;
export const broadcastTxCommitResponseResultReceiptsItemReceiptActionActionsItemDelegateDelegateActionActionsItemFunctionCallGasMin = 0;
export const broadcastTxCommitResponseResultReceiptsItemReceiptActionActionsItemDelegateDelegateActionActionsItemAddKeyAccessKeyNonceMin = 0;
export const broadcastTxCommitResponseResultReceiptsItemReceiptActionActionsItemDelegateDelegateActionMaxBlockHeightMin = 0;
export const broadcastTxCommitResponseResultReceiptsItemReceiptActionActionsItemDelegateDelegateActionNonceMin = 0;
export const broadcastTxCommitResponseResultReceiptsItemReceiptActionIsPromiseYieldDefault = false;export const broadcastTxCommitResponseResultReceiptsItemReceiptDataDataDefault = null;export const broadcastTxCommitResponseResultReceiptsItemReceiptDataIsPromiseResumeDefault = false;export const broadcastTxCommitResponseResultReceiptsItemReceiptGlobalContractDistributionAlreadyDeliveredShardsItemMin = 0;
export const broadcastTxCommitResponseResultReceiptsItemReceiptGlobalContractDistributionTargetShardMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeGasBurntMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeMetadataVersionMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeMetadataDefault = { version: 1 };export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorIndexMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorInvalidNonceAkNonceMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorInvalidNonceTxNonceMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorNonceTooLargeTxNonceMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededLimitMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededSizeMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardCongestedShardIdMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardStuckMissedChunksMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardStuckShardIdMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorIndexMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMin = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMin = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorInvalidNonceAkNonceMin = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorInvalidNonceTxNonceMin = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorNonceTooLargeTxNonceMin = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMin = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMin = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMin = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMin = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMin = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMin = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorTransactionSizeExceededLimitMin = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorTransactionSizeExceededSizeMin = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorShardCongestedShardIdMin = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorShardStuckMissedChunksMin = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorShardStuckShardIdMin = 0;
export const broadcastTxCommitResponseResultTransactionActionsItemFunctionCallGasMin = 0;
export const broadcastTxCommitResponseResultTransactionActionsItemAddKeyAccessKeyNonceMin = 0;
export const broadcastTxCommitResponseResultTransactionActionsItemDelegateDelegateActionActionsItemFunctionCallGasMin = 0;
export const broadcastTxCommitResponseResultTransactionActionsItemDelegateDelegateActionActionsItemAddKeyAccessKeyNonceMin = 0;
export const broadcastTxCommitResponseResultTransactionActionsItemDelegateDelegateActionMaxBlockHeightMin = 0;
export const broadcastTxCommitResponseResultTransactionActionsItemDelegateDelegateActionNonceMin = 0;
export const broadcastTxCommitResponseResultTransactionNonceMin = 0;
export const broadcastTxCommitResponseResultTransactionPriorityFeeDefault = 0;
export const broadcastTxCommitResponseResultTransactionPriorityFeeMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeGasBurntMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeMetadataVersionMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeMetadataDefault = { version: 1 };export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorIndexMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorInvalidNonceAkNonceMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorInvalidNonceTxNonceMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorNonceTooLargeTxNonceMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededLimitMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededSizeMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardCongestedShardIdMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardStuckMissedChunksMin = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardStuckShardIdMin = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeGasBurntMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeMetadataVersionMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeMetadataDefaultTwo = { version: 1 };export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorIndexMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorInvalidNonceAkNonceMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorInvalidNonceTxNonceMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorNonceTooLargeTxNonceMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededSizeMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardCongestedShardIdMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardStuckMissedChunksMinOne = 0;
export const broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardStuckShardIdMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorIndexMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorInvalidNonceAkNonceMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorInvalidNonceTxNonceMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorNonceTooLargeTxNonceMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorTransactionSizeExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorTransactionSizeExceededSizeMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorShardCongestedShardIdMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorShardStuckMissedChunksMinOne = 0;
export const broadcastTxCommitResponseResultStatusFailureInvalidTxErrorShardStuckShardIdMinOne = 0;
export const broadcastTxCommitResponseResultTransactionActionsItemFunctionCallGasMinOne = 0;
export const broadcastTxCommitResponseResultTransactionActionsItemAddKeyAccessKeyNonceMinOne = 0;
export const broadcastTxCommitResponseResultTransactionActionsItemDelegateDelegateActionActionsItemFunctionCallGasMinOne = 0;
export const broadcastTxCommitResponseResultTransactionActionsItemDelegateDelegateActionActionsItemAddKeyAccessKeyNonceMinOne = 0;
export const broadcastTxCommitResponseResultTransactionActionsItemDelegateDelegateActionMaxBlockHeightMinOne = 0;
export const broadcastTxCommitResponseResultTransactionActionsItemDelegateDelegateActionNonceMinOne = 0;
export const broadcastTxCommitResponseResultTransactionNonceMinOne = 0;
export const broadcastTxCommitResponseResultTransactionPriorityFeeDefaultOne = 0;
export const broadcastTxCommitResponseResultTransactionPriorityFeeMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeGasBurntMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeMetadataVersionMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeMetadataDefaultTwo = { version: 1 };export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorIndexMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorInvalidNonceAkNonceMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorInvalidNonceTxNonceMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorNonceTooLargeTxNonceMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededLimitMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededSizeMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardCongestedShardIdMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardStuckMissedChunksMinOne = 0;
export const broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardStuckShardIdMinOne = 0;


export const broadcastTxCommitResponse = zod.object({
  "result": zod.object({
  "receipts": zod.array(zod.object({
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "priority": zod.number().min(broadcastTxCommitResponseResultReceiptsItemPriorityMin).optional(),
  "receipt": zod.object({
  "Action": zod.object({
  "actions": zod.array(zod.enum(['CreateAccount']).or(zod.object({
  "DeployContract": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "FunctionCall": zod.object({
  "args": zod.string(),
  "deposit": zod.string(),
  "gas": zod.number().min(broadcastTxCommitResponseResultReceiptsItemReceiptActionActionsItemFunctionCallGasMin),
  "method_name": zod.string()
})
})).or(zod.object({
  "Transfer": zod.object({
  "deposit": zod.string()
})
})).or(zod.object({
  "Stake": zod.object({
  "public_key": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "AddKey": zod.object({
  "access_key": zod.object({
  "nonce": zod.number().min(broadcastTxCommitResponseResultReceiptsItemReceiptActionActionsItemAddKeyAccessKeyNonceMin),
  "permission": zod.enum(['FullAccess']).or(zod.object({
  "FunctionCall": zod.object({
  "allowance": zod.string().nullish(),
  "method_names": zod.array(zod.string()),
  "receiver_id": zod.string()
})
}))
}),
  "public_key": zod.string()
})
})).or(zod.object({
  "DeleteKey": zod.object({
  "public_key": zod.string()
})
})).or(zod.object({
  "DeleteAccount": zod.object({
  "beneficiary_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
})).or(zod.object({
  "Delegate": zod.object({
  "delegate_action": zod.object({
  "actions": zod.array(zod.object({
  "CreateAccount": zod.object({

}).describe('Create account action')
}).describe('Create an (sub)account using a transaction `receiver_id` as an ID for\n a new account ID must pass validation rules described here\n <http://nomicon.io/Primitives/Account.html>.').or(zod.object({
  "DeployContract": zod.object({
  "code": zod.string().describe('WebAssembly binary')
}).describe('Deploy contract action')
}).describe('Sets a Wasm code to a receiver_id')).or(zod.object({
  "FunctionCall": zod.object({
  "args": zod.string(),
  "deposit": zod.string(),
  "gas": zod.number().min(broadcastTxCommitResponseResultReceiptsItemReceiptActionActionsItemDelegateDelegateActionActionsItemFunctionCallGasMin),
  "method_name": zod.string()
})
})).or(zod.object({
  "Transfer": zod.object({
  "deposit": zod.string()
})
})).or(zod.object({
  "Stake": zod.object({
  "public_key": zod.string().describe('Validator key which will be used to sign transactions on behalf of signer_id'),
  "stake": zod.string().describe('Amount of tokens to stake.')
}).describe('An action which stakes signer_id tokens and setup\'s validator public key')
})).or(zod.object({
  "AddKey": zod.object({
  "access_key": zod.object({
  "nonce": zod.number().min(broadcastTxCommitResponseResultReceiptsItemReceiptActionActionsItemDelegateDelegateActionActionsItemAddKeyAccessKeyNonceMin).describe('Nonce for this access key, used for tx nonce generation. When access key is created, nonce\n is set to `(block_height - 1) * 1e6` to avoid tx hash collision on access key re-creation.\n See <https://github.com/near/nearcore/issues/3779> for more details.'),
  "permission": zod.object({
  "FunctionCall": zod.object({
  "allowance": zod.string().nullish().describe('Allowance is a balance limit to use by this access key to pay for function call gas and\n transaction fees. When this access key is used, both account balance and the allowance is\n decreased by the same value.\n `None` means unlimited allowance.\n NOTE: To change or increase the allowance, the old access key needs to be deleted and a new\n access key should be created.'),
  "method_names": zod.array(zod.string()).describe('A list of method names that can be used. The access key only allows transactions with the\n function call of one of the given method names.\n Empty list means any method name can be used.'),
  "receiver_id": zod.string().describe('The access key only allows transactions with the given receiver\'s account id.')
}).describe('Grants limited permission to make transactions with FunctionCallActions\n The permission can limit the allowed balance to be spent on the prepaid gas.\n It also restrict the account ID of the receiver for this function call.\n It also can restrict the method name for the allowed function calls.')
}).or(zod.enum(['FullAccess']).describe('Grants full access to the account.\n NOTE: It\'s used to replace account-level public keys.')).describe('Defines permissions for AccessKey').describe('Defines permissions for this access key.')
}).describe('Access key provides limited access to an account. Each access key belongs to some account and\n is identified by a unique (within the account) public key. One account may have large number of\n access keys. Access keys allow to act on behalf of the account by restricting transactions\n that can be issued.\n `account_id,public_key` is a key in the state').describe('An access key with the permission'),
  "public_key": zod.string().describe('A public key which will be associated with an access_key')
})
})).or(zod.object({
  "DeleteKey": zod.object({
  "public_key": zod.string().describe('A public key associated with the access_key to be deleted.')
})
})).or(zod.object({
  "DeleteAccount": zod.object({
  "beneficiary_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
})).or(zod.object({
  "Delegate": zod.object({
  "delegate_action": zod.any(),
  "signature": zod.string()
})
})).or(zod.object({
  "DeployGlobalContract": zod.object({
  "code": zod.string().describe('WebAssembly binary'),
  "deploy_mode": zod.enum(['CodeHash']).describe('Contract is deployed under its code hash.\n Users will be able reference it by that hash.\n This effectively makes the contract immutable.').or(zod.enum(['AccountId']).describe('Contract is deployed under the owner account id.\n Users will be able reference it by that account id.\n This allows the owner to update the contract for all its users.'))
}).describe('Deploy global contract action')
})).or(zod.object({
  "UseGlobalContract": zod.object({
  "contract_identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
}).describe('Use global contract action')
})).describe('This is Action which mustn\'t contain DelegateAction.\n\n This struct is needed to avoid the recursion when Action/DelegateAction is deserialized.\n\n Important: Don\'t make the inner Action public, this must only be constructed\n through the correct interface that ensures the inner Action is actually not\n a delegate action. That would break an assumption of this type, which we use\n in several places. For example, borsh de-/serialization relies on it. If the\n invariant is broken, we may end up with a `Transaction` or `Receipt` that we\n can serialize but deserializing it back causes a parsing error.')).describe('List of actions to be executed.\n\n With the meta transactions MVP defined in NEP-366, nested\n DelegateActions are not allowed. A separate type is used to enforce it.'),
  "max_block_height": zod.number().min(broadcastTxCommitResponseResultReceiptsItemReceiptActionActionsItemDelegateDelegateActionMaxBlockHeightMin).describe('The maximal height of the block in the blockchain below which the given DelegateAction is valid.'),
  "nonce": zod.number().min(broadcastTxCommitResponseResultReceiptsItemReceiptActionActionsItemDelegateDelegateActionNonceMin).describe('Nonce to ensure that the same delegate action is not sent twice by a\n relayer and should match for given account\'s `public_key`.\n After this action is processed it will increment.'),
  "public_key": zod.string().describe('Public key used to sign this delegated action.'),
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('Receiver of the delegated actions.'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('Signer of the delegated actions')
}).describe('This action allows to execute the inner actions behalf of the defined sender.'),
  "signature": zod.string()
})
})).or(zod.object({
  "DeployGlobalContract": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "DeployGlobalContractByAccountId": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "UseGlobalContract": zod.object({
  "code_hash": zod.string()
})
})).or(zod.object({
  "UseGlobalContractByAccountId": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}))),
  "gas_price": zod.string(),
  "input_data_ids": zod.array(zod.string()),
  "is_promise_yield": zod.boolean().optional(),
  "output_data_receivers": zod.array(zod.object({
  "data_id": zod.string(),
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "signer_public_key": zod.string()
})
}).or(zod.object({
  "Data": zod.object({
  "data": zod.string().nullish(),
  "data_id": zod.string(),
  "is_promise_resume": zod.boolean().optional()
})
})).or(zod.object({
  "GlobalContractDistribution": zod.object({
  "already_delivered_shards": zod.array(zod.number().min(broadcastTxCommitResponseResultReceiptsItemReceiptGlobalContractDistributionAlreadyDeliveredShardsItemMin).describe('The shard identifier. It may be an arbitrary number - it does not need to be\n a number in the range 0..NUM_SHARDS. The shard ids do not need to be\n sequential or contiguous.\n\n The shard id is wrapped in a new type to prevent the old pattern of using\n indices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\n if fully complete it potentially may be simplified to a regular type alias.')),
  "code": zod.string(),
  "id": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})),
  "target_shard": zod.number().min(broadcastTxCommitResponseResultReceiptsItemReceiptGlobalContractDistributionTargetShardMin).describe('The shard identifier. It may be an arbitrary number - it does not need to be\n a number in the range 0..NUM_SHARDS. The shard ids do not need to be\n sequential or contiguous.\n\n The shard id is wrapped in a new type to prevent the old pattern of using\n indices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\n if fully complete it potentially may be simplified to a regular type alias.')
})
})),
  "receipt_id": zod.string(),
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})).describe('Receipts generated from the transaction'),
  "receipts_outcome": zod.array(zod.object({
  "block_hash": zod.string(),
  "id": zod.string(),
  "outcome": zod.object({
  "executor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('The id of the account on which the execution happens. For transaction this is signer_id,\n for receipt this is receiver_id.'),
  "gas_burnt": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeGasBurntMin).describe('The amount of the gas burnt by the given transaction or receipt.'),
  "logs": zod.array(zod.string()).describe('Logs from this transaction or receipt.'),
  "metadata": zod.object({
  "gas_profile": zod.array(zod.object({
  "cost": zod.string(),
  "cost_category": zod.string(),
  "gas_used": zod.string()
})).nullish(),
  "version": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeMetadataVersionMin)
}).default(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeMetadataDefault).describe('Execution metadata, versioned'),
  "receipt_ids": zod.array(zod.string()).describe('Receipt IDs generated by this transaction or receipt.'),
  "status": zod.enum(['Unknown']).describe('The execution is pending or unknown.').or(zod.object({
  "Failure": zod.object({
  "ActionError": zod.object({
  "index": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorIndexMin).nullish().describe('Index of the failed action in the transaction.\n Action index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`'),
  "kind": zod.object({
  "AccountAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage').or(zod.object({
  "AccountDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when TX receiver_id doesn\'t exist (but action is not Action::CreateAccount)')).or(zod.object({
  "CreateAccountOnlyByRegistrar": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "registrar_account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A top-level account ID can only be created by registrar.')).or(zod.object({
  "CreateAccountNotAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A newly created account must be under a namespace of the creator account')).or(zod.object({
  "ActorNoPermission": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "actor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\n or the first TX action is a `CreateAccount` action')).or(zod.object({
  "DeleteKeyDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('Account tries to remove an access key that doesn\'t exist')).or(zod.object({
  "AddKeyAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The public key is already used for an existing access key')).or(zod.object({
  "DeleteAccountStaking": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is staking and can not be deleted')).or(zod.object({
  "LackBalanceForState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which needs balance'),
  "amount": zod.string().describe('Balance required to complete an action.')
})
}).describe('ActionReceipt can\'t be completed, because the remaining balance will not be enough to cover storage.')).or(zod.object({
  "TriesToUnstake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is not yet staked, but tries to unstake')).or(zod.object({
  "TriesToStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "balance": zod.string(),
  "locked": zod.string(),
  "stake": zod.string()
})
}).describe('The account doesn\'t have enough balance to increase the stake.')).or(zod.object({
  "InsufficientStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "minimum_stake": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "FunctionCallError": zod.enum(['WasmUnknownError', '_EVMError']).or(zod.object({
  "CompilationError": zod.object({
  "CodeDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).or(zod.object({
  "PrepareError": zod.enum(['Serialization']).describe('Error happened while serializing the module.').or(zod.enum(['Deserialization']).describe('Error happened while deserializing the module.')).or(zod.enum(['InternalMemoryDeclared']).describe('Internal memory declaration has been found in the module.')).or(zod.enum(['GasInstrumentation']).describe('Gas instrumentation failed.\n\n This most likely indicates the module isn\'t valid.')).or(zod.enum(['StackHeightInstrumentation']).describe('Stack instrumentation failed.\n\n This  most likely indicates the module isn\'t valid.')).or(zod.enum(['Instantiate']).describe('Error happened during instantiation.\n\n This might indicate that `start` function trapped, or module isn\'t\n instantiable and/or un-linkable.')).or(zod.enum(['Memory']).describe('Error creating memory.')).or(zod.enum(['TooManyFunctions']).describe('Contract contains too many functions.')).or(zod.enum(['TooManyLocals']).describe('Contract contains too many locals.')).describe('Error that can occur while preparing or executing Wasm smart-contract.')
})).or(zod.object({
  "WasmerCompileError": zod.object({
  "msg": zod.string()
})
}).describe('This is for defense in depth.\n We expect our runtime-independent preparation code to fully catch all invalid wasms,\n but, if it ever misses something we‚Äôll emit this error'))
}).describe('Wasm compilation error')).or(zod.object({
  "LinkError": zod.object({
  "msg": zod.string()
})
}).describe('Wasm binary env link error\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "MethodResolveError": zod.enum(['MethodEmptyName', 'MethodNotFound', 'MethodInvalidSignature'])
}).describe('Import/export resolve error')).or(zod.object({
  "WasmTrap": zod.enum(['Unreachable']).describe('An `unreachable` opcode was executed.').or(zod.enum(['IncorrectCallIndirectSignature']).describe('Call indirect incorrect signature trap.')).or(zod.enum(['MemoryOutOfBounds']).describe('Memory out of bounds trap.')).or(zod.enum(['CallIndirectOOB']).describe('Call indirect out of bounds trap.')).or(zod.enum(['IllegalArithmetic']).describe('An arithmetic exception, e.g. divided by zero.')).or(zod.enum(['MisalignedAtomicAccess']).describe('Misaligned atomic access trap.')).or(zod.enum(['IndirectCallToNull']).describe('Indirect call to null.')).or(zod.enum(['StackOverflow']).describe('Stack overflow.')).or(zod.enum(['GenericTrap']).describe('Generic trap.')).describe('A kind of a trap happened during execution of a binary')
}).describe('A trap happened during execution of a binary\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "HostError": zod.enum(['BadUTF16']).describe('String encoding is bad UTF-16 sequence').or(zod.enum(['BadUTF8']).describe('String encoding is bad UTF-8 sequence')).or(zod.enum(['GasExceeded']).describe('Exceeded the prepaid gas')).or(zod.enum(['GasLimitExceeded']).describe('Exceeded the maximum amount of gas allowed to burn per contract')).or(zod.enum(['BalanceExceeded']).describe('Exceeded the account balance')).or(zod.enum(['EmptyMethodName']).describe('Tried to call an empty method name')).or(zod.object({
  "GuestPanic": zod.object({
  "panic_msg": zod.string()
})
}).describe('Smart contract panicked')).or(zod.enum(['IntegerOverflow']).describe('IntegerOverflow happened during a contract execution')).or(zod.object({
  "InvalidPromiseIndex": zod.object({
  "promise_idx": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMin)
})
}).describe('`promise_idx` does not correspond to existing promises')).or(zod.enum(['CannotAppendActionToJointPromise']).describe('Actions can only be appended to non-joint promise.')).or(zod.enum(['CannotReturnJointPromise']).describe('Returning joint promise is currently prohibited')).or(zod.object({
  "InvalidPromiseResultIndex": zod.object({
  "result_idx": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMin)
})
}).describe('Accessed invalid promise result index')).or(zod.object({
  "InvalidRegisterId": zod.object({
  "register_id": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMin)
})
}).describe('Accessed invalid register id')).or(zod.object({
  "IteratorWasInvalidated": zod.object({
  "iterator_index": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMin)
})
}).describe('Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie')).or(zod.enum(['MemoryAccessViolation']).describe('Accessed memory outside the bounds')).or(zod.object({
  "InvalidReceiptIndex": zod.object({
  "receipt_index": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMin)
})
}).describe('VM Logic returned an invalid receipt index')).or(zod.object({
  "InvalidIteratorIndex": zod.object({
  "iterator_index": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMin)
})
}).describe('Iterator index `iterator_index` does not exist')).or(zod.enum(['InvalidAccountId']).describe('VM Logic returned an invalid account id')).or(zod.enum(['InvalidMethodName']).describe('VM Logic returned an invalid method name')).or(zod.enum(['InvalidPublicKey']).describe('VM Logic provided an invalid public key')).or(zod.object({
  "ProhibitedInView": zod.object({
  "method_name": zod.string()
})
}).describe('`method_name` is not allowed in view calls')).or(zod.object({
  "NumberOfLogsExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMin)
})
}).describe('The total number of logs will exceed the limit.')).or(zod.object({
  "KeyLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMin),
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMin)
})
}).describe('The storage key length exceeded the limit.')).or(zod.object({
  "ValueLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMin),
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMin)
})
}).describe('The storage value length exceeded the limit.')).or(zod.object({
  "TotalLogLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMin),
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMin)
})
}).describe('The total log length exceeded the limit.')).or(zod.object({
  "NumberPromisesExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMin),
  "number_of_promises": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMin)
})
}).describe('The maximum number of promises within a FunctionCall exceeded the limit.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMin),
  "number_of_input_data_dependencies": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin)
})
}).describe('The maximum number of input data dependencies exceeded the limit.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMin),
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMin)
})
}).describe('The returned value length exceeded the limit.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMin),
  "size": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMin)
})
}).describe('The contract size for DeployContract action exceeded the limit.')).or(zod.object({
  "Deprecated": zod.object({
  "method_name": zod.string()
})
}).describe('The host function was deprecated.')).or(zod.object({
  "ECRecoverError": zod.object({
  "msg": zod.string()
})
}).describe('General errors for ECDSA recover.')).or(zod.object({
  "AltBn128InvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to alt_bn128 family of functions (e.g., point which isn\'t\n on the curve).')).or(zod.object({
  "Ed25519VerifyInvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to ed25519 signature verification function (e.g. signature cannot be\n derived from bytes).'))
}).describe('Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "ExecutionError": zod.string()
})).describe('Serializable version of `near-vm-runner::FunctionCallError`.\n\n Must never reorder/remove elements, can only add new variants at the end (but do that very\n carefully). It describes stable serialization format, and only used by serialization logic.')
}).describe('An error occurred during a `FunctionCall` Action, parameter is debug message.')).or(zod.object({
  "NewReceiptValidationError": zod.object({
  "InvalidPredecessorId": zod.object({
  "account_id": zod.string()
})
}).describe('The `predecessor_id` of a Receipt is not valid.').or(zod.object({
  "InvalidReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a Receipt is not valid.')).or(zod.object({
  "InvalidSignerId": zod.object({
  "account_id": zod.string()
})
}).describe('The `signer_id` of an ActionReceipt is not valid.')).or(zod.object({
  "InvalidDataReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a DataReceiver within an ActionReceipt is not valid.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMin),
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMin)
})
}).describe('The length of the returned data exceeded the limit in a DataReceipt.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMin),
  "number_of_input_data_dependencies": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin)
})
}).describe('The number of input data dependencies exceeds the limit in an ActionReceipt.')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMin),
  "total_prepaid_gas": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMin),
  "total_number_of_actions": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin),
  "total_number_of_bytes": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMin),
  "size": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMin)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin),
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMin)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of an ActionReceipt.')).or(zod.object({
  "ReceiptSizeExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMin),
  "size": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMin)
})
}).describe('Receipt is bigger than the limit.')).describe('Describes the error for validating a receipt.')
}).describe('Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\n receipt validation.')).or(zod.object({
  "OnlyImplicitAccountCreationAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\n See NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\n Also, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\n TODO(#8598): This error is named very poorly. A better name would be\n `OnlyNamedAccountCreationAllowed`.')).or(zod.object({
  "DeleteAccountWithLargeState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Delete account whose state is large is temporarily banned.')).or(zod.enum(['DelegateActionInvalidSignature']).describe('Signature does not match the provided actions and given signer public key.')).or(zod.object({
  "DelegateActionSenderDoesNotMatchTxReceiver": zod.object({
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Receiver of the transaction doesn\'t match Sender of the delegate action')).or(zod.enum(['DelegateActionExpired']).describe('Delegate action has expired. `max_block_height` is less than actual block height.')).or(zod.object({
  "DelegateActionAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('The given public key doesn\'t exist for Sender account')).or(zod.object({
  "DelegateActionInvalidNonce": zod.object({
  "ak_nonce": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMin),
  "delegate_nonce": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMin)
})
}).describe('DelegateAction nonce must be greater sender[public_key].nonce')).or(zod.object({
  "DelegateActionNonceTooLarge": zod.object({
  "delegate_nonce": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMin),
  "upper_bound": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMin)
})
}).describe('DelegateAction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "GlobalContractDoesNotExist": zod.object({
  "identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
})
})).describe('The kind of ActionError happened')
}).describe('An error happened during Action execution')
}).describe('An error happened during Action execution').or(zod.object({
  "InvalidTxError": zod.object({
  "InvalidAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('Happens if a wrong AccessKey used or AccessKey has not enough permissions').or(zod.object({
  "InvalidSignerId": zod.object({
  "signer_id": zod.string()
})
}).describe('TX signer_id is not a valid [`AccountId`]')).or(zod.object({
  "SignerDoesNotExist": zod.object({
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('TX signer_id is not found in a storage')).or(zod.object({
  "InvalidNonce": zod.object({
  "ak_nonce": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorInvalidNonceAkNonceMin),
  "tx_nonce": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorInvalidNonceTxNonceMin)
})
}).describe('Transaction nonce must be strictly greater than `account[access_key].nonce`.')).or(zod.object({
  "NonceTooLarge": zod.object({
  "tx_nonce": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorNonceTooLargeTxNonceMin),
  "upper_bound": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMin)
})
}).describe('Transaction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "InvalidReceiverId": zod.object({
  "receiver_id": zod.string()
})
}).describe('TX receiver_id is not a valid AccountId')).or(zod.enum(['InvalidSignature']).describe('TX signature is not valid')).or(zod.object({
  "NotEnoughBalance": zod.object({
  "balance": zod.string(),
  "cost": zod.string(),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account does not have enough balance to cover TX cost')).or(zod.object({
  "LackBalanceForState": zod.object({
  "amount": zod.string().describe('Required balance to cover the state.'),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which doesn\'t have enough balance to cover storage.')
})
}).describe('Signer account doesn\'t have enough balance after transaction.')).or(zod.enum(['CostOverflow']).describe('An integer overflow occurred during transaction cost estimation.')).or(zod.enum(['InvalidChain']).describe('Transaction parent block hash doesn\'t belong to the current chain')).or(zod.enum(['Expired']).describe('Transaction has expired')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMin),
  "total_prepaid_gas": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMin),
  "total_number_of_actions": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin),
  "total_number_of_bytes": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMin),
  "size": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMin)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin),
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMin)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of a Transaction.')).or(zod.object({
  "TransactionSizeExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededLimitMin),
  "size": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededSizeMin)
})
}).describe('The size of serialized transaction exceeded the limit.')).or(zod.enum(['InvalidTransactionVersion']).describe('Transaction version is invalid.')).or(zod.object({
  "StorageError": zod.enum(['StorageInternalError']).describe('Key-value db internal failure').or(zod.object({
  "MissingTrieValue": zod.object({
  "context": zod.enum(['TrieIterator']).describe('Missing trie value when reading from TrieIterator.').or(zod.enum(['TriePrefetchingStorage']).describe('Missing trie value when reading from TriePrefetchingStorage.')).or(zod.enum(['TrieMemoryPartialStorage']).describe('Missing trie value when reading from TrieMemoryPartialStorage.')).or(zod.enum(['TrieStorage']).describe('Missing trie value when reading from TrieStorage.')).describe('Contexts in which `StorageError::MissingTrieValue` error might occur.'),
  "hash": zod.string()
})
}).describe('Requested trie value by its hash which is missing in storage.')).or(zod.enum(['UnexpectedTrieValue']).describe('Found trie node which shouldn\'t be part of state. Raised during\n validation of state sync parts where incorrect node was passed.\n TODO (#8997): consider including hash of trie node.')).or(zod.object({
  "StorageInconsistentState": zod.string()
}).describe('Either invalid state or key-value db is corrupted.\n For PartialStorage it cannot be corrupted.\n Error message is unreliable and for debugging purposes only. It\'s also probably ok to\n panic in every place that produces this error.\n We can check if db is corrupted by verifying everything in the state trie.')).or(zod.object({
  "FlatStorageBlockNotSupported": zod.string()
}).describe('Flat storage error, meaning that it doesn\'t support some block anymore.\n We guarantee that such block cannot become final, thus block processing\n must resume normally.')).or(zod.object({
  "MemTrieLoadingError": zod.string()
}).describe('In-memory trie could not be loaded for some reason.')).describe('Errors which may occur during working with trie storages, storing\n trie values (trie nodes and state values) by their hashes.')
})).or(zod.object({
  "ShardCongested": zod.object({
  "congestion_level": zod.number().describe('A value between 0 (no congestion) and 1 (max congestion).'),
  "shard_id": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardCongestedShardIdMin).describe('The congested shard.')
})
}).describe('The receiver shard of the transaction is too congested to accept new\n transactions at the moment.')).or(zod.object({
  "ShardStuck": zod.object({
  "missed_chunks": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardStuckMissedChunksMin).describe('The number of blocks since the last included chunk of the shard.'),
  "shard_id": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardStuckShardIdMin).describe('The shard that fails making progress.')
})
}).describe('The receiver shard of the transaction missed several chunks and rejects\n new transaction until it can make progress again.')).describe('An error happened during TX execution')
}).describe('An error happened during Transaction execution')).describe('Error returned in the ExecutionOutcome in case of failure')
}).describe('The execution has failed.')).or(zod.object({
  "SuccessValue": zod.string()
}).describe('The final action succeeded and returned some value or an empty vec encoded in base64.')).or(zod.object({
  "SuccessReceiptId": zod.string()
}).describe('The final action of the receipt returned a promise or the signed transaction was converted\n to a receipt. Contains the receipt_id of the generated receipt.')).describe('Execution status. Contains the result in case of successful execution.'),
  "tokens_burnt": zod.string().describe('The amount of tokens burnt corresponding to the burnt gas amount.\n This value doesn\'t always equal to the `gas_burnt` multiplied by the gas price, because\n the prepaid gas price might be lower than the actual gas price and it creates a deficit.\n `tokens_burnt` also contains the penalty subtracted from refunds, while\n `gas_burnt` only contains the gas that we actually burn for the execution.')
}),
  "proof": zod.array(zod.object({
  "direction": zod.enum(['Left', 'Right']),
  "hash": zod.string()
}))
})).describe('The execution outcome of receipts.'),
  "status": zod.enum(['NotStarted']).describe('The execution has not yet started.').or(zod.enum(['Started']).describe('The execution has started and still going.')).or(zod.object({
  "Failure": zod.object({
  "ActionError": zod.object({
  "index": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorIndexMin).nullish().describe('Index of the failed action in the transaction.\n Action index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`'),
  "kind": zod.object({
  "AccountAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage').or(zod.object({
  "AccountDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when TX receiver_id doesn\'t exist (but action is not Action::CreateAccount)')).or(zod.object({
  "CreateAccountOnlyByRegistrar": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "registrar_account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A top-level account ID can only be created by registrar.')).or(zod.object({
  "CreateAccountNotAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A newly created account must be under a namespace of the creator account')).or(zod.object({
  "ActorNoPermission": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "actor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\n or the first TX action is a `CreateAccount` action')).or(zod.object({
  "DeleteKeyDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('Account tries to remove an access key that doesn\'t exist')).or(zod.object({
  "AddKeyAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The public key is already used for an existing access key')).or(zod.object({
  "DeleteAccountStaking": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is staking and can not be deleted')).or(zod.object({
  "LackBalanceForState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which needs balance'),
  "amount": zod.string().describe('Balance required to complete an action.')
})
}).describe('ActionReceipt can\'t be completed, because the remaining balance will not be enough to cover storage.')).or(zod.object({
  "TriesToUnstake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is not yet staked, but tries to unstake')).or(zod.object({
  "TriesToStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "balance": zod.string(),
  "locked": zod.string(),
  "stake": zod.string()
})
}).describe('The account doesn\'t have enough balance to increase the stake.')).or(zod.object({
  "InsufficientStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "minimum_stake": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "FunctionCallError": zod.enum(['WasmUnknownError', '_EVMError']).or(zod.object({
  "CompilationError": zod.object({
  "CodeDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).or(zod.object({
  "PrepareError": zod.enum(['Serialization']).describe('Error happened while serializing the module.').or(zod.enum(['Deserialization']).describe('Error happened while deserializing the module.')).or(zod.enum(['InternalMemoryDeclared']).describe('Internal memory declaration has been found in the module.')).or(zod.enum(['GasInstrumentation']).describe('Gas instrumentation failed.\n\n This most likely indicates the module isn\'t valid.')).or(zod.enum(['StackHeightInstrumentation']).describe('Stack instrumentation failed.\n\n This  most likely indicates the module isn\'t valid.')).or(zod.enum(['Instantiate']).describe('Error happened during instantiation.\n\n This might indicate that `start` function trapped, or module isn\'t\n instantiable and/or un-linkable.')).or(zod.enum(['Memory']).describe('Error creating memory.')).or(zod.enum(['TooManyFunctions']).describe('Contract contains too many functions.')).or(zod.enum(['TooManyLocals']).describe('Contract contains too many locals.')).describe('Error that can occur while preparing or executing Wasm smart-contract.')
})).or(zod.object({
  "WasmerCompileError": zod.object({
  "msg": zod.string()
})
}).describe('This is for defense in depth.\n We expect our runtime-independent preparation code to fully catch all invalid wasms,\n but, if it ever misses something we‚Äôll emit this error'))
}).describe('Wasm compilation error')).or(zod.object({
  "LinkError": zod.object({
  "msg": zod.string()
})
}).describe('Wasm binary env link error\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "MethodResolveError": zod.enum(['MethodEmptyName', 'MethodNotFound', 'MethodInvalidSignature'])
}).describe('Import/export resolve error')).or(zod.object({
  "WasmTrap": zod.enum(['Unreachable']).describe('An `unreachable` opcode was executed.').or(zod.enum(['IncorrectCallIndirectSignature']).describe('Call indirect incorrect signature trap.')).or(zod.enum(['MemoryOutOfBounds']).describe('Memory out of bounds trap.')).or(zod.enum(['CallIndirectOOB']).describe('Call indirect out of bounds trap.')).or(zod.enum(['IllegalArithmetic']).describe('An arithmetic exception, e.g. divided by zero.')).or(zod.enum(['MisalignedAtomicAccess']).describe('Misaligned atomic access trap.')).or(zod.enum(['IndirectCallToNull']).describe('Indirect call to null.')).or(zod.enum(['StackOverflow']).describe('Stack overflow.')).or(zod.enum(['GenericTrap']).describe('Generic trap.')).describe('A kind of a trap happened during execution of a binary')
}).describe('A trap happened during execution of a binary\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "HostError": zod.enum(['BadUTF16']).describe('String encoding is bad UTF-16 sequence').or(zod.enum(['BadUTF8']).describe('String encoding is bad UTF-8 sequence')).or(zod.enum(['GasExceeded']).describe('Exceeded the prepaid gas')).or(zod.enum(['GasLimitExceeded']).describe('Exceeded the maximum amount of gas allowed to burn per contract')).or(zod.enum(['BalanceExceeded']).describe('Exceeded the account balance')).or(zod.enum(['EmptyMethodName']).describe('Tried to call an empty method name')).or(zod.object({
  "GuestPanic": zod.object({
  "panic_msg": zod.string()
})
}).describe('Smart contract panicked')).or(zod.enum(['IntegerOverflow']).describe('IntegerOverflow happened during a contract execution')).or(zod.object({
  "InvalidPromiseIndex": zod.object({
  "promise_idx": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMin)
})
}).describe('`promise_idx` does not correspond to existing promises')).or(zod.enum(['CannotAppendActionToJointPromise']).describe('Actions can only be appended to non-joint promise.')).or(zod.enum(['CannotReturnJointPromise']).describe('Returning joint promise is currently prohibited')).or(zod.object({
  "InvalidPromiseResultIndex": zod.object({
  "result_idx": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMin)
})
}).describe('Accessed invalid promise result index')).or(zod.object({
  "InvalidRegisterId": zod.object({
  "register_id": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMin)
})
}).describe('Accessed invalid register id')).or(zod.object({
  "IteratorWasInvalidated": zod.object({
  "iterator_index": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMin)
})
}).describe('Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie')).or(zod.enum(['MemoryAccessViolation']).describe('Accessed memory outside the bounds')).or(zod.object({
  "InvalidReceiptIndex": zod.object({
  "receipt_index": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMin)
})
}).describe('VM Logic returned an invalid receipt index')).or(zod.object({
  "InvalidIteratorIndex": zod.object({
  "iterator_index": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMin)
})
}).describe('Iterator index `iterator_index` does not exist')).or(zod.enum(['InvalidAccountId']).describe('VM Logic returned an invalid account id')).or(zod.enum(['InvalidMethodName']).describe('VM Logic returned an invalid method name')).or(zod.enum(['InvalidPublicKey']).describe('VM Logic provided an invalid public key')).or(zod.object({
  "ProhibitedInView": zod.object({
  "method_name": zod.string()
})
}).describe('`method_name` is not allowed in view calls')).or(zod.object({
  "NumberOfLogsExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMin)
})
}).describe('The total number of logs will exceed the limit.')).or(zod.object({
  "KeyLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMin),
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMin)
})
}).describe('The storage key length exceeded the limit.')).or(zod.object({
  "ValueLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMin),
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMin)
})
}).describe('The storage value length exceeded the limit.')).or(zod.object({
  "TotalLogLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMin),
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMin)
})
}).describe('The total log length exceeded the limit.')).or(zod.object({
  "NumberPromisesExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMin),
  "number_of_promises": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMin)
})
}).describe('The maximum number of promises within a FunctionCall exceeded the limit.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMin),
  "number_of_input_data_dependencies": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin)
})
}).describe('The maximum number of input data dependencies exceeded the limit.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMin),
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMin)
})
}).describe('The returned value length exceeded the limit.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMin),
  "size": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMin)
})
}).describe('The contract size for DeployContract action exceeded the limit.')).or(zod.object({
  "Deprecated": zod.object({
  "method_name": zod.string()
})
}).describe('The host function was deprecated.')).or(zod.object({
  "ECRecoverError": zod.object({
  "msg": zod.string()
})
}).describe('General errors for ECDSA recover.')).or(zod.object({
  "AltBn128InvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to alt_bn128 family of functions (e.g., point which isn\'t\n on the curve).')).or(zod.object({
  "Ed25519VerifyInvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to ed25519 signature verification function (e.g. signature cannot be\n derived from bytes).'))
}).describe('Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "ExecutionError": zod.string()
})).describe('Serializable version of `near-vm-runner::FunctionCallError`.\n\n Must never reorder/remove elements, can only add new variants at the end (but do that very\n carefully). It describes stable serialization format, and only used by serialization logic.')
}).describe('An error occurred during a `FunctionCall` Action, parameter is debug message.')).or(zod.object({
  "NewReceiptValidationError": zod.object({
  "InvalidPredecessorId": zod.object({
  "account_id": zod.string()
})
}).describe('The `predecessor_id` of a Receipt is not valid.').or(zod.object({
  "InvalidReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a Receipt is not valid.')).or(zod.object({
  "InvalidSignerId": zod.object({
  "account_id": zod.string()
})
}).describe('The `signer_id` of an ActionReceipt is not valid.')).or(zod.object({
  "InvalidDataReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a DataReceiver within an ActionReceipt is not valid.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMin),
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMin)
})
}).describe('The length of the returned data exceeded the limit in a DataReceipt.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMin),
  "number_of_input_data_dependencies": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin)
})
}).describe('The number of input data dependencies exceeds the limit in an ActionReceipt.')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMin),
  "total_prepaid_gas": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMin),
  "total_number_of_actions": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin),
  "total_number_of_bytes": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMin),
  "size": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMin)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin),
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMin)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of an ActionReceipt.')).or(zod.object({
  "ReceiptSizeExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMin),
  "size": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMin)
})
}).describe('Receipt is bigger than the limit.')).describe('Describes the error for validating a receipt.')
}).describe('Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\n receipt validation.')).or(zod.object({
  "OnlyImplicitAccountCreationAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\n See NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\n Also, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\n TODO(#8598): This error is named very poorly. A better name would be\n `OnlyNamedAccountCreationAllowed`.')).or(zod.object({
  "DeleteAccountWithLargeState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Delete account whose state is large is temporarily banned.')).or(zod.enum(['DelegateActionInvalidSignature']).describe('Signature does not match the provided actions and given signer public key.')).or(zod.object({
  "DelegateActionSenderDoesNotMatchTxReceiver": zod.object({
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Receiver of the transaction doesn\'t match Sender of the delegate action')).or(zod.enum(['DelegateActionExpired']).describe('Delegate action has expired. `max_block_height` is less than actual block height.')).or(zod.object({
  "DelegateActionAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('The given public key doesn\'t exist for Sender account')).or(zod.object({
  "DelegateActionInvalidNonce": zod.object({
  "ak_nonce": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMin),
  "delegate_nonce": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMin)
})
}).describe('DelegateAction nonce must be greater sender[public_key].nonce')).or(zod.object({
  "DelegateActionNonceTooLarge": zod.object({
  "delegate_nonce": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMin),
  "upper_bound": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMin)
})
}).describe('DelegateAction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "GlobalContractDoesNotExist": zod.object({
  "identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
})
})).describe('The kind of ActionError happened')
}).describe('An error happened during Action execution')
}).describe('An error happened during Action execution').or(zod.object({
  "InvalidTxError": zod.object({
  "InvalidAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('Happens if a wrong AccessKey used or AccessKey has not enough permissions').or(zod.object({
  "InvalidSignerId": zod.object({
  "signer_id": zod.string()
})
}).describe('TX signer_id is not a valid [`AccountId`]')).or(zod.object({
  "SignerDoesNotExist": zod.object({
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('TX signer_id is not found in a storage')).or(zod.object({
  "InvalidNonce": zod.object({
  "ak_nonce": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorInvalidNonceAkNonceMin),
  "tx_nonce": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorInvalidNonceTxNonceMin)
})
}).describe('Transaction nonce must be strictly greater than `account[access_key].nonce`.')).or(zod.object({
  "NonceTooLarge": zod.object({
  "tx_nonce": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorNonceTooLargeTxNonceMin),
  "upper_bound": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMin)
})
}).describe('Transaction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "InvalidReceiverId": zod.object({
  "receiver_id": zod.string()
})
}).describe('TX receiver_id is not a valid AccountId')).or(zod.enum(['InvalidSignature']).describe('TX signature is not valid')).or(zod.object({
  "NotEnoughBalance": zod.object({
  "balance": zod.string(),
  "cost": zod.string(),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account does not have enough balance to cover TX cost')).or(zod.object({
  "LackBalanceForState": zod.object({
  "amount": zod.string().describe('Required balance to cover the state.'),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which doesn\'t have enough balance to cover storage.')
})
}).describe('Signer account doesn\'t have enough balance after transaction.')).or(zod.enum(['CostOverflow']).describe('An integer overflow occurred during transaction cost estimation.')).or(zod.enum(['InvalidChain']).describe('Transaction parent block hash doesn\'t belong to the current chain')).or(zod.enum(['Expired']).describe('Transaction has expired')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMin),
  "total_prepaid_gas": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMin),
  "total_number_of_actions": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin),
  "total_number_of_bytes": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMin),
  "size": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMin)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin),
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMin)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of a Transaction.')).or(zod.object({
  "TransactionSizeExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorTransactionSizeExceededLimitMin),
  "size": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorTransactionSizeExceededSizeMin)
})
}).describe('The size of serialized transaction exceeded the limit.')).or(zod.enum(['InvalidTransactionVersion']).describe('Transaction version is invalid.')).or(zod.object({
  "StorageError": zod.enum(['StorageInternalError']).describe('Key-value db internal failure').or(zod.object({
  "MissingTrieValue": zod.object({
  "context": zod.enum(['TrieIterator']).describe('Missing trie value when reading from TrieIterator.').or(zod.enum(['TriePrefetchingStorage']).describe('Missing trie value when reading from TriePrefetchingStorage.')).or(zod.enum(['TrieMemoryPartialStorage']).describe('Missing trie value when reading from TrieMemoryPartialStorage.')).or(zod.enum(['TrieStorage']).describe('Missing trie value when reading from TrieStorage.')).describe('Contexts in which `StorageError::MissingTrieValue` error might occur.'),
  "hash": zod.string()
})
}).describe('Requested trie value by its hash which is missing in storage.')).or(zod.enum(['UnexpectedTrieValue']).describe('Found trie node which shouldn\'t be part of state. Raised during\n validation of state sync parts where incorrect node was passed.\n TODO (#8997): consider including hash of trie node.')).or(zod.object({
  "StorageInconsistentState": zod.string()
}).describe('Either invalid state or key-value db is corrupted.\n For PartialStorage it cannot be corrupted.\n Error message is unreliable and for debugging purposes only. It\'s also probably ok to\n panic in every place that produces this error.\n We can check if db is corrupted by verifying everything in the state trie.')).or(zod.object({
  "FlatStorageBlockNotSupported": zod.string()
}).describe('Flat storage error, meaning that it doesn\'t support some block anymore.\n We guarantee that such block cannot become final, thus block processing\n must resume normally.')).or(zod.object({
  "MemTrieLoadingError": zod.string()
}).describe('In-memory trie could not be loaded for some reason.')).describe('Errors which may occur during working with trie storages, storing\n trie values (trie nodes and state values) by their hashes.')
})).or(zod.object({
  "ShardCongested": zod.object({
  "congestion_level": zod.number().describe('A value between 0 (no congestion) and 1 (max congestion).'),
  "shard_id": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorShardCongestedShardIdMin).describe('The congested shard.')
})
}).describe('The receiver shard of the transaction is too congested to accept new\n transactions at the moment.')).or(zod.object({
  "ShardStuck": zod.object({
  "missed_chunks": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorShardStuckMissedChunksMin).describe('The number of blocks since the last included chunk of the shard.'),
  "shard_id": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorShardStuckShardIdMin).describe('The shard that fails making progress.')
})
}).describe('The receiver shard of the transaction missed several chunks and rejects\n new transaction until it can make progress again.')).describe('An error happened during TX execution')
}).describe('An error happened during Transaction execution')).describe('Error returned in the ExecutionOutcome in case of failure')
}).describe('The execution has failed with the given error.')).or(zod.object({
  "SuccessValue": zod.string()
}).describe('The execution has succeeded and returned some value or an empty vec encoded in base64.')).describe('Execution status defined by chain.rs:get_final_transaction_result\n FinalExecutionStatus::NotStarted - the tx is not converted to the receipt yet\n FinalExecutionStatus::Started - we have at least 1 receipt, but the first leaf receipt_id (using dfs) hasn\'t finished the execution\n FinalExecutionStatus::Failure - the result of the first leaf receipt_id\n FinalExecutionStatus::SuccessValue - the result of the first leaf receipt_id'),
  "transaction": zod.object({
  "actions": zod.array(zod.enum(['CreateAccount']).or(zod.object({
  "DeployContract": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "FunctionCall": zod.object({
  "args": zod.string(),
  "deposit": zod.string(),
  "gas": zod.number().min(broadcastTxCommitResponseResultTransactionActionsItemFunctionCallGasMin),
  "method_name": zod.string()
})
})).or(zod.object({
  "Transfer": zod.object({
  "deposit": zod.string()
})
})).or(zod.object({
  "Stake": zod.object({
  "public_key": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "AddKey": zod.object({
  "access_key": zod.object({
  "nonce": zod.number().min(broadcastTxCommitResponseResultTransactionActionsItemAddKeyAccessKeyNonceMin),
  "permission": zod.enum(['FullAccess']).or(zod.object({
  "FunctionCall": zod.object({
  "allowance": zod.string().nullish(),
  "method_names": zod.array(zod.string()),
  "receiver_id": zod.string()
})
}))
}),
  "public_key": zod.string()
})
})).or(zod.object({
  "DeleteKey": zod.object({
  "public_key": zod.string()
})
})).or(zod.object({
  "DeleteAccount": zod.object({
  "beneficiary_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
})).or(zod.object({
  "Delegate": zod.object({
  "delegate_action": zod.object({
  "actions": zod.array(zod.object({
  "CreateAccount": zod.object({

}).describe('Create account action')
}).describe('Create an (sub)account using a transaction `receiver_id` as an ID for\n a new account ID must pass validation rules described here\n <http://nomicon.io/Primitives/Account.html>.').or(zod.object({
  "DeployContract": zod.object({
  "code": zod.string().describe('WebAssembly binary')
}).describe('Deploy contract action')
}).describe('Sets a Wasm code to a receiver_id')).or(zod.object({
  "FunctionCall": zod.object({
  "args": zod.string(),
  "deposit": zod.string(),
  "gas": zod.number().min(broadcastTxCommitResponseResultTransactionActionsItemDelegateDelegateActionActionsItemFunctionCallGasMin),
  "method_name": zod.string()
})
})).or(zod.object({
  "Transfer": zod.object({
  "deposit": zod.string()
})
})).or(zod.object({
  "Stake": zod.object({
  "public_key": zod.string().describe('Validator key which will be used to sign transactions on behalf of signer_id'),
  "stake": zod.string().describe('Amount of tokens to stake.')
}).describe('An action which stakes signer_id tokens and setup\'s validator public key')
})).or(zod.object({
  "AddKey": zod.object({
  "access_key": zod.object({
  "nonce": zod.number().min(broadcastTxCommitResponseResultTransactionActionsItemDelegateDelegateActionActionsItemAddKeyAccessKeyNonceMin).describe('Nonce for this access key, used for tx nonce generation. When access key is created, nonce\n is set to `(block_height - 1) * 1e6` to avoid tx hash collision on access key re-creation.\n See <https://github.com/near/nearcore/issues/3779> for more details.'),
  "permission": zod.object({
  "FunctionCall": zod.object({
  "allowance": zod.string().nullish().describe('Allowance is a balance limit to use by this access key to pay for function call gas and\n transaction fees. When this access key is used, both account balance and the allowance is\n decreased by the same value.\n `None` means unlimited allowance.\n NOTE: To change or increase the allowance, the old access key needs to be deleted and a new\n access key should be created.'),
  "method_names": zod.array(zod.string()).describe('A list of method names that can be used. The access key only allows transactions with the\n function call of one of the given method names.\n Empty list means any method name can be used.'),
  "receiver_id": zod.string().describe('The access key only allows transactions with the given receiver\'s account id.')
}).describe('Grants limited permission to make transactions with FunctionCallActions\n The permission can limit the allowed balance to be spent on the prepaid gas.\n It also restrict the account ID of the receiver for this function call.\n It also can restrict the method name for the allowed function calls.')
}).or(zod.enum(['FullAccess']).describe('Grants full access to the account.\n NOTE: It\'s used to replace account-level public keys.')).describe('Defines permissions for AccessKey').describe('Defines permissions for this access key.')
}).describe('Access key provides limited access to an account. Each access key belongs to some account and\n is identified by a unique (within the account) public key. One account may have large number of\n access keys. Access keys allow to act on behalf of the account by restricting transactions\n that can be issued.\n `account_id,public_key` is a key in the state').describe('An access key with the permission'),
  "public_key": zod.string().describe('A public key which will be associated with an access_key')
})
})).or(zod.object({
  "DeleteKey": zod.object({
  "public_key": zod.string().describe('A public key associated with the access_key to be deleted.')
})
})).or(zod.object({
  "DeleteAccount": zod.object({
  "beneficiary_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
})).or(zod.object({
  "Delegate": zod.object({
  "delegate_action": zod.any(),
  "signature": zod.string()
})
})).or(zod.object({
  "DeployGlobalContract": zod.object({
  "code": zod.string().describe('WebAssembly binary'),
  "deploy_mode": zod.enum(['CodeHash']).describe('Contract is deployed under its code hash.\n Users will be able reference it by that hash.\n This effectively makes the contract immutable.').or(zod.enum(['AccountId']).describe('Contract is deployed under the owner account id.\n Users will be able reference it by that account id.\n This allows the owner to update the contract for all its users.'))
}).describe('Deploy global contract action')
})).or(zod.object({
  "UseGlobalContract": zod.object({
  "contract_identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
}).describe('Use global contract action')
})).describe('This is Action which mustn\'t contain DelegateAction.\n\n This struct is needed to avoid the recursion when Action/DelegateAction is deserialized.\n\n Important: Don\'t make the inner Action public, this must only be constructed\n through the correct interface that ensures the inner Action is actually not\n a delegate action. That would break an assumption of this type, which we use\n in several places. For example, borsh de-/serialization relies on it. If the\n invariant is broken, we may end up with a `Transaction` or `Receipt` that we\n can serialize but deserializing it back causes a parsing error.')).describe('List of actions to be executed.\n\n With the meta transactions MVP defined in NEP-366, nested\n DelegateActions are not allowed. A separate type is used to enforce it.'),
  "max_block_height": zod.number().min(broadcastTxCommitResponseResultTransactionActionsItemDelegateDelegateActionMaxBlockHeightMin).describe('The maximal height of the block in the blockchain below which the given DelegateAction is valid.'),
  "nonce": zod.number().min(broadcastTxCommitResponseResultTransactionActionsItemDelegateDelegateActionNonceMin).describe('Nonce to ensure that the same delegate action is not sent twice by a\n relayer and should match for given account\'s `public_key`.\n After this action is processed it will increment.'),
  "public_key": zod.string().describe('Public key used to sign this delegated action.'),
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('Receiver of the delegated actions.'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('Signer of the delegated actions')
}).describe('This action allows to execute the inner actions behalf of the defined sender.'),
  "signature": zod.string()
})
})).or(zod.object({
  "DeployGlobalContract": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "DeployGlobalContractByAccountId": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "UseGlobalContract": zod.object({
  "code_hash": zod.string()
})
})).or(zod.object({
  "UseGlobalContractByAccountId": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}))),
  "hash": zod.string(),
  "nonce": zod.number().min(broadcastTxCommitResponseResultTransactionNonceMin),
  "priority_fee": zod.number().min(broadcastTxCommitResponseResultTransactionPriorityFeeMin).optional(),
  "public_key": zod.string(),
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "signature": zod.string(),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}).describe('Signed Transaction'),
  "transaction_outcome": zod.object({
  "block_hash": zod.string(),
  "id": zod.string(),
  "outcome": zod.object({
  "executor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('The id of the account on which the execution happens. For transaction this is signer_id,\n for receipt this is receiver_id.'),
  "gas_burnt": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeGasBurntMin).describe('The amount of the gas burnt by the given transaction or receipt.'),
  "logs": zod.array(zod.string()).describe('Logs from this transaction or receipt.'),
  "metadata": zod.object({
  "gas_profile": zod.array(zod.object({
  "cost": zod.string(),
  "cost_category": zod.string(),
  "gas_used": zod.string()
})).nullish(),
  "version": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeMetadataVersionMin)
}).default(broadcastTxCommitResponseResultTransactionOutcomeOutcomeMetadataDefault).describe('Execution metadata, versioned'),
  "receipt_ids": zod.array(zod.string()).describe('Receipt IDs generated by this transaction or receipt.'),
  "status": zod.enum(['Unknown']).describe('The execution is pending or unknown.').or(zod.object({
  "Failure": zod.object({
  "ActionError": zod.object({
  "index": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorIndexMin).nullish().describe('Index of the failed action in the transaction.\n Action index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`'),
  "kind": zod.object({
  "AccountAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage').or(zod.object({
  "AccountDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when TX receiver_id doesn\'t exist (but action is not Action::CreateAccount)')).or(zod.object({
  "CreateAccountOnlyByRegistrar": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "registrar_account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A top-level account ID can only be created by registrar.')).or(zod.object({
  "CreateAccountNotAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A newly created account must be under a namespace of the creator account')).or(zod.object({
  "ActorNoPermission": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "actor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\n or the first TX action is a `CreateAccount` action')).or(zod.object({
  "DeleteKeyDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('Account tries to remove an access key that doesn\'t exist')).or(zod.object({
  "AddKeyAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The public key is already used for an existing access key')).or(zod.object({
  "DeleteAccountStaking": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is staking and can not be deleted')).or(zod.object({
  "LackBalanceForState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which needs balance'),
  "amount": zod.string().describe('Balance required to complete an action.')
})
}).describe('ActionReceipt can\'t be completed, because the remaining balance will not be enough to cover storage.')).or(zod.object({
  "TriesToUnstake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is not yet staked, but tries to unstake')).or(zod.object({
  "TriesToStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "balance": zod.string(),
  "locked": zod.string(),
  "stake": zod.string()
})
}).describe('The account doesn\'t have enough balance to increase the stake.')).or(zod.object({
  "InsufficientStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "minimum_stake": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "FunctionCallError": zod.enum(['WasmUnknownError', '_EVMError']).or(zod.object({
  "CompilationError": zod.object({
  "CodeDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).or(zod.object({
  "PrepareError": zod.enum(['Serialization']).describe('Error happened while serializing the module.').or(zod.enum(['Deserialization']).describe('Error happened while deserializing the module.')).or(zod.enum(['InternalMemoryDeclared']).describe('Internal memory declaration has been found in the module.')).or(zod.enum(['GasInstrumentation']).describe('Gas instrumentation failed.\n\n This most likely indicates the module isn\'t valid.')).or(zod.enum(['StackHeightInstrumentation']).describe('Stack instrumentation failed.\n\n This  most likely indicates the module isn\'t valid.')).or(zod.enum(['Instantiate']).describe('Error happened during instantiation.\n\n This might indicate that `start` function trapped, or module isn\'t\n instantiable and/or un-linkable.')).or(zod.enum(['Memory']).describe('Error creating memory.')).or(zod.enum(['TooManyFunctions']).describe('Contract contains too many functions.')).or(zod.enum(['TooManyLocals']).describe('Contract contains too many locals.')).describe('Error that can occur while preparing or executing Wasm smart-contract.')
})).or(zod.object({
  "WasmerCompileError": zod.object({
  "msg": zod.string()
})
}).describe('This is for defense in depth.\n We expect our runtime-independent preparation code to fully catch all invalid wasms,\n but, if it ever misses something we‚Äôll emit this error'))
}).describe('Wasm compilation error')).or(zod.object({
  "LinkError": zod.object({
  "msg": zod.string()
})
}).describe('Wasm binary env link error\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "MethodResolveError": zod.enum(['MethodEmptyName', 'MethodNotFound', 'MethodInvalidSignature'])
}).describe('Import/export resolve error')).or(zod.object({
  "WasmTrap": zod.enum(['Unreachable']).describe('An `unreachable` opcode was executed.').or(zod.enum(['IncorrectCallIndirectSignature']).describe('Call indirect incorrect signature trap.')).or(zod.enum(['MemoryOutOfBounds']).describe('Memory out of bounds trap.')).or(zod.enum(['CallIndirectOOB']).describe('Call indirect out of bounds trap.')).or(zod.enum(['IllegalArithmetic']).describe('An arithmetic exception, e.g. divided by zero.')).or(zod.enum(['MisalignedAtomicAccess']).describe('Misaligned atomic access trap.')).or(zod.enum(['IndirectCallToNull']).describe('Indirect call to null.')).or(zod.enum(['StackOverflow']).describe('Stack overflow.')).or(zod.enum(['GenericTrap']).describe('Generic trap.')).describe('A kind of a trap happened during execution of a binary')
}).describe('A trap happened during execution of a binary\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "HostError": zod.enum(['BadUTF16']).describe('String encoding is bad UTF-16 sequence').or(zod.enum(['BadUTF8']).describe('String encoding is bad UTF-8 sequence')).or(zod.enum(['GasExceeded']).describe('Exceeded the prepaid gas')).or(zod.enum(['GasLimitExceeded']).describe('Exceeded the maximum amount of gas allowed to burn per contract')).or(zod.enum(['BalanceExceeded']).describe('Exceeded the account balance')).or(zod.enum(['EmptyMethodName']).describe('Tried to call an empty method name')).or(zod.object({
  "GuestPanic": zod.object({
  "panic_msg": zod.string()
})
}).describe('Smart contract panicked')).or(zod.enum(['IntegerOverflow']).describe('IntegerOverflow happened during a contract execution')).or(zod.object({
  "InvalidPromiseIndex": zod.object({
  "promise_idx": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMin)
})
}).describe('`promise_idx` does not correspond to existing promises')).or(zod.enum(['CannotAppendActionToJointPromise']).describe('Actions can only be appended to non-joint promise.')).or(zod.enum(['CannotReturnJointPromise']).describe('Returning joint promise is currently prohibited')).or(zod.object({
  "InvalidPromiseResultIndex": zod.object({
  "result_idx": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMin)
})
}).describe('Accessed invalid promise result index')).or(zod.object({
  "InvalidRegisterId": zod.object({
  "register_id": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMin)
})
}).describe('Accessed invalid register id')).or(zod.object({
  "IteratorWasInvalidated": zod.object({
  "iterator_index": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMin)
})
}).describe('Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie')).or(zod.enum(['MemoryAccessViolation']).describe('Accessed memory outside the bounds')).or(zod.object({
  "InvalidReceiptIndex": zod.object({
  "receipt_index": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMin)
})
}).describe('VM Logic returned an invalid receipt index')).or(zod.object({
  "InvalidIteratorIndex": zod.object({
  "iterator_index": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMin)
})
}).describe('Iterator index `iterator_index` does not exist')).or(zod.enum(['InvalidAccountId']).describe('VM Logic returned an invalid account id')).or(zod.enum(['InvalidMethodName']).describe('VM Logic returned an invalid method name')).or(zod.enum(['InvalidPublicKey']).describe('VM Logic provided an invalid public key')).or(zod.object({
  "ProhibitedInView": zod.object({
  "method_name": zod.string()
})
}).describe('`method_name` is not allowed in view calls')).or(zod.object({
  "NumberOfLogsExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMin)
})
}).describe('The total number of logs will exceed the limit.')).or(zod.object({
  "KeyLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMin),
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMin)
})
}).describe('The storage key length exceeded the limit.')).or(zod.object({
  "ValueLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMin),
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMin)
})
}).describe('The storage value length exceeded the limit.')).or(zod.object({
  "TotalLogLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMin),
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMin)
})
}).describe('The total log length exceeded the limit.')).or(zod.object({
  "NumberPromisesExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMin),
  "number_of_promises": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMin)
})
}).describe('The maximum number of promises within a FunctionCall exceeded the limit.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMin),
  "number_of_input_data_dependencies": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin)
})
}).describe('The maximum number of input data dependencies exceeded the limit.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMin),
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMin)
})
}).describe('The returned value length exceeded the limit.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMin),
  "size": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMin)
})
}).describe('The contract size for DeployContract action exceeded the limit.')).or(zod.object({
  "Deprecated": zod.object({
  "method_name": zod.string()
})
}).describe('The host function was deprecated.')).or(zod.object({
  "ECRecoverError": zod.object({
  "msg": zod.string()
})
}).describe('General errors for ECDSA recover.')).or(zod.object({
  "AltBn128InvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to alt_bn128 family of functions (e.g., point which isn\'t\n on the curve).')).or(zod.object({
  "Ed25519VerifyInvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to ed25519 signature verification function (e.g. signature cannot be\n derived from bytes).'))
}).describe('Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "ExecutionError": zod.string()
})).describe('Serializable version of `near-vm-runner::FunctionCallError`.\n\n Must never reorder/remove elements, can only add new variants at the end (but do that very\n carefully). It describes stable serialization format, and only used by serialization logic.')
}).describe('An error occurred during a `FunctionCall` Action, parameter is debug message.')).or(zod.object({
  "NewReceiptValidationError": zod.object({
  "InvalidPredecessorId": zod.object({
  "account_id": zod.string()
})
}).describe('The `predecessor_id` of a Receipt is not valid.').or(zod.object({
  "InvalidReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a Receipt is not valid.')).or(zod.object({
  "InvalidSignerId": zod.object({
  "account_id": zod.string()
})
}).describe('The `signer_id` of an ActionReceipt is not valid.')).or(zod.object({
  "InvalidDataReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a DataReceiver within an ActionReceipt is not valid.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMin),
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMin)
})
}).describe('The length of the returned data exceeded the limit in a DataReceipt.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMin),
  "number_of_input_data_dependencies": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin)
})
}).describe('The number of input data dependencies exceeds the limit in an ActionReceipt.')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMin),
  "total_prepaid_gas": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMin),
  "total_number_of_actions": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin),
  "total_number_of_bytes": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMin),
  "size": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMin)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin),
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMin)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of an ActionReceipt.')).or(zod.object({
  "ReceiptSizeExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMin),
  "size": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMin)
})
}).describe('Receipt is bigger than the limit.')).describe('Describes the error for validating a receipt.')
}).describe('Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\n receipt validation.')).or(zod.object({
  "OnlyImplicitAccountCreationAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\n See NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\n Also, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\n TODO(#8598): This error is named very poorly. A better name would be\n `OnlyNamedAccountCreationAllowed`.')).or(zod.object({
  "DeleteAccountWithLargeState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Delete account whose state is large is temporarily banned.')).or(zod.enum(['DelegateActionInvalidSignature']).describe('Signature does not match the provided actions and given signer public key.')).or(zod.object({
  "DelegateActionSenderDoesNotMatchTxReceiver": zod.object({
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Receiver of the transaction doesn\'t match Sender of the delegate action')).or(zod.enum(['DelegateActionExpired']).describe('Delegate action has expired. `max_block_height` is less than actual block height.')).or(zod.object({
  "DelegateActionAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('The given public key doesn\'t exist for Sender account')).or(zod.object({
  "DelegateActionInvalidNonce": zod.object({
  "ak_nonce": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMin),
  "delegate_nonce": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMin)
})
}).describe('DelegateAction nonce must be greater sender[public_key].nonce')).or(zod.object({
  "DelegateActionNonceTooLarge": zod.object({
  "delegate_nonce": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMin),
  "upper_bound": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMin)
})
}).describe('DelegateAction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "GlobalContractDoesNotExist": zod.object({
  "identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
})
})).describe('The kind of ActionError happened')
}).describe('An error happened during Action execution')
}).describe('An error happened during Action execution').or(zod.object({
  "InvalidTxError": zod.object({
  "InvalidAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('Happens if a wrong AccessKey used or AccessKey has not enough permissions').or(zod.object({
  "InvalidSignerId": zod.object({
  "signer_id": zod.string()
})
}).describe('TX signer_id is not a valid [`AccountId`]')).or(zod.object({
  "SignerDoesNotExist": zod.object({
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('TX signer_id is not found in a storage')).or(zod.object({
  "InvalidNonce": zod.object({
  "ak_nonce": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorInvalidNonceAkNonceMin),
  "tx_nonce": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorInvalidNonceTxNonceMin)
})
}).describe('Transaction nonce must be strictly greater than `account[access_key].nonce`.')).or(zod.object({
  "NonceTooLarge": zod.object({
  "tx_nonce": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorNonceTooLargeTxNonceMin),
  "upper_bound": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMin)
})
}).describe('Transaction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "InvalidReceiverId": zod.object({
  "receiver_id": zod.string()
})
}).describe('TX receiver_id is not a valid AccountId')).or(zod.enum(['InvalidSignature']).describe('TX signature is not valid')).or(zod.object({
  "NotEnoughBalance": zod.object({
  "balance": zod.string(),
  "cost": zod.string(),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account does not have enough balance to cover TX cost')).or(zod.object({
  "LackBalanceForState": zod.object({
  "amount": zod.string().describe('Required balance to cover the state.'),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which doesn\'t have enough balance to cover storage.')
})
}).describe('Signer account doesn\'t have enough balance after transaction.')).or(zod.enum(['CostOverflow']).describe('An integer overflow occurred during transaction cost estimation.')).or(zod.enum(['InvalidChain']).describe('Transaction parent block hash doesn\'t belong to the current chain')).or(zod.enum(['Expired']).describe('Transaction has expired')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMin),
  "total_prepaid_gas": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMin),
  "total_number_of_actions": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin),
  "total_number_of_bytes": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMin),
  "size": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMin)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin),
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMin)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of a Transaction.')).or(zod.object({
  "TransactionSizeExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededLimitMin),
  "size": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededSizeMin)
})
}).describe('The size of serialized transaction exceeded the limit.')).or(zod.enum(['InvalidTransactionVersion']).describe('Transaction version is invalid.')).or(zod.object({
  "StorageError": zod.enum(['StorageInternalError']).describe('Key-value db internal failure').or(zod.object({
  "MissingTrieValue": zod.object({
  "context": zod.enum(['TrieIterator']).describe('Missing trie value when reading from TrieIterator.').or(zod.enum(['TriePrefetchingStorage']).describe('Missing trie value when reading from TriePrefetchingStorage.')).or(zod.enum(['TrieMemoryPartialStorage']).describe('Missing trie value when reading from TrieMemoryPartialStorage.')).or(zod.enum(['TrieStorage']).describe('Missing trie value when reading from TrieStorage.')).describe('Contexts in which `StorageError::MissingTrieValue` error might occur.'),
  "hash": zod.string()
})
}).describe('Requested trie value by its hash which is missing in storage.')).or(zod.enum(['UnexpectedTrieValue']).describe('Found trie node which shouldn\'t be part of state. Raised during\n validation of state sync parts where incorrect node was passed.\n TODO (#8997): consider including hash of trie node.')).or(zod.object({
  "StorageInconsistentState": zod.string()
}).describe('Either invalid state or key-value db is corrupted.\n For PartialStorage it cannot be corrupted.\n Error message is unreliable and for debugging purposes only. It\'s also probably ok to\n panic in every place that produces this error.\n We can check if db is corrupted by verifying everything in the state trie.')).or(zod.object({
  "FlatStorageBlockNotSupported": zod.string()
}).describe('Flat storage error, meaning that it doesn\'t support some block anymore.\n We guarantee that such block cannot become final, thus block processing\n must resume normally.')).or(zod.object({
  "MemTrieLoadingError": zod.string()
}).describe('In-memory trie could not be loaded for some reason.')).describe('Errors which may occur during working with trie storages, storing\n trie values (trie nodes and state values) by their hashes.')
})).or(zod.object({
  "ShardCongested": zod.object({
  "congestion_level": zod.number().describe('A value between 0 (no congestion) and 1 (max congestion).'),
  "shard_id": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardCongestedShardIdMin).describe('The congested shard.')
})
}).describe('The receiver shard of the transaction is too congested to accept new\n transactions at the moment.')).or(zod.object({
  "ShardStuck": zod.object({
  "missed_chunks": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardStuckMissedChunksMin).describe('The number of blocks since the last included chunk of the shard.'),
  "shard_id": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardStuckShardIdMin).describe('The shard that fails making progress.')
})
}).describe('The receiver shard of the transaction missed several chunks and rejects\n new transaction until it can make progress again.')).describe('An error happened during TX execution')
}).describe('An error happened during Transaction execution')).describe('Error returned in the ExecutionOutcome in case of failure')
}).describe('The execution has failed.')).or(zod.object({
  "SuccessValue": zod.string()
}).describe('The final action succeeded and returned some value or an empty vec encoded in base64.')).or(zod.object({
  "SuccessReceiptId": zod.string()
}).describe('The final action of the receipt returned a promise or the signed transaction was converted\n to a receipt. Contains the receipt_id of the generated receipt.')).describe('Execution status. Contains the result in case of successful execution.'),
  "tokens_burnt": zod.string().describe('The amount of tokens burnt corresponding to the burnt gas amount.\n This value doesn\'t always equal to the `gas_burnt` multiplied by the gas price, because\n the prepaid gas price might be lower than the actual gas price and it creates a deficit.\n `tokens_burnt` also contains the penalty subtracted from refunds, while\n `gas_burnt` only contains the gas that we actually burn for the execution.')
}),
  "proof": zod.array(zod.object({
  "direction": zod.enum(['Left', 'Right']),
  "hash": zod.string()
}))
}).describe('The execution outcome of the signed transaction.')
}).describe('Final execution outcome of the transaction and all of subsequent the receipts. Also includes\n the generated receipt.').or(zod.object({
  "receipts_outcome": zod.array(zod.object({
  "block_hash": zod.string(),
  "id": zod.string(),
  "outcome": zod.object({
  "executor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('The id of the account on which the execution happens. For transaction this is signer_id,\n for receipt this is receiver_id.'),
  "gas_burnt": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeGasBurntMinOne).describe('The amount of the gas burnt by the given transaction or receipt.'),
  "logs": zod.array(zod.string()).describe('Logs from this transaction or receipt.'),
  "metadata": zod.object({
  "gas_profile": zod.array(zod.object({
  "cost": zod.string(),
  "cost_category": zod.string(),
  "gas_used": zod.string()
})).nullish(),
  "version": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeMetadataVersionMinOne)
}).default(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeMetadataDefaultTwo).describe('Execution metadata, versioned'),
  "receipt_ids": zod.array(zod.string()).describe('Receipt IDs generated by this transaction or receipt.'),
  "status": zod.enum(['Unknown']).describe('The execution is pending or unknown.').or(zod.object({
  "Failure": zod.object({
  "ActionError": zod.object({
  "index": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorIndexMinOne).nullish().describe('Index of the failed action in the transaction.\n Action index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`'),
  "kind": zod.object({
  "AccountAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage').or(zod.object({
  "AccountDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when TX receiver_id doesn\'t exist (but action is not Action::CreateAccount)')).or(zod.object({
  "CreateAccountOnlyByRegistrar": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "registrar_account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A top-level account ID can only be created by registrar.')).or(zod.object({
  "CreateAccountNotAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A newly created account must be under a namespace of the creator account')).or(zod.object({
  "ActorNoPermission": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "actor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\n or the first TX action is a `CreateAccount` action')).or(zod.object({
  "DeleteKeyDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('Account tries to remove an access key that doesn\'t exist')).or(zod.object({
  "AddKeyAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The public key is already used for an existing access key')).or(zod.object({
  "DeleteAccountStaking": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is staking and can not be deleted')).or(zod.object({
  "LackBalanceForState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which needs balance'),
  "amount": zod.string().describe('Balance required to complete an action.')
})
}).describe('ActionReceipt can\'t be completed, because the remaining balance will not be enough to cover storage.')).or(zod.object({
  "TriesToUnstake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is not yet staked, but tries to unstake')).or(zod.object({
  "TriesToStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "balance": zod.string(),
  "locked": zod.string(),
  "stake": zod.string()
})
}).describe('The account doesn\'t have enough balance to increase the stake.')).or(zod.object({
  "InsufficientStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "minimum_stake": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "FunctionCallError": zod.enum(['WasmUnknownError', '_EVMError']).or(zod.object({
  "CompilationError": zod.object({
  "CodeDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).or(zod.object({
  "PrepareError": zod.enum(['Serialization']).describe('Error happened while serializing the module.').or(zod.enum(['Deserialization']).describe('Error happened while deserializing the module.')).or(zod.enum(['InternalMemoryDeclared']).describe('Internal memory declaration has been found in the module.')).or(zod.enum(['GasInstrumentation']).describe('Gas instrumentation failed.\n\n This most likely indicates the module isn\'t valid.')).or(zod.enum(['StackHeightInstrumentation']).describe('Stack instrumentation failed.\n\n This  most likely indicates the module isn\'t valid.')).or(zod.enum(['Instantiate']).describe('Error happened during instantiation.\n\n This might indicate that `start` function trapped, or module isn\'t\n instantiable and/or un-linkable.')).or(zod.enum(['Memory']).describe('Error creating memory.')).or(zod.enum(['TooManyFunctions']).describe('Contract contains too many functions.')).or(zod.enum(['TooManyLocals']).describe('Contract contains too many locals.')).describe('Error that can occur while preparing or executing Wasm smart-contract.')
})).or(zod.object({
  "WasmerCompileError": zod.object({
  "msg": zod.string()
})
}).describe('This is for defense in depth.\n We expect our runtime-independent preparation code to fully catch all invalid wasms,\n but, if it ever misses something we‚Äôll emit this error'))
}).describe('Wasm compilation error')).or(zod.object({
  "LinkError": zod.object({
  "msg": zod.string()
})
}).describe('Wasm binary env link error\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "MethodResolveError": zod.enum(['MethodEmptyName', 'MethodNotFound', 'MethodInvalidSignature'])
}).describe('Import/export resolve error')).or(zod.object({
  "WasmTrap": zod.enum(['Unreachable']).describe('An `unreachable` opcode was executed.').or(zod.enum(['IncorrectCallIndirectSignature']).describe('Call indirect incorrect signature trap.')).or(zod.enum(['MemoryOutOfBounds']).describe('Memory out of bounds trap.')).or(zod.enum(['CallIndirectOOB']).describe('Call indirect out of bounds trap.')).or(zod.enum(['IllegalArithmetic']).describe('An arithmetic exception, e.g. divided by zero.')).or(zod.enum(['MisalignedAtomicAccess']).describe('Misaligned atomic access trap.')).or(zod.enum(['IndirectCallToNull']).describe('Indirect call to null.')).or(zod.enum(['StackOverflow']).describe('Stack overflow.')).or(zod.enum(['GenericTrap']).describe('Generic trap.')).describe('A kind of a trap happened during execution of a binary')
}).describe('A trap happened during execution of a binary\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "HostError": zod.enum(['BadUTF16']).describe('String encoding is bad UTF-16 sequence').or(zod.enum(['BadUTF8']).describe('String encoding is bad UTF-8 sequence')).or(zod.enum(['GasExceeded']).describe('Exceeded the prepaid gas')).or(zod.enum(['GasLimitExceeded']).describe('Exceeded the maximum amount of gas allowed to burn per contract')).or(zod.enum(['BalanceExceeded']).describe('Exceeded the account balance')).or(zod.enum(['EmptyMethodName']).describe('Tried to call an empty method name')).or(zod.object({
  "GuestPanic": zod.object({
  "panic_msg": zod.string()
})
}).describe('Smart contract panicked')).or(zod.enum(['IntegerOverflow']).describe('IntegerOverflow happened during a contract execution')).or(zod.object({
  "InvalidPromiseIndex": zod.object({
  "promise_idx": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMinOne)
})
}).describe('`promise_idx` does not correspond to existing promises')).or(zod.enum(['CannotAppendActionToJointPromise']).describe('Actions can only be appended to non-joint promise.')).or(zod.enum(['CannotReturnJointPromise']).describe('Returning joint promise is currently prohibited')).or(zod.object({
  "InvalidPromiseResultIndex": zod.object({
  "result_idx": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMinOne)
})
}).describe('Accessed invalid promise result index')).or(zod.object({
  "InvalidRegisterId": zod.object({
  "register_id": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMinOne)
})
}).describe('Accessed invalid register id')).or(zod.object({
  "IteratorWasInvalidated": zod.object({
  "iterator_index": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMinOne)
})
}).describe('Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie')).or(zod.enum(['MemoryAccessViolation']).describe('Accessed memory outside the bounds')).or(zod.object({
  "InvalidReceiptIndex": zod.object({
  "receipt_index": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMinOne)
})
}).describe('VM Logic returned an invalid receipt index')).or(zod.object({
  "InvalidIteratorIndex": zod.object({
  "iterator_index": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMinOne)
})
}).describe('Iterator index `iterator_index` does not exist')).or(zod.enum(['InvalidAccountId']).describe('VM Logic returned an invalid account id')).or(zod.enum(['InvalidMethodName']).describe('VM Logic returned an invalid method name')).or(zod.enum(['InvalidPublicKey']).describe('VM Logic provided an invalid public key')).or(zod.object({
  "ProhibitedInView": zod.object({
  "method_name": zod.string()
})
}).describe('`method_name` is not allowed in view calls')).or(zod.object({
  "NumberOfLogsExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMinOne)
})
}).describe('The total number of logs will exceed the limit.')).or(zod.object({
  "KeyLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMinOne),
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMinOne)
})
}).describe('The storage key length exceeded the limit.')).or(zod.object({
  "ValueLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMinOne),
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMinOne)
})
}).describe('The storage value length exceeded the limit.')).or(zod.object({
  "TotalLogLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMinOne),
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMinOne)
})
}).describe('The total log length exceeded the limit.')).or(zod.object({
  "NumberPromisesExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMinOne),
  "number_of_promises": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMinOne)
})
}).describe('The maximum number of promises within a FunctionCall exceeded the limit.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMinOne),
  "number_of_input_data_dependencies": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne)
})
}).describe('The maximum number of input data dependencies exceeded the limit.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMinOne),
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMinOne)
})
}).describe('The returned value length exceeded the limit.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMinOne),
  "size": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMinOne)
})
}).describe('The contract size for DeployContract action exceeded the limit.')).or(zod.object({
  "Deprecated": zod.object({
  "method_name": zod.string()
})
}).describe('The host function was deprecated.')).or(zod.object({
  "ECRecoverError": zod.object({
  "msg": zod.string()
})
}).describe('General errors for ECDSA recover.')).or(zod.object({
  "AltBn128InvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to alt_bn128 family of functions (e.g., point which isn\'t\n on the curve).')).or(zod.object({
  "Ed25519VerifyInvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to ed25519 signature verification function (e.g. signature cannot be\n derived from bytes).'))
}).describe('Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "ExecutionError": zod.string()
})).describe('Serializable version of `near-vm-runner::FunctionCallError`.\n\n Must never reorder/remove elements, can only add new variants at the end (but do that very\n carefully). It describes stable serialization format, and only used by serialization logic.')
}).describe('An error occurred during a `FunctionCall` Action, parameter is debug message.')).or(zod.object({
  "NewReceiptValidationError": zod.object({
  "InvalidPredecessorId": zod.object({
  "account_id": zod.string()
})
}).describe('The `predecessor_id` of a Receipt is not valid.').or(zod.object({
  "InvalidReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a Receipt is not valid.')).or(zod.object({
  "InvalidSignerId": zod.object({
  "account_id": zod.string()
})
}).describe('The `signer_id` of an ActionReceipt is not valid.')).or(zod.object({
  "InvalidDataReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a DataReceiver within an ActionReceipt is not valid.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMinOne),
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMinOne)
})
}).describe('The length of the returned data exceeded the limit in a DataReceipt.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMinOne),
  "number_of_input_data_dependencies": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne)
})
}).describe('The number of input data dependencies exceeds the limit in an ActionReceipt.')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMinOne),
  "total_prepaid_gas": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne),
  "total_number_of_actions": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne),
  "total_number_of_bytes": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMinOne),
  "size": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMinOne)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne),
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of an ActionReceipt.')).or(zod.object({
  "ReceiptSizeExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMinOne),
  "size": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMinOne)
})
}).describe('Receipt is bigger than the limit.')).describe('Describes the error for validating a receipt.')
}).describe('Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\n receipt validation.')).or(zod.object({
  "OnlyImplicitAccountCreationAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\n See NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\n Also, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\n TODO(#8598): This error is named very poorly. A better name would be\n `OnlyNamedAccountCreationAllowed`.')).or(zod.object({
  "DeleteAccountWithLargeState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Delete account whose state is large is temporarily banned.')).or(zod.enum(['DelegateActionInvalidSignature']).describe('Signature does not match the provided actions and given signer public key.')).or(zod.object({
  "DelegateActionSenderDoesNotMatchTxReceiver": zod.object({
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Receiver of the transaction doesn\'t match Sender of the delegate action')).or(zod.enum(['DelegateActionExpired']).describe('Delegate action has expired. `max_block_height` is less than actual block height.')).or(zod.object({
  "DelegateActionAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('The given public key doesn\'t exist for Sender account')).or(zod.object({
  "DelegateActionInvalidNonce": zod.object({
  "ak_nonce": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMinOne),
  "delegate_nonce": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMinOne)
})
}).describe('DelegateAction nonce must be greater sender[public_key].nonce')).or(zod.object({
  "DelegateActionNonceTooLarge": zod.object({
  "delegate_nonce": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMinOne),
  "upper_bound": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMinOne)
})
}).describe('DelegateAction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "GlobalContractDoesNotExist": zod.object({
  "identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
})
})).describe('The kind of ActionError happened')
}).describe('An error happened during Action execution')
}).describe('An error happened during Action execution').or(zod.object({
  "InvalidTxError": zod.object({
  "InvalidAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('Happens if a wrong AccessKey used or AccessKey has not enough permissions').or(zod.object({
  "InvalidSignerId": zod.object({
  "signer_id": zod.string()
})
}).describe('TX signer_id is not a valid [`AccountId`]')).or(zod.object({
  "SignerDoesNotExist": zod.object({
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('TX signer_id is not found in a storage')).or(zod.object({
  "InvalidNonce": zod.object({
  "ak_nonce": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorInvalidNonceAkNonceMinOne),
  "tx_nonce": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorInvalidNonceTxNonceMinOne)
})
}).describe('Transaction nonce must be strictly greater than `account[access_key].nonce`.')).or(zod.object({
  "NonceTooLarge": zod.object({
  "tx_nonce": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorNonceTooLargeTxNonceMinOne),
  "upper_bound": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMinOne)
})
}).describe('Transaction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "InvalidReceiverId": zod.object({
  "receiver_id": zod.string()
})
}).describe('TX receiver_id is not a valid AccountId')).or(zod.enum(['InvalidSignature']).describe('TX signature is not valid')).or(zod.object({
  "NotEnoughBalance": zod.object({
  "balance": zod.string(),
  "cost": zod.string(),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account does not have enough balance to cover TX cost')).or(zod.object({
  "LackBalanceForState": zod.object({
  "amount": zod.string().describe('Required balance to cover the state.'),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which doesn\'t have enough balance to cover storage.')
})
}).describe('Signer account doesn\'t have enough balance after transaction.')).or(zod.enum(['CostOverflow']).describe('An integer overflow occurred during transaction cost estimation.')).or(zod.enum(['InvalidChain']).describe('Transaction parent block hash doesn\'t belong to the current chain')).or(zod.enum(['Expired']).describe('Transaction has expired')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMinOne),
  "total_prepaid_gas": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne),
  "total_number_of_actions": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne),
  "total_number_of_bytes": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMinOne),
  "size": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMinOne)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne),
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of a Transaction.')).or(zod.object({
  "TransactionSizeExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededLimitMinOne),
  "size": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededSizeMinOne)
})
}).describe('The size of serialized transaction exceeded the limit.')).or(zod.enum(['InvalidTransactionVersion']).describe('Transaction version is invalid.')).or(zod.object({
  "StorageError": zod.enum(['StorageInternalError']).describe('Key-value db internal failure').or(zod.object({
  "MissingTrieValue": zod.object({
  "context": zod.enum(['TrieIterator']).describe('Missing trie value when reading from TrieIterator.').or(zod.enum(['TriePrefetchingStorage']).describe('Missing trie value when reading from TriePrefetchingStorage.')).or(zod.enum(['TrieMemoryPartialStorage']).describe('Missing trie value when reading from TrieMemoryPartialStorage.')).or(zod.enum(['TrieStorage']).describe('Missing trie value when reading from TrieStorage.')).describe('Contexts in which `StorageError::MissingTrieValue` error might occur.'),
  "hash": zod.string()
})
}).describe('Requested trie value by its hash which is missing in storage.')).or(zod.enum(['UnexpectedTrieValue']).describe('Found trie node which shouldn\'t be part of state. Raised during\n validation of state sync parts where incorrect node was passed.\n TODO (#8997): consider including hash of trie node.')).or(zod.object({
  "StorageInconsistentState": zod.string()
}).describe('Either invalid state or key-value db is corrupted.\n For PartialStorage it cannot be corrupted.\n Error message is unreliable and for debugging purposes only. It\'s also probably ok to\n panic in every place that produces this error.\n We can check if db is corrupted by verifying everything in the state trie.')).or(zod.object({
  "FlatStorageBlockNotSupported": zod.string()
}).describe('Flat storage error, meaning that it doesn\'t support some block anymore.\n We guarantee that such block cannot become final, thus block processing\n must resume normally.')).or(zod.object({
  "MemTrieLoadingError": zod.string()
}).describe('In-memory trie could not be loaded for some reason.')).describe('Errors which may occur during working with trie storages, storing\n trie values (trie nodes and state values) by their hashes.')
})).or(zod.object({
  "ShardCongested": zod.object({
  "congestion_level": zod.number().describe('A value between 0 (no congestion) and 1 (max congestion).'),
  "shard_id": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardCongestedShardIdMinOne).describe('The congested shard.')
})
}).describe('The receiver shard of the transaction is too congested to accept new\n transactions at the moment.')).or(zod.object({
  "ShardStuck": zod.object({
  "missed_chunks": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardStuckMissedChunksMinOne).describe('The number of blocks since the last included chunk of the shard.'),
  "shard_id": zod.number().min(broadcastTxCommitResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardStuckShardIdMinOne).describe('The shard that fails making progress.')
})
}).describe('The receiver shard of the transaction missed several chunks and rejects\n new transaction until it can make progress again.')).describe('An error happened during TX execution')
}).describe('An error happened during Transaction execution')).describe('Error returned in the ExecutionOutcome in case of failure')
}).describe('The execution has failed.')).or(zod.object({
  "SuccessValue": zod.string()
}).describe('The final action succeeded and returned some value or an empty vec encoded in base64.')).or(zod.object({
  "SuccessReceiptId": zod.string()
}).describe('The final action of the receipt returned a promise or the signed transaction was converted\n to a receipt. Contains the receipt_id of the generated receipt.')).describe('Execution status. Contains the result in case of successful execution.'),
  "tokens_burnt": zod.string().describe('The amount of tokens burnt corresponding to the burnt gas amount.\n This value doesn\'t always equal to the `gas_burnt` multiplied by the gas price, because\n the prepaid gas price might be lower than the actual gas price and it creates a deficit.\n `tokens_burnt` also contains the penalty subtracted from refunds, while\n `gas_burnt` only contains the gas that we actually burn for the execution.')
}),
  "proof": zod.array(zod.object({
  "direction": zod.enum(['Left', 'Right']),
  "hash": zod.string()
}))
})).describe('The execution outcome of receipts.'),
  "status": zod.enum(['NotStarted']).describe('The execution has not yet started.').or(zod.enum(['Started']).describe('The execution has started and still going.')).or(zod.object({
  "Failure": zod.object({
  "ActionError": zod.object({
  "index": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorIndexMinOne).nullish().describe('Index of the failed action in the transaction.\n Action index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`'),
  "kind": zod.object({
  "AccountAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage').or(zod.object({
  "AccountDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when TX receiver_id doesn\'t exist (but action is not Action::CreateAccount)')).or(zod.object({
  "CreateAccountOnlyByRegistrar": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "registrar_account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A top-level account ID can only be created by registrar.')).or(zod.object({
  "CreateAccountNotAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A newly created account must be under a namespace of the creator account')).or(zod.object({
  "ActorNoPermission": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "actor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\n or the first TX action is a `CreateAccount` action')).or(zod.object({
  "DeleteKeyDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('Account tries to remove an access key that doesn\'t exist')).or(zod.object({
  "AddKeyAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The public key is already used for an existing access key')).or(zod.object({
  "DeleteAccountStaking": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is staking and can not be deleted')).or(zod.object({
  "LackBalanceForState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which needs balance'),
  "amount": zod.string().describe('Balance required to complete an action.')
})
}).describe('ActionReceipt can\'t be completed, because the remaining balance will not be enough to cover storage.')).or(zod.object({
  "TriesToUnstake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is not yet staked, but tries to unstake')).or(zod.object({
  "TriesToStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "balance": zod.string(),
  "locked": zod.string(),
  "stake": zod.string()
})
}).describe('The account doesn\'t have enough balance to increase the stake.')).or(zod.object({
  "InsufficientStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "minimum_stake": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "FunctionCallError": zod.enum(['WasmUnknownError', '_EVMError']).or(zod.object({
  "CompilationError": zod.object({
  "CodeDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).or(zod.object({
  "PrepareError": zod.enum(['Serialization']).describe('Error happened while serializing the module.').or(zod.enum(['Deserialization']).describe('Error happened while deserializing the module.')).or(zod.enum(['InternalMemoryDeclared']).describe('Internal memory declaration has been found in the module.')).or(zod.enum(['GasInstrumentation']).describe('Gas instrumentation failed.\n\n This most likely indicates the module isn\'t valid.')).or(zod.enum(['StackHeightInstrumentation']).describe('Stack instrumentation failed.\n\n This  most likely indicates the module isn\'t valid.')).or(zod.enum(['Instantiate']).describe('Error happened during instantiation.\n\n This might indicate that `start` function trapped, or module isn\'t\n instantiable and/or un-linkable.')).or(zod.enum(['Memory']).describe('Error creating memory.')).or(zod.enum(['TooManyFunctions']).describe('Contract contains too many functions.')).or(zod.enum(['TooManyLocals']).describe('Contract contains too many locals.')).describe('Error that can occur while preparing or executing Wasm smart-contract.')
})).or(zod.object({
  "WasmerCompileError": zod.object({
  "msg": zod.string()
})
}).describe('This is for defense in depth.\n We expect our runtime-independent preparation code to fully catch all invalid wasms,\n but, if it ever misses something we‚Äôll emit this error'))
}).describe('Wasm compilation error')).or(zod.object({
  "LinkError": zod.object({
  "msg": zod.string()
})
}).describe('Wasm binary env link error\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "MethodResolveError": zod.enum(['MethodEmptyName', 'MethodNotFound', 'MethodInvalidSignature'])
}).describe('Import/export resolve error')).or(zod.object({
  "WasmTrap": zod.enum(['Unreachable']).describe('An `unreachable` opcode was executed.').or(zod.enum(['IncorrectCallIndirectSignature']).describe('Call indirect incorrect signature trap.')).or(zod.enum(['MemoryOutOfBounds']).describe('Memory out of bounds trap.')).or(zod.enum(['CallIndirectOOB']).describe('Call indirect out of bounds trap.')).or(zod.enum(['IllegalArithmetic']).describe('An arithmetic exception, e.g. divided by zero.')).or(zod.enum(['MisalignedAtomicAccess']).describe('Misaligned atomic access trap.')).or(zod.enum(['IndirectCallToNull']).describe('Indirect call to null.')).or(zod.enum(['StackOverflow']).describe('Stack overflow.')).or(zod.enum(['GenericTrap']).describe('Generic trap.')).describe('A kind of a trap happened during execution of a binary')
}).describe('A trap happened during execution of a binary\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "HostError": zod.enum(['BadUTF16']).describe('String encoding is bad UTF-16 sequence').or(zod.enum(['BadUTF8']).describe('String encoding is bad UTF-8 sequence')).or(zod.enum(['GasExceeded']).describe('Exceeded the prepaid gas')).or(zod.enum(['GasLimitExceeded']).describe('Exceeded the maximum amount of gas allowed to burn per contract')).or(zod.enum(['BalanceExceeded']).describe('Exceeded the account balance')).or(zod.enum(['EmptyMethodName']).describe('Tried to call an empty method name')).or(zod.object({
  "GuestPanic": zod.object({
  "panic_msg": zod.string()
})
}).describe('Smart contract panicked')).or(zod.enum(['IntegerOverflow']).describe('IntegerOverflow happened during a contract execution')).or(zod.object({
  "InvalidPromiseIndex": zod.object({
  "promise_idx": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMinOne)
})
}).describe('`promise_idx` does not correspond to existing promises')).or(zod.enum(['CannotAppendActionToJointPromise']).describe('Actions can only be appended to non-joint promise.')).or(zod.enum(['CannotReturnJointPromise']).describe('Returning joint promise is currently prohibited')).or(zod.object({
  "InvalidPromiseResultIndex": zod.object({
  "result_idx": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMinOne)
})
}).describe('Accessed invalid promise result index')).or(zod.object({
  "InvalidRegisterId": zod.object({
  "register_id": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMinOne)
})
}).describe('Accessed invalid register id')).or(zod.object({
  "IteratorWasInvalidated": zod.object({
  "iterator_index": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMinOne)
})
}).describe('Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie')).or(zod.enum(['MemoryAccessViolation']).describe('Accessed memory outside the bounds')).or(zod.object({
  "InvalidReceiptIndex": zod.object({
  "receipt_index": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMinOne)
})
}).describe('VM Logic returned an invalid receipt index')).or(zod.object({
  "InvalidIteratorIndex": zod.object({
  "iterator_index": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMinOne)
})
}).describe('Iterator index `iterator_index` does not exist')).or(zod.enum(['InvalidAccountId']).describe('VM Logic returned an invalid account id')).or(zod.enum(['InvalidMethodName']).describe('VM Logic returned an invalid method name')).or(zod.enum(['InvalidPublicKey']).describe('VM Logic provided an invalid public key')).or(zod.object({
  "ProhibitedInView": zod.object({
  "method_name": zod.string()
})
}).describe('`method_name` is not allowed in view calls')).or(zod.object({
  "NumberOfLogsExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMinOne)
})
}).describe('The total number of logs will exceed the limit.')).or(zod.object({
  "KeyLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMinOne),
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMinOne)
})
}).describe('The storage key length exceeded the limit.')).or(zod.object({
  "ValueLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMinOne),
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMinOne)
})
}).describe('The storage value length exceeded the limit.')).or(zod.object({
  "TotalLogLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMinOne),
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMinOne)
})
}).describe('The total log length exceeded the limit.')).or(zod.object({
  "NumberPromisesExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMinOne),
  "number_of_promises": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMinOne)
})
}).describe('The maximum number of promises within a FunctionCall exceeded the limit.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMinOne),
  "number_of_input_data_dependencies": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne)
})
}).describe('The maximum number of input data dependencies exceeded the limit.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMinOne),
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMinOne)
})
}).describe('The returned value length exceeded the limit.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMinOne),
  "size": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMinOne)
})
}).describe('The contract size for DeployContract action exceeded the limit.')).or(zod.object({
  "Deprecated": zod.object({
  "method_name": zod.string()
})
}).describe('The host function was deprecated.')).or(zod.object({
  "ECRecoverError": zod.object({
  "msg": zod.string()
})
}).describe('General errors for ECDSA recover.')).or(zod.object({
  "AltBn128InvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to alt_bn128 family of functions (e.g., point which isn\'t\n on the curve).')).or(zod.object({
  "Ed25519VerifyInvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to ed25519 signature verification function (e.g. signature cannot be\n derived from bytes).'))
}).describe('Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "ExecutionError": zod.string()
})).describe('Serializable version of `near-vm-runner::FunctionCallError`.\n\n Must never reorder/remove elements, can only add new variants at the end (but do that very\n carefully). It describes stable serialization format, and only used by serialization logic.')
}).describe('An error occurred during a `FunctionCall` Action, parameter is debug message.')).or(zod.object({
  "NewReceiptValidationError": zod.object({
  "InvalidPredecessorId": zod.object({
  "account_id": zod.string()
})
}).describe('The `predecessor_id` of a Receipt is not valid.').or(zod.object({
  "InvalidReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a Receipt is not valid.')).or(zod.object({
  "InvalidSignerId": zod.object({
  "account_id": zod.string()
})
}).describe('The `signer_id` of an ActionReceipt is not valid.')).or(zod.object({
  "InvalidDataReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a DataReceiver within an ActionReceipt is not valid.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMinOne),
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMinOne)
})
}).describe('The length of the returned data exceeded the limit in a DataReceipt.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMinOne),
  "number_of_input_data_dependencies": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne)
})
}).describe('The number of input data dependencies exceeds the limit in an ActionReceipt.')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMinOne),
  "total_prepaid_gas": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne),
  "total_number_of_actions": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne),
  "total_number_of_bytes": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMinOne),
  "size": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMinOne)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne),
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of an ActionReceipt.')).or(zod.object({
  "ReceiptSizeExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMinOne),
  "size": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMinOne)
})
}).describe('Receipt is bigger than the limit.')).describe('Describes the error for validating a receipt.')
}).describe('Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\n receipt validation.')).or(zod.object({
  "OnlyImplicitAccountCreationAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\n See NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\n Also, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\n TODO(#8598): This error is named very poorly. A better name would be\n `OnlyNamedAccountCreationAllowed`.')).or(zod.object({
  "DeleteAccountWithLargeState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Delete account whose state is large is temporarily banned.')).or(zod.enum(['DelegateActionInvalidSignature']).describe('Signature does not match the provided actions and given signer public key.')).or(zod.object({
  "DelegateActionSenderDoesNotMatchTxReceiver": zod.object({
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Receiver of the transaction doesn\'t match Sender of the delegate action')).or(zod.enum(['DelegateActionExpired']).describe('Delegate action has expired. `max_block_height` is less than actual block height.')).or(zod.object({
  "DelegateActionAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('The given public key doesn\'t exist for Sender account')).or(zod.object({
  "DelegateActionInvalidNonce": zod.object({
  "ak_nonce": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMinOne),
  "delegate_nonce": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMinOne)
})
}).describe('DelegateAction nonce must be greater sender[public_key].nonce')).or(zod.object({
  "DelegateActionNonceTooLarge": zod.object({
  "delegate_nonce": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMinOne),
  "upper_bound": zod.number().min(broadcastTxCommitResponseResultStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMinOne)
})
}).describe('DelegateAction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "GlobalContractDoesNotExist": zod.object({
  "identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
})
})).describe('The kind of ActionError happened')
}).describe('An error happened during Action execution')
}).describe('An error happened during Action execution').or(zod.object({
  "InvalidTxError": zod.object({
  "InvalidAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('Happens if a wrong AccessKey used or AccessKey has not enough permissions').or(zod.object({
  "InvalidSignerId": zod.object({
  "signer_id": zod.string()
})
}).describe('TX signer_id is not a valid [`AccountId`]')).or(zod.object({
  "SignerDoesNotExist": zod.object({
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('TX signer_id is not found in a storage')).or(zod.object({
  "InvalidNonce": zod.object({
  "ak_nonce": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorInvalidNonceAkNonceMinOne),
  "tx_nonce": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorInvalidNonceTxNonceMinOne)
})
}).describe('Transaction nonce must be strictly greater than `account[access_key].nonce`.')).or(zod.object({
  "NonceTooLarge": zod.object({
  "tx_nonce": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorNonceTooLargeTxNonceMinOne),
  "upper_bound": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMinOne)
})
}).describe('Transaction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "InvalidReceiverId": zod.object({
  "receiver_id": zod.string()
})
}).describe('TX receiver_id is not a valid AccountId')).or(zod.enum(['InvalidSignature']).describe('TX signature is not valid')).or(zod.object({
  "NotEnoughBalance": zod.object({
  "balance": zod.string(),
  "cost": zod.string(),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account does not have enough balance to cover TX cost')).or(zod.object({
  "LackBalanceForState": zod.object({
  "amount": zod.string().describe('Required balance to cover the state.'),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which doesn\'t have enough balance to cover storage.')
})
}).describe('Signer account doesn\'t have enough balance after transaction.')).or(zod.enum(['CostOverflow']).describe('An integer overflow occurred during transaction cost estimation.')).or(zod.enum(['InvalidChain']).describe('Transaction parent block hash doesn\'t belong to the current chain')).or(zod.enum(['Expired']).describe('Transaction has expired')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMinOne),
  "total_prepaid_gas": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne),
  "total_number_of_actions": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne),
  "total_number_of_bytes": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMinOne),
  "size": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMinOne)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne),
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of a Transaction.')).or(zod.object({
  "TransactionSizeExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorTransactionSizeExceededLimitMinOne),
  "size": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorTransactionSizeExceededSizeMinOne)
})
}).describe('The size of serialized transaction exceeded the limit.')).or(zod.enum(['InvalidTransactionVersion']).describe('Transaction version is invalid.')).or(zod.object({
  "StorageError": zod.enum(['StorageInternalError']).describe('Key-value db internal failure').or(zod.object({
  "MissingTrieValue": zod.object({
  "context": zod.enum(['TrieIterator']).describe('Missing trie value when reading from TrieIterator.').or(zod.enum(['TriePrefetchingStorage']).describe('Missing trie value when reading from TriePrefetchingStorage.')).or(zod.enum(['TrieMemoryPartialStorage']).describe('Missing trie value when reading from TrieMemoryPartialStorage.')).or(zod.enum(['TrieStorage']).describe('Missing trie value when reading from TrieStorage.')).describe('Contexts in which `StorageError::MissingTrieValue` error might occur.'),
  "hash": zod.string()
})
}).describe('Requested trie value by its hash which is missing in storage.')).or(zod.enum(['UnexpectedTrieValue']).describe('Found trie node which shouldn\'t be part of state. Raised during\n validation of state sync parts where incorrect node was passed.\n TODO (#8997): consider including hash of trie node.')).or(zod.object({
  "StorageInconsistentState": zod.string()
}).describe('Either invalid state or key-value db is corrupted.\n For PartialStorage it cannot be corrupted.\n Error message is unreliable and for debugging purposes only. It\'s also probably ok to\n panic in every place that produces this error.\n We can check if db is corrupted by verifying everything in the state trie.')).or(zod.object({
  "FlatStorageBlockNotSupported": zod.string()
}).describe('Flat storage error, meaning that it doesn\'t support some block anymore.\n We guarantee that such block cannot become final, thus block processing\n must resume normally.')).or(zod.object({
  "MemTrieLoadingError": zod.string()
}).describe('In-memory trie could not be loaded for some reason.')).describe('Errors which may occur during working with trie storages, storing\n trie values (trie nodes and state values) by their hashes.')
})).or(zod.object({
  "ShardCongested": zod.object({
  "congestion_level": zod.number().describe('A value between 0 (no congestion) and 1 (max congestion).'),
  "shard_id": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorShardCongestedShardIdMinOne).describe('The congested shard.')
})
}).describe('The receiver shard of the transaction is too congested to accept new\n transactions at the moment.')).or(zod.object({
  "ShardStuck": zod.object({
  "missed_chunks": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorShardStuckMissedChunksMinOne).describe('The number of blocks since the last included chunk of the shard.'),
  "shard_id": zod.number().min(broadcastTxCommitResponseResultStatusFailureInvalidTxErrorShardStuckShardIdMinOne).describe('The shard that fails making progress.')
})
}).describe('The receiver shard of the transaction missed several chunks and rejects\n new transaction until it can make progress again.')).describe('An error happened during TX execution')
}).describe('An error happened during Transaction execution')).describe('Error returned in the ExecutionOutcome in case of failure')
}).describe('The execution has failed with the given error.')).or(zod.object({
  "SuccessValue": zod.string()
}).describe('The execution has succeeded and returned some value or an empty vec encoded in base64.')).describe('Execution status defined by chain.rs:get_final_transaction_result\n FinalExecutionStatus::NotStarted - the tx is not converted to the receipt yet\n FinalExecutionStatus::Started - we have at least 1 receipt, but the first leaf receipt_id (using dfs) hasn\'t finished the execution\n FinalExecutionStatus::Failure - the result of the first leaf receipt_id\n FinalExecutionStatus::SuccessValue - the result of the first leaf receipt_id'),
  "transaction": zod.object({
  "actions": zod.array(zod.enum(['CreateAccount']).or(zod.object({
  "DeployContract": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "FunctionCall": zod.object({
  "args": zod.string(),
  "deposit": zod.string(),
  "gas": zod.number().min(broadcastTxCommitResponseResultTransactionActionsItemFunctionCallGasMinOne),
  "method_name": zod.string()
})
})).or(zod.object({
  "Transfer": zod.object({
  "deposit": zod.string()
})
})).or(zod.object({
  "Stake": zod.object({
  "public_key": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "AddKey": zod.object({
  "access_key": zod.object({
  "nonce": zod.number().min(broadcastTxCommitResponseResultTransactionActionsItemAddKeyAccessKeyNonceMinOne),
  "permission": zod.enum(['FullAccess']).or(zod.object({
  "FunctionCall": zod.object({
  "allowance": zod.string().nullish(),
  "method_names": zod.array(zod.string()),
  "receiver_id": zod.string()
})
}))
}),
  "public_key": zod.string()
})
})).or(zod.object({
  "DeleteKey": zod.object({
  "public_key": zod.string()
})
})).or(zod.object({
  "DeleteAccount": zod.object({
  "beneficiary_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
})).or(zod.object({
  "Delegate": zod.object({
  "delegate_action": zod.object({
  "actions": zod.array(zod.object({
  "CreateAccount": zod.object({

}).describe('Create account action')
}).describe('Create an (sub)account using a transaction `receiver_id` as an ID for\n a new account ID must pass validation rules described here\n <http://nomicon.io/Primitives/Account.html>.').or(zod.object({
  "DeployContract": zod.object({
  "code": zod.string().describe('WebAssembly binary')
}).describe('Deploy contract action')
}).describe('Sets a Wasm code to a receiver_id')).or(zod.object({
  "FunctionCall": zod.object({
  "args": zod.string(),
  "deposit": zod.string(),
  "gas": zod.number().min(broadcastTxCommitResponseResultTransactionActionsItemDelegateDelegateActionActionsItemFunctionCallGasMinOne),
  "method_name": zod.string()
})
})).or(zod.object({
  "Transfer": zod.object({
  "deposit": zod.string()
})
})).or(zod.object({
  "Stake": zod.object({
  "public_key": zod.string().describe('Validator key which will be used to sign transactions on behalf of signer_id'),
  "stake": zod.string().describe('Amount of tokens to stake.')
}).describe('An action which stakes signer_id tokens and setup\'s validator public key')
})).or(zod.object({
  "AddKey": zod.object({
  "access_key": zod.object({
  "nonce": zod.number().min(broadcastTxCommitResponseResultTransactionActionsItemDelegateDelegateActionActionsItemAddKeyAccessKeyNonceMinOne).describe('Nonce for this access key, used for tx nonce generation. When access key is created, nonce\n is set to `(block_height - 1) * 1e6` to avoid tx hash collision on access key re-creation.\n See <https://github.com/near/nearcore/issues/3779> for more details.'),
  "permission": zod.object({
  "FunctionCall": zod.object({
  "allowance": zod.string().nullish().describe('Allowance is a balance limit to use by this access key to pay for function call gas and\n transaction fees. When this access key is used, both account balance and the allowance is\n decreased by the same value.\n `None` means unlimited allowance.\n NOTE: To change or increase the allowance, the old access key needs to be deleted and a new\n access key should be created.'),
  "method_names": zod.array(zod.string()).describe('A list of method names that can be used. The access key only allows transactions with the\n function call of one of the given method names.\n Empty list means any method name can be used.'),
  "receiver_id": zod.string().describe('The access key only allows transactions with the given receiver\'s account id.')
}).describe('Grants limited permission to make transactions with FunctionCallActions\n The permission can limit the allowed balance to be spent on the prepaid gas.\n It also restrict the account ID of the receiver for this function call.\n It also can restrict the method name for the allowed function calls.')
}).or(zod.enum(['FullAccess']).describe('Grants full access to the account.\n NOTE: It\'s used to replace account-level public keys.')).describe('Defines permissions for AccessKey').describe('Defines permissions for this access key.')
}).describe('Access key provides limited access to an account. Each access key belongs to some account and\n is identified by a unique (within the account) public key. One account may have large number of\n access keys. Access keys allow to act on behalf of the account by restricting transactions\n that can be issued.\n `account_id,public_key` is a key in the state').describe('An access key with the permission'),
  "public_key": zod.string().describe('A public key which will be associated with an access_key')
})
})).or(zod.object({
  "DeleteKey": zod.object({
  "public_key": zod.string().describe('A public key associated with the access_key to be deleted.')
})
})).or(zod.object({
  "DeleteAccount": zod.object({
  "beneficiary_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
})).or(zod.object({
  "Delegate": zod.object({
  "delegate_action": zod.any(),
  "signature": zod.string()
})
})).or(zod.object({
  "DeployGlobalContract": zod.object({
  "code": zod.string().describe('WebAssembly binary'),
  "deploy_mode": zod.enum(['CodeHash']).describe('Contract is deployed under its code hash.\n Users will be able reference it by that hash.\n This effectively makes the contract immutable.').or(zod.enum(['AccountId']).describe('Contract is deployed under the owner account id.\n Users will be able reference it by that account id.\n This allows the owner to update the contract for all its users.'))
}).describe('Deploy global contract action')
})).or(zod.object({
  "UseGlobalContract": zod.object({
  "contract_identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
}).describe('Use global contract action')
})).describe('This is Action which mustn\'t contain DelegateAction.\n\n This struct is needed to avoid the recursion when Action/DelegateAction is deserialized.\n\n Important: Don\'t make the inner Action public, this must only be constructed\n through the correct interface that ensures the inner Action is actually not\n a delegate action. That would break an assumption of this type, which we use\n in several places. For example, borsh de-/serialization relies on it. If the\n invariant is broken, we may end up with a `Transaction` or `Receipt` that we\n can serialize but deserializing it back causes a parsing error.')).describe('List of actions to be executed.\n\n With the meta transactions MVP defined in NEP-366, nested\n DelegateActions are not allowed. A separate type is used to enforce it.'),
  "max_block_height": zod.number().min(broadcastTxCommitResponseResultTransactionActionsItemDelegateDelegateActionMaxBlockHeightMinOne).describe('The maximal height of the block in the blockchain below which the given DelegateAction is valid.'),
  "nonce": zod.number().min(broadcastTxCommitResponseResultTransactionActionsItemDelegateDelegateActionNonceMinOne).describe('Nonce to ensure that the same delegate action is not sent twice by a\n relayer and should match for given account\'s `public_key`.\n After this action is processed it will increment.'),
  "public_key": zod.string().describe('Public key used to sign this delegated action.'),
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('Receiver of the delegated actions.'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('Signer of the delegated actions')
}).describe('This action allows to execute the inner actions behalf of the defined sender.'),
  "signature": zod.string()
})
})).or(zod.object({
  "DeployGlobalContract": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "DeployGlobalContractByAccountId": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "UseGlobalContract": zod.object({
  "code_hash": zod.string()
})
})).or(zod.object({
  "UseGlobalContractByAccountId": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}))),
  "hash": zod.string(),
  "nonce": zod.number().min(broadcastTxCommitResponseResultTransactionNonceMinOne),
  "priority_fee": zod.number().min(broadcastTxCommitResponseResultTransactionPriorityFeeMinOne).optional(),
  "public_key": zod.string(),
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "signature": zod.string(),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}).describe('Signed Transaction'),
  "transaction_outcome": zod.object({
  "block_hash": zod.string(),
  "id": zod.string(),
  "outcome": zod.object({
  "executor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('The id of the account on which the execution happens. For transaction this is signer_id,\n for receipt this is receiver_id.'),
  "gas_burnt": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeGasBurntMinOne).describe('The amount of the gas burnt by the given transaction or receipt.'),
  "logs": zod.array(zod.string()).describe('Logs from this transaction or receipt.'),
  "metadata": zod.object({
  "gas_profile": zod.array(zod.object({
  "cost": zod.string(),
  "cost_category": zod.string(),
  "gas_used": zod.string()
})).nullish(),
  "version": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeMetadataVersionMinOne)
}).default(broadcastTxCommitResponseResultTransactionOutcomeOutcomeMetadataDefaultTwo).describe('Execution metadata, versioned'),
  "receipt_ids": zod.array(zod.string()).describe('Receipt IDs generated by this transaction or receipt.'),
  "status": zod.enum(['Unknown']).describe('The execution is pending or unknown.').or(zod.object({
  "Failure": zod.object({
  "ActionError": zod.object({
  "index": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorIndexMinOne).nullish().describe('Index of the failed action in the transaction.\n Action index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`'),
  "kind": zod.object({
  "AccountAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage').or(zod.object({
  "AccountDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when TX receiver_id doesn\'t exist (but action is not Action::CreateAccount)')).or(zod.object({
  "CreateAccountOnlyByRegistrar": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "registrar_account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A top-level account ID can only be created by registrar.')).or(zod.object({
  "CreateAccountNotAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A newly created account must be under a namespace of the creator account')).or(zod.object({
  "ActorNoPermission": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "actor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\n or the first TX action is a `CreateAccount` action')).or(zod.object({
  "DeleteKeyDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('Account tries to remove an access key that doesn\'t exist')).or(zod.object({
  "AddKeyAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The public key is already used for an existing access key')).or(zod.object({
  "DeleteAccountStaking": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is staking and can not be deleted')).or(zod.object({
  "LackBalanceForState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which needs balance'),
  "amount": zod.string().describe('Balance required to complete an action.')
})
}).describe('ActionReceipt can\'t be completed, because the remaining balance will not be enough to cover storage.')).or(zod.object({
  "TriesToUnstake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is not yet staked, but tries to unstake')).or(zod.object({
  "TriesToStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "balance": zod.string(),
  "locked": zod.string(),
  "stake": zod.string()
})
}).describe('The account doesn\'t have enough balance to increase the stake.')).or(zod.object({
  "InsufficientStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "minimum_stake": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "FunctionCallError": zod.enum(['WasmUnknownError', '_EVMError']).or(zod.object({
  "CompilationError": zod.object({
  "CodeDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).or(zod.object({
  "PrepareError": zod.enum(['Serialization']).describe('Error happened while serializing the module.').or(zod.enum(['Deserialization']).describe('Error happened while deserializing the module.')).or(zod.enum(['InternalMemoryDeclared']).describe('Internal memory declaration has been found in the module.')).or(zod.enum(['GasInstrumentation']).describe('Gas instrumentation failed.\n\n This most likely indicates the module isn\'t valid.')).or(zod.enum(['StackHeightInstrumentation']).describe('Stack instrumentation failed.\n\n This  most likely indicates the module isn\'t valid.')).or(zod.enum(['Instantiate']).describe('Error happened during instantiation.\n\n This might indicate that `start` function trapped, or module isn\'t\n instantiable and/or un-linkable.')).or(zod.enum(['Memory']).describe('Error creating memory.')).or(zod.enum(['TooManyFunctions']).describe('Contract contains too many functions.')).or(zod.enum(['TooManyLocals']).describe('Contract contains too many locals.')).describe('Error that can occur while preparing or executing Wasm smart-contract.')
})).or(zod.object({
  "WasmerCompileError": zod.object({
  "msg": zod.string()
})
}).describe('This is for defense in depth.\n We expect our runtime-independent preparation code to fully catch all invalid wasms,\n but, if it ever misses something we‚Äôll emit this error'))
}).describe('Wasm compilation error')).or(zod.object({
  "LinkError": zod.object({
  "msg": zod.string()
})
}).describe('Wasm binary env link error\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "MethodResolveError": zod.enum(['MethodEmptyName', 'MethodNotFound', 'MethodInvalidSignature'])
}).describe('Import/export resolve error')).or(zod.object({
  "WasmTrap": zod.enum(['Unreachable']).describe('An `unreachable` opcode was executed.').or(zod.enum(['IncorrectCallIndirectSignature']).describe('Call indirect incorrect signature trap.')).or(zod.enum(['MemoryOutOfBounds']).describe('Memory out of bounds trap.')).or(zod.enum(['CallIndirectOOB']).describe('Call indirect out of bounds trap.')).or(zod.enum(['IllegalArithmetic']).describe('An arithmetic exception, e.g. divided by zero.')).or(zod.enum(['MisalignedAtomicAccess']).describe('Misaligned atomic access trap.')).or(zod.enum(['IndirectCallToNull']).describe('Indirect call to null.')).or(zod.enum(['StackOverflow']).describe('Stack overflow.')).or(zod.enum(['GenericTrap']).describe('Generic trap.')).describe('A kind of a trap happened during execution of a binary')
}).describe('A trap happened during execution of a binary\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "HostError": zod.enum(['BadUTF16']).describe('String encoding is bad UTF-16 sequence').or(zod.enum(['BadUTF8']).describe('String encoding is bad UTF-8 sequence')).or(zod.enum(['GasExceeded']).describe('Exceeded the prepaid gas')).or(zod.enum(['GasLimitExceeded']).describe('Exceeded the maximum amount of gas allowed to burn per contract')).or(zod.enum(['BalanceExceeded']).describe('Exceeded the account balance')).or(zod.enum(['EmptyMethodName']).describe('Tried to call an empty method name')).or(zod.object({
  "GuestPanic": zod.object({
  "panic_msg": zod.string()
})
}).describe('Smart contract panicked')).or(zod.enum(['IntegerOverflow']).describe('IntegerOverflow happened during a contract execution')).or(zod.object({
  "InvalidPromiseIndex": zod.object({
  "promise_idx": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMinOne)
})
}).describe('`promise_idx` does not correspond to existing promises')).or(zod.enum(['CannotAppendActionToJointPromise']).describe('Actions can only be appended to non-joint promise.')).or(zod.enum(['CannotReturnJointPromise']).describe('Returning joint promise is currently prohibited')).or(zod.object({
  "InvalidPromiseResultIndex": zod.object({
  "result_idx": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMinOne)
})
}).describe('Accessed invalid promise result index')).or(zod.object({
  "InvalidRegisterId": zod.object({
  "register_id": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMinOne)
})
}).describe('Accessed invalid register id')).or(zod.object({
  "IteratorWasInvalidated": zod.object({
  "iterator_index": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMinOne)
})
}).describe('Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie')).or(zod.enum(['MemoryAccessViolation']).describe('Accessed memory outside the bounds')).or(zod.object({
  "InvalidReceiptIndex": zod.object({
  "receipt_index": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMinOne)
})
}).describe('VM Logic returned an invalid receipt index')).or(zod.object({
  "InvalidIteratorIndex": zod.object({
  "iterator_index": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMinOne)
})
}).describe('Iterator index `iterator_index` does not exist')).or(zod.enum(['InvalidAccountId']).describe('VM Logic returned an invalid account id')).or(zod.enum(['InvalidMethodName']).describe('VM Logic returned an invalid method name')).or(zod.enum(['InvalidPublicKey']).describe('VM Logic provided an invalid public key')).or(zod.object({
  "ProhibitedInView": zod.object({
  "method_name": zod.string()
})
}).describe('`method_name` is not allowed in view calls')).or(zod.object({
  "NumberOfLogsExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMinOne)
})
}).describe('The total number of logs will exceed the limit.')).or(zod.object({
  "KeyLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMinOne),
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMinOne)
})
}).describe('The storage key length exceeded the limit.')).or(zod.object({
  "ValueLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMinOne),
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMinOne)
})
}).describe('The storage value length exceeded the limit.')).or(zod.object({
  "TotalLogLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMinOne),
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMinOne)
})
}).describe('The total log length exceeded the limit.')).or(zod.object({
  "NumberPromisesExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMinOne),
  "number_of_promises": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMinOne)
})
}).describe('The maximum number of promises within a FunctionCall exceeded the limit.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMinOne),
  "number_of_input_data_dependencies": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne)
})
}).describe('The maximum number of input data dependencies exceeded the limit.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMinOne),
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMinOne)
})
}).describe('The returned value length exceeded the limit.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMinOne),
  "size": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMinOne)
})
}).describe('The contract size for DeployContract action exceeded the limit.')).or(zod.object({
  "Deprecated": zod.object({
  "method_name": zod.string()
})
}).describe('The host function was deprecated.')).or(zod.object({
  "ECRecoverError": zod.object({
  "msg": zod.string()
})
}).describe('General errors for ECDSA recover.')).or(zod.object({
  "AltBn128InvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to alt_bn128 family of functions (e.g., point which isn\'t\n on the curve).')).or(zod.object({
  "Ed25519VerifyInvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to ed25519 signature verification function (e.g. signature cannot be\n derived from bytes).'))
}).describe('Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "ExecutionError": zod.string()
})).describe('Serializable version of `near-vm-runner::FunctionCallError`.\n\n Must never reorder/remove elements, can only add new variants at the end (but do that very\n carefully). It describes stable serialization format, and only used by serialization logic.')
}).describe('An error occurred during a `FunctionCall` Action, parameter is debug message.')).or(zod.object({
  "NewReceiptValidationError": zod.object({
  "InvalidPredecessorId": zod.object({
  "account_id": zod.string()
})
}).describe('The `predecessor_id` of a Receipt is not valid.').or(zod.object({
  "InvalidReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a Receipt is not valid.')).or(zod.object({
  "InvalidSignerId": zod.object({
  "account_id": zod.string()
})
}).describe('The `signer_id` of an ActionReceipt is not valid.')).or(zod.object({
  "InvalidDataReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a DataReceiver within an ActionReceipt is not valid.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMinOne),
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMinOne)
})
}).describe('The length of the returned data exceeded the limit in a DataReceipt.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMinOne),
  "number_of_input_data_dependencies": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne)
})
}).describe('The number of input data dependencies exceeds the limit in an ActionReceipt.')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMinOne),
  "total_prepaid_gas": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne),
  "total_number_of_actions": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne),
  "total_number_of_bytes": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMinOne),
  "size": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMinOne)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne),
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of an ActionReceipt.')).or(zod.object({
  "ReceiptSizeExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMinOne),
  "size": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMinOne)
})
}).describe('Receipt is bigger than the limit.')).describe('Describes the error for validating a receipt.')
}).describe('Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\n receipt validation.')).or(zod.object({
  "OnlyImplicitAccountCreationAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\n See NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\n Also, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\n TODO(#8598): This error is named very poorly. A better name would be\n `OnlyNamedAccountCreationAllowed`.')).or(zod.object({
  "DeleteAccountWithLargeState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Delete account whose state is large is temporarily banned.')).or(zod.enum(['DelegateActionInvalidSignature']).describe('Signature does not match the provided actions and given signer public key.')).or(zod.object({
  "DelegateActionSenderDoesNotMatchTxReceiver": zod.object({
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Receiver of the transaction doesn\'t match Sender of the delegate action')).or(zod.enum(['DelegateActionExpired']).describe('Delegate action has expired. `max_block_height` is less than actual block height.')).or(zod.object({
  "DelegateActionAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('The given public key doesn\'t exist for Sender account')).or(zod.object({
  "DelegateActionInvalidNonce": zod.object({
  "ak_nonce": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMinOne),
  "delegate_nonce": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMinOne)
})
}).describe('DelegateAction nonce must be greater sender[public_key].nonce')).or(zod.object({
  "DelegateActionNonceTooLarge": zod.object({
  "delegate_nonce": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMinOne),
  "upper_bound": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMinOne)
})
}).describe('DelegateAction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "GlobalContractDoesNotExist": zod.object({
  "identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
})
})).describe('The kind of ActionError happened')
}).describe('An error happened during Action execution')
}).describe('An error happened during Action execution').or(zod.object({
  "InvalidTxError": zod.object({
  "InvalidAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('Happens if a wrong AccessKey used or AccessKey has not enough permissions').or(zod.object({
  "InvalidSignerId": zod.object({
  "signer_id": zod.string()
})
}).describe('TX signer_id is not a valid [`AccountId`]')).or(zod.object({
  "SignerDoesNotExist": zod.object({
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('TX signer_id is not found in a storage')).or(zod.object({
  "InvalidNonce": zod.object({
  "ak_nonce": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorInvalidNonceAkNonceMinOne),
  "tx_nonce": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorInvalidNonceTxNonceMinOne)
})
}).describe('Transaction nonce must be strictly greater than `account[access_key].nonce`.')).or(zod.object({
  "NonceTooLarge": zod.object({
  "tx_nonce": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorNonceTooLargeTxNonceMinOne),
  "upper_bound": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMinOne)
})
}).describe('Transaction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "InvalidReceiverId": zod.object({
  "receiver_id": zod.string()
})
}).describe('TX receiver_id is not a valid AccountId')).or(zod.enum(['InvalidSignature']).describe('TX signature is not valid')).or(zod.object({
  "NotEnoughBalance": zod.object({
  "balance": zod.string(),
  "cost": zod.string(),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account does not have enough balance to cover TX cost')).or(zod.object({
  "LackBalanceForState": zod.object({
  "amount": zod.string().describe('Required balance to cover the state.'),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which doesn\'t have enough balance to cover storage.')
})
}).describe('Signer account doesn\'t have enough balance after transaction.')).or(zod.enum(['CostOverflow']).describe('An integer overflow occurred during transaction cost estimation.')).or(zod.enum(['InvalidChain']).describe('Transaction parent block hash doesn\'t belong to the current chain')).or(zod.enum(['Expired']).describe('Transaction has expired')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMinOne),
  "total_prepaid_gas": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne),
  "total_number_of_actions": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne),
  "total_number_of_bytes": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMinOne),
  "size": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMinOne)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne),
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of a Transaction.')).or(zod.object({
  "TransactionSizeExceeded": zod.object({
  "limit": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededLimitMinOne),
  "size": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededSizeMinOne)
})
}).describe('The size of serialized transaction exceeded the limit.')).or(zod.enum(['InvalidTransactionVersion']).describe('Transaction version is invalid.')).or(zod.object({
  "StorageError": zod.enum(['StorageInternalError']).describe('Key-value db internal failure').or(zod.object({
  "MissingTrieValue": zod.object({
  "context": zod.enum(['TrieIterator']).describe('Missing trie value when reading from TrieIterator.').or(zod.enum(['TriePrefetchingStorage']).describe('Missing trie value when reading from TriePrefetchingStorage.')).or(zod.enum(['TrieMemoryPartialStorage']).describe('Missing trie value when reading from TrieMemoryPartialStorage.')).or(zod.enum(['TrieStorage']).describe('Missing trie value when reading from TrieStorage.')).describe('Contexts in which `StorageError::MissingTrieValue` error might occur.'),
  "hash": zod.string()
})
}).describe('Requested trie value by its hash which is missing in storage.')).or(zod.enum(['UnexpectedTrieValue']).describe('Found trie node which shouldn\'t be part of state. Raised during\n validation of state sync parts where incorrect node was passed.\n TODO (#8997): consider including hash of trie node.')).or(zod.object({
  "StorageInconsistentState": zod.string()
}).describe('Either invalid state or key-value db is corrupted.\n For PartialStorage it cannot be corrupted.\n Error message is unreliable and for debugging purposes only. It\'s also probably ok to\n panic in every place that produces this error.\n We can check if db is corrupted by verifying everything in the state trie.')).or(zod.object({
  "FlatStorageBlockNotSupported": zod.string()
}).describe('Flat storage error, meaning that it doesn\'t support some block anymore.\n We guarantee that such block cannot become final, thus block processing\n must resume normally.')).or(zod.object({
  "MemTrieLoadingError": zod.string()
}).describe('In-memory trie could not be loaded for some reason.')).describe('Errors which may occur during working with trie storages, storing\n trie values (trie nodes and state values) by their hashes.')
})).or(zod.object({
  "ShardCongested": zod.object({
  "congestion_level": zod.number().describe('A value between 0 (no congestion) and 1 (max congestion).'),
  "shard_id": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardCongestedShardIdMinOne).describe('The congested shard.')
})
}).describe('The receiver shard of the transaction is too congested to accept new\n transactions at the moment.')).or(zod.object({
  "ShardStuck": zod.object({
  "missed_chunks": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardStuckMissedChunksMinOne).describe('The number of blocks since the last included chunk of the shard.'),
  "shard_id": zod.number().min(broadcastTxCommitResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardStuckShardIdMinOne).describe('The shard that fails making progress.')
})
}).describe('The receiver shard of the transaction missed several chunks and rejects\n new transaction until it can make progress again.')).describe('An error happened during TX execution')
}).describe('An error happened during Transaction execution')).describe('Error returned in the ExecutionOutcome in case of failure')
}).describe('The execution has failed.')).or(zod.object({
  "SuccessValue": zod.string()
}).describe('The final action succeeded and returned some value or an empty vec encoded in base64.')).or(zod.object({
  "SuccessReceiptId": zod.string()
}).describe('The final action of the receipt returned a promise or the signed transaction was converted\n to a receipt. Contains the receipt_id of the generated receipt.')).describe('Execution status. Contains the result in case of successful execution.'),
  "tokens_burnt": zod.string().describe('The amount of tokens burnt corresponding to the burnt gas amount.\n This value doesn\'t always equal to the `gas_burnt` multiplied by the gas price, because\n the prepaid gas price might be lower than the actual gas price and it creates a deficit.\n `tokens_burnt` also contains the penalty subtracted from refunds, while\n `gas_burnt` only contains the gas that we actually burn for the execution.')
}),
  "proof": zod.array(zod.object({
  "direction": zod.enum(['Left', 'Right']),
  "hash": zod.string()
}))
}).describe('The execution outcome of the signed transaction.')
}).describe('Execution outcome of the transaction and all the subsequent receipts.\n Could be not finalized yet'))
}).or(zod.object({
  "error": zod.object({
  "cause": zod.object({
  "info": zod.object({
  "method_name": zod.string()
}),
  "name": zod.enum(['METHOD_NOT_FOUND'])
}).or(zod.object({
  "info": zod.object({
  "error_message": zod.string()
}),
  "name": zod.enum(['PARSE_ERROR'])
})),
  "name": zod.enum(['REQUEST_VALIDATION_ERROR'])
}).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['HANDLER_ERROR'])
})).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['INTERNAL_ERROR'])
})).describe('This struct may be returned from JSON RPC server in case of error\n It is expected that this struct has impl From<_> all other RPC errors\n like [RpcBlockError](crate::types::blocks::RpcBlockError)')
}))


export const changesBodyParamsBlockIdMinOne = 0;


export const changesBody = zod.object({
  "id": zod.string(),
  "jsonrpc": zod.string(),
  "method": zod.enum(['changes']),
  "params": zod.object({
  "block_id": zod.number().min(changesBodyParamsBlockIdMinOne).or(zod.string())
}).or(zod.object({
  "finality": zod.enum(['optimistic', 'near-final', 'final']).describe('Different types of finality.')
})).or(zod.object({
  "sync_checkpoint": zod.enum(['genesis', 'earliest_available'])
})).and(zod.object({
  "account_ids": zod.array(zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')),
  "changes_type": zod.enum(['account_changes'])
}).or(zod.object({
  "changes_type": zod.enum(['single_access_key_changes']),
  "keys": zod.array(zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
}))
})).or(zod.object({
  "changes_type": zod.enum(['single_gas_key_changes']),
  "keys": zod.array(zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
}))
})).or(zod.object({
  "account_ids": zod.array(zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')),
  "changes_type": zod.enum(['all_access_key_changes'])
})).or(zod.object({
  "account_ids": zod.array(zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')),
  "changes_type": zod.enum(['all_gas_key_changes'])
})).or(zod.object({
  "account_ids": zod.array(zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')),
  "changes_type": zod.enum(['contract_code_changes'])
})).or(zod.object({
  "account_ids": zod.array(zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')),
  "changes_type": zod.enum(['data_changes']),
  "key_prefix_base64": zod.string()
}))).describe('It is a [serializable view] of [`StateChangesRequest`].\n\n [serializable view]: ./index.html\n [`StateChangesRequest`]: ../types/struct.StateChangesRequest.html')
})

export const changesResponseResultChangesItemChangeStoragePaidAtDefault = 0;
export const changesResponseResultChangesItemChangeStoragePaidAtMin = 0;
export const changesResponseResultChangesItemChangeStorageUsageMin = 0;
export const changesResponseResultChangesItemChangeAccessKeyNonceMin = 0;
export const changesResponseResultChangesItemChangeGasKeyBalanceMin = 0;
export const changesResponseResultChangesItemChangeGasKeyNumNoncesMin = 0;
export const changesResponseResultChangesItemChangeIndexMin = 0;
export const changesResponseResultChangesItemChangeNonceMin = 0;


export const changesResponse = zod.object({
  "result": zod.object({
  "block_hash": zod.string(),
  "changes": zod.array(zod.object({
  "change": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "amount": zod.string(),
  "code_hash": zod.string(),
  "global_contract_account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').nullish(),
  "global_contract_hash": zod.string().nullish(),
  "locked": zod.string(),
  "storage_paid_at": zod.number().min(changesResponseResultChangesItemChangeStoragePaidAtMin).optional().describe('TODO(2271): deprecated.'),
  "storage_usage": zod.number().min(changesResponseResultChangesItemChangeStorageUsageMin)
}).describe('A view of the account'),
  "type": zod.enum(['account_update'])
}).or(zod.object({
  "change": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}),
  "type": zod.enum(['account_deletion'])
})).or(zod.object({
  "change": zod.object({
  "access_key": zod.object({
  "nonce": zod.number().min(changesResponseResultChangesItemChangeAccessKeyNonceMin),
  "permission": zod.enum(['FullAccess']).or(zod.object({
  "FunctionCall": zod.object({
  "allowance": zod.string().nullish(),
  "method_names": zod.array(zod.string()),
  "receiver_id": zod.string()
})
}))
}),
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
}),
  "type": zod.enum(['access_key_update'])
})).or(zod.object({
  "change": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
}),
  "type": zod.enum(['access_key_deletion'])
})).or(zod.object({
  "change": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "gas_key": zod.object({
  "balance": zod.number().min(changesResponseResultChangesItemChangeGasKeyBalanceMin),
  "num_nonces": zod.number().min(changesResponseResultChangesItemChangeGasKeyNumNoncesMin),
  "permission": zod.enum(['FullAccess']).or(zod.object({
  "FunctionCall": zod.object({
  "allowance": zod.string().nullish(),
  "method_names": zod.array(zod.string()),
  "receiver_id": zod.string()
})
}))
}),
  "public_key": zod.string()
}),
  "type": zod.enum(['gas_key_update'])
})).or(zod.object({
  "change": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "index": zod.number().min(changesResponseResultChangesItemChangeIndexMin),
  "nonce": zod.number().min(changesResponseResultChangesItemChangeNonceMin),
  "public_key": zod.string()
}),
  "type": zod.enum(['gas_key_nonce_update'])
})).or(zod.object({
  "change": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
}),
  "type": zod.enum(['gas_key_deletion'])
})).or(zod.object({
  "change": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "key_base64": zod.string(),
  "value_base64": zod.string()
}),
  "type": zod.enum(['data_update'])
})).or(zod.object({
  "change": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "key_base64": zod.string()
}),
  "type": zod.enum(['data_deletion'])
})).or(zod.object({
  "change": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "code_base64": zod.string()
}),
  "type": zod.enum(['contract_code_update'])
})).or(zod.object({
  "change": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}),
  "type": zod.enum(['contract_code_deletion'])
})))
})
}).or(zod.object({
  "error": zod.object({
  "cause": zod.object({
  "info": zod.object({
  "method_name": zod.string()
}),
  "name": zod.enum(['METHOD_NOT_FOUND'])
}).or(zod.object({
  "info": zod.object({
  "error_message": zod.string()
}),
  "name": zod.enum(['PARSE_ERROR'])
})),
  "name": zod.enum(['REQUEST_VALIDATION_ERROR'])
}).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['HANDLER_ERROR'])
})).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['INTERNAL_ERROR'])
})).describe('This struct may be returned from JSON RPC server in case of error\n It is expected that this struct has impl From<_> all other RPC errors\n like [RpcBlockError](crate::types::blocks::RpcBlockError)')
}))


export const chunkBodyParamsBlockIdMinOne = 0;
export const chunkBodyParamsShardIdMin = 0;


export const chunkBody = zod.object({
  "id": zod.string(),
  "jsonrpc": zod.string(),
  "method": zod.enum(['chunk']),
  "params": zod.object({
  "block_id": zod.number().min(chunkBodyParamsBlockIdMinOne).or(zod.string()),
  "shard_id": zod.number().min(chunkBodyParamsShardIdMin).describe('The shard identifier. It may be an arbitrary number - it does not need to be\n a number in the range 0..NUM_SHARDS. The shard ids do not need to be\n sequential or contiguous.\n\n The shard id is wrapped in a new type to prevent the old pattern of using\n indices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\n if fully complete it potentially may be simplified to a regular type alias.')
}).or(zod.object({
  "chunk_id": zod.string()
}))
})

export const chunkResponseResultHeaderBandwidthRequestsV1RequestsItemRequestedValuesBitmapDataItemMin = 0;
export const chunkResponseResultHeaderBandwidthRequestsV1RequestsItemRequestedValuesBitmapDataMin = 5;

export const chunkResponseResultHeaderBandwidthRequestsV1RequestsItemRequestedValuesBitmapDataMax = 5;
export const chunkResponseResultHeaderBandwidthRequestsV1RequestsItemToShardMin = 0;
export const chunkResponseResultHeaderCongestionInfoAllowedShardMin = 0;
export const chunkResponseResultHeaderCongestionInfoReceiptBytesMin = 0;
export const chunkResponseResultHeaderEncodedLengthMin = 0;
export const chunkResponseResultHeaderGasLimitMin = 0;
export const chunkResponseResultHeaderGasUsedMin = 0;
export const chunkResponseResultHeaderHeightCreatedMin = 0;
export const chunkResponseResultHeaderHeightIncludedMin = 0;
export const chunkResponseResultHeaderShardIdMin = 0;
export const chunkResponseResultReceiptsItemPriorityDefault = 0;
export const chunkResponseResultReceiptsItemPriorityMin = 0;
export const chunkResponseResultReceiptsItemReceiptActionActionsItemFunctionCallGasMin = 0;
export const chunkResponseResultReceiptsItemReceiptActionActionsItemAddKeyAccessKeyNonceMin = 0;
export const chunkResponseResultReceiptsItemReceiptActionActionsItemDelegateDelegateActionActionsItemFunctionCallGasMin = 0;
export const chunkResponseResultReceiptsItemReceiptActionActionsItemDelegateDelegateActionActionsItemAddKeyAccessKeyNonceMin = 0;
export const chunkResponseResultReceiptsItemReceiptActionActionsItemDelegateDelegateActionMaxBlockHeightMin = 0;
export const chunkResponseResultReceiptsItemReceiptActionActionsItemDelegateDelegateActionNonceMin = 0;
export const chunkResponseResultReceiptsItemReceiptActionIsPromiseYieldDefault = false;export const chunkResponseResultReceiptsItemReceiptDataDataDefault = null;export const chunkResponseResultReceiptsItemReceiptDataIsPromiseResumeDefault = false;export const chunkResponseResultReceiptsItemReceiptGlobalContractDistributionAlreadyDeliveredShardsItemMin = 0;
export const chunkResponseResultReceiptsItemReceiptGlobalContractDistributionTargetShardMin = 0;
export const chunkResponseResultTransactionsItemActionsItemFunctionCallGasMin = 0;
export const chunkResponseResultTransactionsItemActionsItemAddKeyAccessKeyNonceMin = 0;
export const chunkResponseResultTransactionsItemActionsItemDelegateDelegateActionActionsItemFunctionCallGasMin = 0;
export const chunkResponseResultTransactionsItemActionsItemDelegateDelegateActionActionsItemAddKeyAccessKeyNonceMin = 0;
export const chunkResponseResultTransactionsItemActionsItemDelegateDelegateActionMaxBlockHeightMin = 0;
export const chunkResponseResultTransactionsItemActionsItemDelegateDelegateActionNonceMin = 0;
export const chunkResponseResultTransactionsItemNonceMin = 0;
export const chunkResponseResultTransactionsItemPriorityFeeDefault = 0;
export const chunkResponseResultTransactionsItemPriorityFeeMin = 0;


export const chunkResponse = zod.object({
  "result": zod.object({
  "author": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "header": zod.object({
  "balance_burnt": zod.string(),
  "bandwidth_requests": zod.object({
  "V1": zod.object({
  "requests": zod.array(zod.object({
  "requested_values_bitmap": zod.object({
  "data": zod.array(zod.number().min(chunkResponseResultHeaderBandwidthRequestsV1RequestsItemRequestedValuesBitmapDataItemMin)).min(chunkResponseResultHeaderBandwidthRequestsV1RequestsItemRequestedValuesBitmapDataMin).max(chunkResponseResultHeaderBandwidthRequestsV1RequestsItemRequestedValuesBitmapDataMax)
}).describe('Bitmap which describes which values from the predefined list are being requested.\n The nth bit is set to 1 when the nth value from the list is being requested.').describe('Bitmap which describes what values of bandwidth are requested.'),
  "to_shard": zod.number().min(chunkResponseResultHeaderBandwidthRequestsV1RequestsItemToShardMin).describe('Requesting bandwidth to this shard.')
}).describe('`BandwidthRequest` describes the size of receipts that a shard would like to send to another shard.\n When a shard wants to send a lot of receipts to another shard, it needs to create a request and wait\n for a bandwidth grant from the bandwidth scheduler.'))
})
}).describe('A list of shard\'s bandwidth requests.\n Describes how much the shard would like to send to other shards.').nullish(),
  "chunk_hash": zod.string(),
  "congestion_info": zod.object({
  "allowed_shard": zod.number().min(chunkResponseResultHeaderCongestionInfoAllowedShardMin),
  "buffered_receipts_gas": zod.string(),
  "delayed_receipts_gas": zod.string(),
  "receipt_bytes": zod.number().min(chunkResponseResultHeaderCongestionInfoReceiptBytesMin)
}).nullish(),
  "encoded_length": zod.number().min(chunkResponseResultHeaderEncodedLengthMin),
  "encoded_merkle_root": zod.string(),
  "gas_limit": zod.number().min(chunkResponseResultHeaderGasLimitMin),
  "gas_used": zod.number().min(chunkResponseResultHeaderGasUsedMin),
  "height_created": zod.number().min(chunkResponseResultHeaderHeightCreatedMin),
  "height_included": zod.number().min(chunkResponseResultHeaderHeightIncludedMin),
  "outcome_root": zod.string(),
  "outgoing_receipts_root": zod.string(),
  "prev_block_hash": zod.string(),
  "prev_state_root": zod.string(),
  "rent_paid": zod.string().describe('TODO(2271): deprecated.'),
  "shard_id": zod.number().min(chunkResponseResultHeaderShardIdMin).describe('The shard identifier. It may be an arbitrary number - it does not need to be\n a number in the range 0..NUM_SHARDS. The shard ids do not need to be\n sequential or contiguous.\n\n The shard id is wrapped in a new type to prevent the old pattern of using\n indices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\n if fully complete it potentially may be simplified to a regular type alias.'),
  "signature": zod.string(),
  "tx_root": zod.string(),
  "validator_proposals": zod.array(zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string(),
  "stake": zod.string()
})),
  "validator_reward": zod.string().describe('TODO(2271): deprecated.')
}),
  "receipts": zod.array(zod.object({
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "priority": zod.number().min(chunkResponseResultReceiptsItemPriorityMin).optional(),
  "receipt": zod.object({
  "Action": zod.object({
  "actions": zod.array(zod.enum(['CreateAccount']).or(zod.object({
  "DeployContract": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "FunctionCall": zod.object({
  "args": zod.string(),
  "deposit": zod.string(),
  "gas": zod.number().min(chunkResponseResultReceiptsItemReceiptActionActionsItemFunctionCallGasMin),
  "method_name": zod.string()
})
})).or(zod.object({
  "Transfer": zod.object({
  "deposit": zod.string()
})
})).or(zod.object({
  "Stake": zod.object({
  "public_key": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "AddKey": zod.object({
  "access_key": zod.object({
  "nonce": zod.number().min(chunkResponseResultReceiptsItemReceiptActionActionsItemAddKeyAccessKeyNonceMin),
  "permission": zod.enum(['FullAccess']).or(zod.object({
  "FunctionCall": zod.object({
  "allowance": zod.string().nullish(),
  "method_names": zod.array(zod.string()),
  "receiver_id": zod.string()
})
}))
}),
  "public_key": zod.string()
})
})).or(zod.object({
  "DeleteKey": zod.object({
  "public_key": zod.string()
})
})).or(zod.object({
  "DeleteAccount": zod.object({
  "beneficiary_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
})).or(zod.object({
  "Delegate": zod.object({
  "delegate_action": zod.object({
  "actions": zod.array(zod.object({
  "CreateAccount": zod.object({

}).describe('Create account action')
}).describe('Create an (sub)account using a transaction `receiver_id` as an ID for\n a new account ID must pass validation rules described here\n <http://nomicon.io/Primitives/Account.html>.').or(zod.object({
  "DeployContract": zod.object({
  "code": zod.string().describe('WebAssembly binary')
}).describe('Deploy contract action')
}).describe('Sets a Wasm code to a receiver_id')).or(zod.object({
  "FunctionCall": zod.object({
  "args": zod.string(),
  "deposit": zod.string(),
  "gas": zod.number().min(chunkResponseResultReceiptsItemReceiptActionActionsItemDelegateDelegateActionActionsItemFunctionCallGasMin),
  "method_name": zod.string()
})
})).or(zod.object({
  "Transfer": zod.object({
  "deposit": zod.string()
})
})).or(zod.object({
  "Stake": zod.object({
  "public_key": zod.string().describe('Validator key which will be used to sign transactions on behalf of signer_id'),
  "stake": zod.string().describe('Amount of tokens to stake.')
}).describe('An action which stakes signer_id tokens and setup\'s validator public key')
})).or(zod.object({
  "AddKey": zod.object({
  "access_key": zod.object({
  "nonce": zod.number().min(chunkResponseResultReceiptsItemReceiptActionActionsItemDelegateDelegateActionActionsItemAddKeyAccessKeyNonceMin).describe('Nonce for this access key, used for tx nonce generation. When access key is created, nonce\n is set to `(block_height - 1) * 1e6` to avoid tx hash collision on access key re-creation.\n See <https://github.com/near/nearcore/issues/3779> for more details.'),
  "permission": zod.object({
  "FunctionCall": zod.object({
  "allowance": zod.string().nullish().describe('Allowance is a balance limit to use by this access key to pay for function call gas and\n transaction fees. When this access key is used, both account balance and the allowance is\n decreased by the same value.\n `None` means unlimited allowance.\n NOTE: To change or increase the allowance, the old access key needs to be deleted and a new\n access key should be created.'),
  "method_names": zod.array(zod.string()).describe('A list of method names that can be used. The access key only allows transactions with the\n function call of one of the given method names.\n Empty list means any method name can be used.'),
  "receiver_id": zod.string().describe('The access key only allows transactions with the given receiver\'s account id.')
}).describe('Grants limited permission to make transactions with FunctionCallActions\n The permission can limit the allowed balance to be spent on the prepaid gas.\n It also restrict the account ID of the receiver for this function call.\n It also can restrict the method name for the allowed function calls.')
}).or(zod.enum(['FullAccess']).describe('Grants full access to the account.\n NOTE: It\'s used to replace account-level public keys.')).describe('Defines permissions for AccessKey').describe('Defines permissions for this access key.')
}).describe('Access key provides limited access to an account. Each access key belongs to some account and\n is identified by a unique (within the account) public key. One account may have large number of\n access keys. Access keys allow to act on behalf of the account by restricting transactions\n that can be issued.\n `account_id,public_key` is a key in the state').describe('An access key with the permission'),
  "public_key": zod.string().describe('A public key which will be associated with an access_key')
})
})).or(zod.object({
  "DeleteKey": zod.object({
  "public_key": zod.string().describe('A public key associated with the access_key to be deleted.')
})
})).or(zod.object({
  "DeleteAccount": zod.object({
  "beneficiary_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
})).or(zod.object({
  "Delegate": zod.object({
  "delegate_action": zod.any(),
  "signature": zod.string()
})
})).or(zod.object({
  "DeployGlobalContract": zod.object({
  "code": zod.string().describe('WebAssembly binary'),
  "deploy_mode": zod.enum(['CodeHash']).describe('Contract is deployed under its code hash.\n Users will be able reference it by that hash.\n This effectively makes the contract immutable.').or(zod.enum(['AccountId']).describe('Contract is deployed under the owner account id.\n Users will be able reference it by that account id.\n This allows the owner to update the contract for all its users.'))
}).describe('Deploy global contract action')
})).or(zod.object({
  "UseGlobalContract": zod.object({
  "contract_identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
}).describe('Use global contract action')
})).describe('This is Action which mustn\'t contain DelegateAction.\n\n This struct is needed to avoid the recursion when Action/DelegateAction is deserialized.\n\n Important: Don\'t make the inner Action public, this must only be constructed\n through the correct interface that ensures the inner Action is actually not\n a delegate action. That would break an assumption of this type, which we use\n in several places. For example, borsh de-/serialization relies on it. If the\n invariant is broken, we may end up with a `Transaction` or `Receipt` that we\n can serialize but deserializing it back causes a parsing error.')).describe('List of actions to be executed.\n\n With the meta transactions MVP defined in NEP-366, nested\n DelegateActions are not allowed. A separate type is used to enforce it.'),
  "max_block_height": zod.number().min(chunkResponseResultReceiptsItemReceiptActionActionsItemDelegateDelegateActionMaxBlockHeightMin).describe('The maximal height of the block in the blockchain below which the given DelegateAction is valid.'),
  "nonce": zod.number().min(chunkResponseResultReceiptsItemReceiptActionActionsItemDelegateDelegateActionNonceMin).describe('Nonce to ensure that the same delegate action is not sent twice by a\n relayer and should match for given account\'s `public_key`.\n After this action is processed it will increment.'),
  "public_key": zod.string().describe('Public key used to sign this delegated action.'),
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('Receiver of the delegated actions.'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('Signer of the delegated actions')
}).describe('This action allows to execute the inner actions behalf of the defined sender.'),
  "signature": zod.string()
})
})).or(zod.object({
  "DeployGlobalContract": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "DeployGlobalContractByAccountId": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "UseGlobalContract": zod.object({
  "code_hash": zod.string()
})
})).or(zod.object({
  "UseGlobalContractByAccountId": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}))),
  "gas_price": zod.string(),
  "input_data_ids": zod.array(zod.string()),
  "is_promise_yield": zod.boolean().optional(),
  "output_data_receivers": zod.array(zod.object({
  "data_id": zod.string(),
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "signer_public_key": zod.string()
})
}).or(zod.object({
  "Data": zod.object({
  "data": zod.string().nullish(),
  "data_id": zod.string(),
  "is_promise_resume": zod.boolean().optional()
})
})).or(zod.object({
  "GlobalContractDistribution": zod.object({
  "already_delivered_shards": zod.array(zod.number().min(chunkResponseResultReceiptsItemReceiptGlobalContractDistributionAlreadyDeliveredShardsItemMin).describe('The shard identifier. It may be an arbitrary number - it does not need to be\n a number in the range 0..NUM_SHARDS. The shard ids do not need to be\n sequential or contiguous.\n\n The shard id is wrapped in a new type to prevent the old pattern of using\n indices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\n if fully complete it potentially may be simplified to a regular type alias.')),
  "code": zod.string(),
  "id": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})),
  "target_shard": zod.number().min(chunkResponseResultReceiptsItemReceiptGlobalContractDistributionTargetShardMin).describe('The shard identifier. It may be an arbitrary number - it does not need to be\n a number in the range 0..NUM_SHARDS. The shard ids do not need to be\n sequential or contiguous.\n\n The shard id is wrapped in a new type to prevent the old pattern of using\n indices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\n if fully complete it potentially may be simplified to a regular type alias.')
})
})),
  "receipt_id": zod.string(),
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})),
  "transactions": zod.array(zod.object({
  "actions": zod.array(zod.enum(['CreateAccount']).or(zod.object({
  "DeployContract": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "FunctionCall": zod.object({
  "args": zod.string(),
  "deposit": zod.string(),
  "gas": zod.number().min(chunkResponseResultTransactionsItemActionsItemFunctionCallGasMin),
  "method_name": zod.string()
})
})).or(zod.object({
  "Transfer": zod.object({
  "deposit": zod.string()
})
})).or(zod.object({
  "Stake": zod.object({
  "public_key": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "AddKey": zod.object({
  "access_key": zod.object({
  "nonce": zod.number().min(chunkResponseResultTransactionsItemActionsItemAddKeyAccessKeyNonceMin),
  "permission": zod.enum(['FullAccess']).or(zod.object({
  "FunctionCall": zod.object({
  "allowance": zod.string().nullish(),
  "method_names": zod.array(zod.string()),
  "receiver_id": zod.string()
})
}))
}),
  "public_key": zod.string()
})
})).or(zod.object({
  "DeleteKey": zod.object({
  "public_key": zod.string()
})
})).or(zod.object({
  "DeleteAccount": zod.object({
  "beneficiary_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
})).or(zod.object({
  "Delegate": zod.object({
  "delegate_action": zod.object({
  "actions": zod.array(zod.object({
  "CreateAccount": zod.object({

}).describe('Create account action')
}).describe('Create an (sub)account using a transaction `receiver_id` as an ID for\n a new account ID must pass validation rules described here\n <http://nomicon.io/Primitives/Account.html>.').or(zod.object({
  "DeployContract": zod.object({
  "code": zod.string().describe('WebAssembly binary')
}).describe('Deploy contract action')
}).describe('Sets a Wasm code to a receiver_id')).or(zod.object({
  "FunctionCall": zod.object({
  "args": zod.string(),
  "deposit": zod.string(),
  "gas": zod.number().min(chunkResponseResultTransactionsItemActionsItemDelegateDelegateActionActionsItemFunctionCallGasMin),
  "method_name": zod.string()
})
})).or(zod.object({
  "Transfer": zod.object({
  "deposit": zod.string()
})
})).or(zod.object({
  "Stake": zod.object({
  "public_key": zod.string().describe('Validator key which will be used to sign transactions on behalf of signer_id'),
  "stake": zod.string().describe('Amount of tokens to stake.')
}).describe('An action which stakes signer_id tokens and setup\'s validator public key')
})).or(zod.object({
  "AddKey": zod.object({
  "access_key": zod.object({
  "nonce": zod.number().min(chunkResponseResultTransactionsItemActionsItemDelegateDelegateActionActionsItemAddKeyAccessKeyNonceMin).describe('Nonce for this access key, used for tx nonce generation. When access key is created, nonce\n is set to `(block_height - 1) * 1e6` to avoid tx hash collision on access key re-creation.\n See <https://github.com/near/nearcore/issues/3779> for more details.'),
  "permission": zod.object({
  "FunctionCall": zod.object({
  "allowance": zod.string().nullish().describe('Allowance is a balance limit to use by this access key to pay for function call gas and\n transaction fees. When this access key is used, both account balance and the allowance is\n decreased by the same value.\n `None` means unlimited allowance.\n NOTE: To change or increase the allowance, the old access key needs to be deleted and a new\n access key should be created.'),
  "method_names": zod.array(zod.string()).describe('A list of method names that can be used. The access key only allows transactions with the\n function call of one of the given method names.\n Empty list means any method name can be used.'),
  "receiver_id": zod.string().describe('The access key only allows transactions with the given receiver\'s account id.')
}).describe('Grants limited permission to make transactions with FunctionCallActions\n The permission can limit the allowed balance to be spent on the prepaid gas.\n It also restrict the account ID of the receiver for this function call.\n It also can restrict the method name for the allowed function calls.')
}).or(zod.enum(['FullAccess']).describe('Grants full access to the account.\n NOTE: It\'s used to replace account-level public keys.')).describe('Defines permissions for AccessKey').describe('Defines permissions for this access key.')
}).describe('Access key provides limited access to an account. Each access key belongs to some account and\n is identified by a unique (within the account) public key. One account may have large number of\n access keys. Access keys allow to act on behalf of the account by restricting transactions\n that can be issued.\n `account_id,public_key` is a key in the state').describe('An access key with the permission'),
  "public_key": zod.string().describe('A public key which will be associated with an access_key')
})
})).or(zod.object({
  "DeleteKey": zod.object({
  "public_key": zod.string().describe('A public key associated with the access_key to be deleted.')
})
})).or(zod.object({
  "DeleteAccount": zod.object({
  "beneficiary_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
})).or(zod.object({
  "Delegate": zod.object({
  "delegate_action": zod.any(),
  "signature": zod.string()
})
})).or(zod.object({
  "DeployGlobalContract": zod.object({
  "code": zod.string().describe('WebAssembly binary'),
  "deploy_mode": zod.enum(['CodeHash']).describe('Contract is deployed under its code hash.\n Users will be able reference it by that hash.\n This effectively makes the contract immutable.').or(zod.enum(['AccountId']).describe('Contract is deployed under the owner account id.\n Users will be able reference it by that account id.\n This allows the owner to update the contract for all its users.'))
}).describe('Deploy global contract action')
})).or(zod.object({
  "UseGlobalContract": zod.object({
  "contract_identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
}).describe('Use global contract action')
})).describe('This is Action which mustn\'t contain DelegateAction.\n\n This struct is needed to avoid the recursion when Action/DelegateAction is deserialized.\n\n Important: Don\'t make the inner Action public, this must only be constructed\n through the correct interface that ensures the inner Action is actually not\n a delegate action. That would break an assumption of this type, which we use\n in several places. For example, borsh de-/serialization relies on it. If the\n invariant is broken, we may end up with a `Transaction` or `Receipt` that we\n can serialize but deserializing it back causes a parsing error.')).describe('List of actions to be executed.\n\n With the meta transactions MVP defined in NEP-366, nested\n DelegateActions are not allowed. A separate type is used to enforce it.'),
  "max_block_height": zod.number().min(chunkResponseResultTransactionsItemActionsItemDelegateDelegateActionMaxBlockHeightMin).describe('The maximal height of the block in the blockchain below which the given DelegateAction is valid.'),
  "nonce": zod.number().min(chunkResponseResultTransactionsItemActionsItemDelegateDelegateActionNonceMin).describe('Nonce to ensure that the same delegate action is not sent twice by a\n relayer and should match for given account\'s `public_key`.\n After this action is processed it will increment.'),
  "public_key": zod.string().describe('Public key used to sign this delegated action.'),
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('Receiver of the delegated actions.'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('Signer of the delegated actions')
}).describe('This action allows to execute the inner actions behalf of the defined sender.'),
  "signature": zod.string()
})
})).or(zod.object({
  "DeployGlobalContract": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "DeployGlobalContractByAccountId": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "UseGlobalContract": zod.object({
  "code_hash": zod.string()
})
})).or(zod.object({
  "UseGlobalContractByAccountId": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}))),
  "hash": zod.string(),
  "nonce": zod.number().min(chunkResponseResultTransactionsItemNonceMin),
  "priority_fee": zod.number().min(chunkResponseResultTransactionsItemPriorityFeeMin).optional(),
  "public_key": zod.string(),
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "signature": zod.string(),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
})
}).or(zod.object({
  "error": zod.object({
  "cause": zod.object({
  "info": zod.object({
  "method_name": zod.string()
}),
  "name": zod.enum(['METHOD_NOT_FOUND'])
}).or(zod.object({
  "info": zod.object({
  "error_message": zod.string()
}),
  "name": zod.enum(['PARSE_ERROR'])
})),
  "name": zod.enum(['REQUEST_VALIDATION_ERROR'])
}).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['HANDLER_ERROR'])
})).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['INTERNAL_ERROR'])
})).describe('This struct may be returned from JSON RPC server in case of error\n It is expected that this struct has impl From<_> all other RPC errors\n like [RpcBlockError](crate::types::blocks::RpcBlockError)')
}))


export const clientConfigBody = zod.object({
  "id": zod.string(),
  "jsonrpc": zod.string(),
  "method": zod.enum(['client_config']),
  "params": zod.object({

})
})

export const clientConfigResponseResultBlockFetchHorizonMin = 0;
export const clientConfigResponseResultBlockHeaderFetchHorizonMin = 0;
export const clientConfigResponseResultBlockProductionTrackingDelayItemMin = 0;
export const clientConfigResponseResultBlockProductionTrackingDelayMin = 2;

export const clientConfigResponseResultBlockProductionTrackingDelayMax = 2;
export const clientConfigResponseResultCatchupStepPeriodItemMin = 0;
export const clientConfigResponseResultCatchupStepPeriodMin = 2;

export const clientConfigResponseResultCatchupStepPeriodMax = 2;
export const clientConfigResponseResultChunkRequestRetryPeriodItemMin = 0;
export const clientConfigResponseResultChunkRequestRetryPeriodMin = 2;

export const clientConfigResponseResultChunkRequestRetryPeriodMax = 2;
export const clientConfigResponseResultChunkWaitMultMin = 2;

export const clientConfigResponseResultChunkWaitMultMax = 2;
export const clientConfigResponseResultClientBackgroundMigrationThreadsMin = 0;
export const clientConfigResponseResultDoomslugStepPeriodItemMin = 0;
export const clientConfigResponseResultDoomslugStepPeriodMin = 2;

export const clientConfigResponseResultDoomslugStepPeriodMax = 2;
export const clientConfigResponseResultEpochLengthMin = 0;
export const clientConfigResponseResultEpochSyncDisableEpochSyncForBootstrappingDefault = false;export const clientConfigResponseResultEpochSyncEpochSyncHorizonMin = 0;
export const clientConfigResponseResultEpochSyncIgnoreEpochSyncNetworkRequestsDefault = false;export const clientConfigResponseResultGcGcBlocksLimitDefault = 2;
export const clientConfigResponseResultGcGcBlocksLimitMin = 0;
export const clientConfigResponseResultGcGcForkCleanStepDefault = 100;
export const clientConfigResponseResultGcGcForkCleanStepMin = 0;
export const clientConfigResponseResultGcGcNumEpochsToKeepDefault = 5;
export const clientConfigResponseResultGcGcNumEpochsToKeepMin = 0;
export const clientConfigResponseResultGcGcStepPeriodDefault = { nanos: 500000000, secs: 0 };export const clientConfigResponseResultHeaderSyncExpectedHeightPerSecondMin = 0;
export const clientConfigResponseResultHeaderSyncInitialTimeoutItemMin = 0;
export const clientConfigResponseResultHeaderSyncInitialTimeoutMin = 2;

export const clientConfigResponseResultHeaderSyncInitialTimeoutMax = 2;
export const clientConfigResponseResultHeaderSyncProgressTimeoutItemMin = 0;
export const clientConfigResponseResultHeaderSyncProgressTimeoutMin = 2;

export const clientConfigResponseResultHeaderSyncProgressTimeoutMax = 2;
export const clientConfigResponseResultHeaderSyncStallBanTimeoutItemMin = 0;
export const clientConfigResponseResultHeaderSyncStallBanTimeoutMin = 2;

export const clientConfigResponseResultHeaderSyncStallBanTimeoutMax = 2;
export const clientConfigResponseResultLogSummaryPeriodItemMin = 0;
export const clientConfigResponseResultLogSummaryPeriodMin = 2;

export const clientConfigResponseResultLogSummaryPeriodMax = 2;
export const clientConfigResponseResultMaxBlockProductionDelayItemMin = 0;
export const clientConfigResponseResultMaxBlockProductionDelayMin = 2;

export const clientConfigResponseResultMaxBlockProductionDelayMax = 2;
export const clientConfigResponseResultMaxBlockWaitDelayItemMin = 0;
export const clientConfigResponseResultMaxBlockWaitDelayMin = 2;

export const clientConfigResponseResultMaxBlockWaitDelayMax = 2;
export const clientConfigResponseResultMaxGasBurntViewMin = 0;
export const clientConfigResponseResultMinBlockProductionDelayItemMin = 0;
export const clientConfigResponseResultMinBlockProductionDelayMin = 2;

export const clientConfigResponseResultMinBlockProductionDelayMax = 2;
export const clientConfigResponseResultMinNumPeersMin = 0;
export const clientConfigResponseResultNumBlockProducerSeatsMin = 0;
export const clientConfigResponseResultOrphanStateWitnessMaxSizeMin = 0;
export const clientConfigResponseResultOrphanStateWitnessPoolSizeMin = 0;
export const clientConfigResponseResultStateSyncConcurrencyApplyMin = 0;
export const clientConfigResponseResultStateSyncConcurrencyApplyDuringCatchupMin = 0;
export const clientConfigResponseResultStateSyncConcurrencyPeerDownloadsMin = 0;
export const clientConfigResponseResultStateSyncConcurrencyPerShardMin = 0;
export const clientConfigResponseResultStateSyncDumpRestartDumpForShardsItemMin = 0;
export const clientConfigResponseResultStateSyncSyncExternalStorageExternalStorageFallbackThresholdDefault = 3;
export const clientConfigResponseResultStateSyncSyncExternalStorageExternalStorageFallbackThresholdMin = 0;
export const clientConfigResponseResultStateSyncSyncExternalStorageNumConcurrentRequestsDefault = 25;
export const clientConfigResponseResultStateSyncSyncExternalStorageNumConcurrentRequestsMin = 0;
export const clientConfigResponseResultStateSyncSyncExternalStorageNumConcurrentRequestsDuringCatchupDefault = 5;
export const clientConfigResponseResultStateSyncSyncExternalStorageNumConcurrentRequestsDuringCatchupMin = 0;
export const clientConfigResponseResultStateSyncExternalBackoffItemMin = 0;
export const clientConfigResponseResultStateSyncExternalBackoffMin = 2;

export const clientConfigResponseResultStateSyncExternalBackoffMax = 2;
export const clientConfigResponseResultStateSyncExternalTimeoutItemMin = 0;
export const clientConfigResponseResultStateSyncExternalTimeoutMin = 2;

export const clientConfigResponseResultStateSyncExternalTimeoutMax = 2;
export const clientConfigResponseResultStateSyncP2pTimeoutItemMin = 0;
export const clientConfigResponseResultStateSyncP2pTimeoutMin = 2;

export const clientConfigResponseResultStateSyncP2pTimeoutMax = 2;
export const clientConfigResponseResultStateSyncRetryBackoffItemMin = 0;
export const clientConfigResponseResultStateSyncRetryBackoffMin = 2;

export const clientConfigResponseResultStateSyncRetryBackoffMax = 2;
export const clientConfigResponseResultSyncCheckPeriodItemMin = 0;
export const clientConfigResponseResultSyncCheckPeriodMin = 2;

export const clientConfigResponseResultSyncCheckPeriodMax = 2;
export const clientConfigResponseResultSyncHeightThresholdMin = 0;
export const clientConfigResponseResultSyncMaxBlockRequestsMin = 0;
export const clientConfigResponseResultSyncStepPeriodItemMin = 0;
export const clientConfigResponseResultSyncStepPeriodMin = 2;

export const clientConfigResponseResultSyncStepPeriodMax = 2;
export const clientConfigResponseResultTrackedShardsConfigShardsItemShardIdMin = 0;
export const clientConfigResponseResultTrackedShardsConfigShardsItemVersionMin = 0;
export const clientConfigResponseResultTrackedShardsConfigScheduleItemItemMin = 0;
export const clientConfigResponseResultTransactionPoolSizeLimitMin = 0;
export const clientConfigResponseResultTransactionRequestHandlerThreadsMin = 0;
export const clientConfigResponseResultTrieViewerStateSizeLimitMin = 0;
export const clientConfigResponseResultTtlAccountIdRouterItemMin = 0;
export const clientConfigResponseResultTtlAccountIdRouterMin = 2;

export const clientConfigResponseResultTtlAccountIdRouterMax = 2;
export const clientConfigResponseResultTxRoutingHeightHorizonMin = 0;
export const clientConfigResponseResultVersionRustcVersionDefault = "";export const clientConfigResponseResultViewClientThreadsMin = 0;
export const clientConfigResponseResultViewClientThrottlePeriodItemMin = 0;
export const clientConfigResponseResultViewClientThrottlePeriodMin = 2;

export const clientConfigResponseResultViewClientThrottlePeriodMax = 2;


export const clientConfigResponse = zod.object({
  "result": zod.object({
  "archive": zod.boolean().describe('Not clear old data, set `true` for archive nodes.'),
  "block_fetch_horizon": zod.number().min(clientConfigResponseResultBlockFetchHorizonMin).describe('Horizon at which instead of fetching block, fetch full state.'),
  "block_header_fetch_horizon": zod.number().min(clientConfigResponseResultBlockHeaderFetchHorizonMin).describe('Behind this horizon header fetch kicks in.'),
  "block_production_tracking_delay": zod.array(zod.number().min(clientConfigResponseResultBlockProductionTrackingDelayItemMin)).min(clientConfigResponseResultBlockProductionTrackingDelayMin).max(clientConfigResponseResultBlockProductionTrackingDelayMax).describe('Duration to check for producing / skipping block.'),
  "catchup_step_period": zod.array(zod.number().min(clientConfigResponseResultCatchupStepPeriodItemMin)).min(clientConfigResponseResultCatchupStepPeriodMin).max(clientConfigResponseResultCatchupStepPeriodMax).describe('Time between check to perform catchup.'),
  "chain_id": zod.string().describe('Chain id for status.'),
  "chunk_distribution_network": zod.object({
  "enabled": zod.boolean(),
  "uris": zod.object({
  "get": zod.string().describe('URI for pulling chunks from the stream.'),
  "set": zod.string().describe('URI for publishing chunks to the stream.')
}).describe('URIs for the Chunk Distribution Network feature.')
}).describe('Config for the Chunk Distribution Network feature.\n This allows nodes to push and pull chunks from a central stream.\n The two benefits of this approach are: (1) less request/response traffic\n on the peer-to-peer network and (2) lower latency for RPC nodes indexing the chain.').nullish().describe('Optional config for the Chunk Distribution Network feature.\n If set to `None` then this node does not participate in the Chunk Distribution Network.\n Nodes not participating will still function fine, but possibly with higher\n latency due to the need of requesting chunks over the peer-to-peer network.'),
  "chunk_request_retry_period": zod.array(zod.number().min(clientConfigResponseResultChunkRequestRetryPeriodItemMin)).min(clientConfigResponseResultChunkRequestRetryPeriodMin).max(clientConfigResponseResultChunkRequestRetryPeriodMax).describe('Time between checking to re-request chunks.'),
  "chunk_wait_mult": zod.array(zod.number()).min(clientConfigResponseResultChunkWaitMultMin).max(clientConfigResponseResultChunkWaitMultMax).describe('Multiplier for the wait time for all chunks to be received.'),
  "client_background_migration_threads": zod.number().min(clientConfigResponseResultClientBackgroundMigrationThreadsMin).describe('Number of threads to execute background migration work in client.'),
  "doomslug_step_period": zod.array(zod.number().min(clientConfigResponseResultDoomslugStepPeriodItemMin)).min(clientConfigResponseResultDoomslugStepPeriodMin).max(clientConfigResponseResultDoomslugStepPeriodMax).describe('Time between running doomslug timer.'),
  "enable_multiline_logging": zod.boolean(),
  "enable_statistics_export": zod.boolean().describe('Re-export storage layer statistics as prometheus metrics.'),
  "epoch_length": zod.number().min(clientConfigResponseResultEpochLengthMin).describe('Epoch length.'),
  "epoch_sync": zod.object({
  "disable_epoch_sync_for_bootstrapping": zod.boolean().optional().describe('If true, even if the node started from genesis, it will not perform epoch sync.\n There should be no reason to set this flag in production, because on both mainnet\n and testnet it would be infeasible to catch up from genesis without epoch sync.'),
  "epoch_sync_horizon": zod.number().min(clientConfigResponseResultEpochSyncEpochSyncHorizonMin).describe('This serves as two purposes: (1) the node will not epoch sync and instead resort to\n header sync, if the genesis block is within this many blocks from the current block;\n (2) the node will reject an epoch sync proof if the provided proof is for an epoch\n that is more than this many blocks behind the current block.'),
  "ignore_epoch_sync_network_requests": zod.boolean().optional().describe('If true, the node will ignore epoch sync requests from the network. It is strongly\n recommended not to set this flag, because it will prevent other nodes from\n bootstrapping. This flag is only included as a kill-switch and may be removed in a\n future release. Please note that epoch sync requests are heavily rate limited and\n cached, and therefore should not affect the performance of the node or introduce\n any non-negligible increase in network traffic.'),
  "timeout_for_epoch_sync": zod.object({
  "nanos": zod.number(),
  "secs": zod.number()
}).describe('Timeout for epoch sync requests. The node will continue retrying indefinitely even\n if this timeout is exceeded.')
}).describe('Options for epoch sync.'),
  "expected_shutdown": zod.string().describe('Graceful shutdown at expected block height.'),
  "gc": zod.object({
  "gc_blocks_limit": zod.number().min(clientConfigResponseResultGcGcBlocksLimitMin).default(clientConfigResponseResultGcGcBlocksLimitDefault).describe('Maximum number of blocks to garbage collect at every garbage collection\n call.'),
  "gc_fork_clean_step": zod.number().min(clientConfigResponseResultGcGcForkCleanStepMin).default(clientConfigResponseResultGcGcForkCleanStepDefault).describe('Maximum number of height to go through at each garbage collection step\n when cleaning forks during garbage collection.'),
  "gc_num_epochs_to_keep": zod.number().min(clientConfigResponseResultGcGcNumEpochsToKeepMin).default(clientConfigResponseResultGcGcNumEpochsToKeepDefault).describe('Number of epochs for which we keep store data.'),
  "gc_step_period": zod.object({
  "nanos": zod.number(),
  "secs": zod.number()
}).default(clientConfigResponseResultGcGcStepPeriodDefault).describe('How often gc should be run')
}).describe('Configuration for garbage collection.').describe('Garbage collection configuration.'),
  "header_sync_expected_height_per_second": zod.number().min(clientConfigResponseResultHeaderSyncExpectedHeightPerSecondMin).describe('Expected increase of header head height per second during header sync'),
  "header_sync_initial_timeout": zod.array(zod.number().min(clientConfigResponseResultHeaderSyncInitialTimeoutItemMin)).min(clientConfigResponseResultHeaderSyncInitialTimeoutMin).max(clientConfigResponseResultHeaderSyncInitialTimeoutMax).describe('How much time to wait after initial header sync'),
  "header_sync_progress_timeout": zod.array(zod.number().min(clientConfigResponseResultHeaderSyncProgressTimeoutItemMin)).min(clientConfigResponseResultHeaderSyncProgressTimeoutMin).max(clientConfigResponseResultHeaderSyncProgressTimeoutMax).describe('How much time to wait after some progress is made in header sync'),
  "header_sync_stall_ban_timeout": zod.array(zod.number().min(clientConfigResponseResultHeaderSyncStallBanTimeoutItemMin)).min(clientConfigResponseResultHeaderSyncStallBanTimeoutMin).max(clientConfigResponseResultHeaderSyncStallBanTimeoutMax).describe('How much time to wait before banning a peer in header sync if sync is too slow'),
  "log_summary_period": zod.array(zod.number().min(clientConfigResponseResultLogSummaryPeriodItemMin)).min(clientConfigResponseResultLogSummaryPeriodMin).max(clientConfigResponseResultLogSummaryPeriodMax).describe('Period between logging summary information.'),
  "log_summary_style": zod.enum(['plain', 'colored']).describe('Enable coloring of the logs'),
  "max_block_production_delay": zod.array(zod.number().min(clientConfigResponseResultMaxBlockProductionDelayItemMin)).min(clientConfigResponseResultMaxBlockProductionDelayMin).max(clientConfigResponseResultMaxBlockProductionDelayMax).describe('Maximum wait for approvals before producing block.'),
  "max_block_wait_delay": zod.array(zod.number().min(clientConfigResponseResultMaxBlockWaitDelayItemMin)).min(clientConfigResponseResultMaxBlockWaitDelayMin).max(clientConfigResponseResultMaxBlockWaitDelayMax).describe('Maximum duration before skipping given height.'),
  "max_gas_burnt_view": zod.number().min(clientConfigResponseResultMaxGasBurntViewMin).nullish().describe('Max burnt gas per view method.  If present, overrides value stored in\n genesis file.  The value only affects the RPCs without influencing the\n protocol thus changing it per-node doesn‚Äôt affect the blockchain.'),
  "min_block_production_delay": zod.array(zod.number().min(clientConfigResponseResultMinBlockProductionDelayItemMin)).min(clientConfigResponseResultMinBlockProductionDelayMin).max(clientConfigResponseResultMinBlockProductionDelayMax).describe('Minimum duration before producing block.'),
  "min_num_peers": zod.number().min(clientConfigResponseResultMinNumPeersMin).describe('Minimum number of peers to start syncing.'),
  "num_block_producer_seats": zod.number().min(clientConfigResponseResultNumBlockProducerSeatsMin).describe('Number of block producer seats'),
  "orphan_state_witness_max_size": zod.number().min(clientConfigResponseResultOrphanStateWitnessMaxSizeMin).describe('Maximum size of state witnesses in the OrphanStateWitnessPool.\n\n We keep only orphan witnesses which are smaller than this size.\n This limits the maximum memory usage of OrphanStateWitnessPool.'),
  "orphan_state_witness_pool_size": zod.number().min(clientConfigResponseResultOrphanStateWitnessPoolSizeMin).describe('OrphanStateWitnessPool keeps instances of ChunkStateWitness which can\'t be processed\n because the previous block isn\'t available. The witnesses wait in the pool until the\n required block appears. This variable controls how many witnesses can be stored in the pool.'),
  "produce_chunk_add_transactions_time_limit": zod.string().describe('Limit the time of adding transactions to a chunk.\n A node produces a chunk by adding transactions from the transaction pool until\n some limit is reached. This time limit ensures that adding transactions won\'t take\n longer than the specified duration, which helps to produce the chunk quickly.'),
  "produce_empty_blocks": zod.boolean().describe('Produce empty blocks, use `false` for testing.'),
  "resharding_config": zod.string(),
  "rpc_addr": zod.string().nullish().describe('Listening rpc port for status.'),
  "save_invalid_witnesses": zod.boolean().describe('Save observed instances of invalid ChunkStateWitness to the database in DBCol::InvalidChunkStateWitnesses.\n Saving invalid witnesses is useful for analysis and debugging.\n This option can cause extra load on the database and is not recommended for production use.'),
  "save_latest_witnesses": zod.boolean().describe('Save observed instances of ChunkStateWitness to the database in DBCol::LatestChunkStateWitnesses.\n Saving the latest witnesses is useful for analysis and debugging.\n This option can cause extra load on the database and is not recommended for production use.'),
  "save_trie_changes": zod.boolean().describe('save_trie_changes should be set to true iff\n - archive if false - non-archival nodes need trie changes to perform garbage collection\n - archive is true, cold_store is configured and migration to split_storage is finished - node\n working in split storage mode needs trie changes in order to do garbage collection on hot.'),
  "save_tx_outcomes": zod.boolean().describe('Whether to persist transaction outcomes to disk or not.'),
  "skip_sync_wait": zod.boolean().describe('Skip waiting for sync (for testing or single node testnet).'),
  "state_sync": zod.object({
  "concurrency": zod.object({
  "apply": zod.number().min(clientConfigResponseResultStateSyncConcurrencyApplyMin).describe('Maximum number of \"apply parts\" tasks that can be performed in parallel.\n This is a very disk-heavy task and therefore we set this to a low limit,\n or else the rocksdb contention makes the whole server freeze up.'),
  "apply_during_catchup": zod.number().min(clientConfigResponseResultStateSyncConcurrencyApplyDuringCatchupMin).describe('Maximum number of \"apply parts\" tasks that can be performed in parallel\n during catchup. We set this to a very low value to avoid overloading the\n node while it is still performing normal tasks.'),
  "peer_downloads": zod.number().min(clientConfigResponseResultStateSyncConcurrencyPeerDownloadsMin).describe('Maximum number of outstanding requests for decentralized state sync.'),
  "per_shard": zod.number().min(clientConfigResponseResultStateSyncConcurrencyPerShardMin).describe('The maximum parallelism to use per shard. This is mostly for fairness, because\n the actual rate limiting is done by the TaskTrackers, but this is useful for\n balancing the shards a little.')
}).optional(),
  "dump": zod.object({
  "credentials_file": zod.string().nullish().describe('Location of a json file with credentials allowing write access to the bucket.'),
  "iteration_delay": zod.object({
  "nanos": zod.number(),
  "secs": zod.number()
}).nullish().describe('How often to check if a new epoch has started.\n Feel free to set to `None`, defaults are sensible.'),
  "location": zod.object({
  "S3": zod.object({
  "bucket": zod.string().describe('Location of state dumps on S3.'),
  "region": zod.string().describe('Data may only be available in certain locations.')
})
}).or(zod.object({
  "Filesystem": zod.object({
  "root_dir": zod.string()
})
})).or(zod.object({
  "GCS": zod.object({
  "bucket": zod.string()
})
})).describe('Specifies where to write the obtained state parts.'),
  "restart_dump_for_shards": zod.array(zod.number().min(clientConfigResponseResultStateSyncDumpRestartDumpForShardsItemMin).describe('The shard identifier. It may be an arbitrary number - it does not need to be\n a number in the range 0..NUM_SHARDS. The shard ids do not need to be\n sequential or contiguous.\n\n The shard id is wrapped in a new type to prevent the old pattern of using\n indices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\n if fully complete it potentially may be simplified to a regular type alias.')).nullish().describe('Use in case a node that dumps state to the external storage\n gets in trouble.')
}).describe('Configures how to dump state to external storage.').nullish().describe('`none` value disables state dump to external storage.'),
  "sync": zod.enum(['Peers']).describe('Syncs state from the peers without reading anything from external storage.').or(zod.object({
  "ExternalStorage": zod.object({
  "external_storage_fallback_threshold": zod.number().min(clientConfigResponseResultStateSyncSyncExternalStorageExternalStorageFallbackThresholdMin).default(clientConfigResponseResultStateSyncSyncExternalStorageExternalStorageFallbackThresholdDefault).describe('The number of attempts the node will make to obtain a part from peers in\n the network before it fetches from external storage.'),
  "location": zod.object({
  "S3": zod.object({
  "bucket": zod.string().describe('Location of state dumps on S3.'),
  "region": zod.string().describe('Data may only be available in certain locations.')
})
}).or(zod.object({
  "Filesystem": zod.object({
  "root_dir": zod.string()
})
})).or(zod.object({
  "GCS": zod.object({
  "bucket": zod.string()
})
})).describe('Location of state parts.'),
  "num_concurrent_requests": zod.number().min(clientConfigResponseResultStateSyncSyncExternalStorageNumConcurrentRequestsMin).default(clientConfigResponseResultStateSyncSyncExternalStorageNumConcurrentRequestsDefault).describe('When fetching state parts from external storage, throttle fetch requests\n to this many concurrent requests.'),
  "num_concurrent_requests_during_catchup": zod.number().min(clientConfigResponseResultStateSyncSyncExternalStorageNumConcurrentRequestsDuringCatchupMin).default(clientConfigResponseResultStateSyncSyncExternalStorageNumConcurrentRequestsDuringCatchupDefault).describe('During catchup, the node will use a different number of concurrent requests\n to reduce the performance impact of state sync.')
})
}).describe('Expects parts to be available in external storage.\n\n Usually as a fallback after some number of attempts to use peers.')).optional().describe('Configures how to fetch state parts during state sync.')
}).describe('Options for syncing state.'),
  "state_sync_enabled": zod.boolean().describe('Whether to use the State Sync mechanism.\n If disabled, the node will do Block Sync instead of State Sync.'),
  "state_sync_external_backoff": zod.array(zod.number().min(clientConfigResponseResultStateSyncExternalBackoffItemMin)).min(clientConfigResponseResultStateSyncExternalBackoffMin).max(clientConfigResponseResultStateSyncExternalBackoffMax).describe('Additional waiting period after a failed request to external storage'),
  "state_sync_external_timeout": zod.array(zod.number().min(clientConfigResponseResultStateSyncExternalTimeoutItemMin)).min(clientConfigResponseResultStateSyncExternalTimeoutMin).max(clientConfigResponseResultStateSyncExternalTimeoutMax).describe('How long to wait for a response from centralized state sync'),
  "state_sync_p2p_timeout": zod.array(zod.number().min(clientConfigResponseResultStateSyncP2pTimeoutItemMin)).min(clientConfigResponseResultStateSyncP2pTimeoutMin).max(clientConfigResponseResultStateSyncP2pTimeoutMax).describe('How long to wait for a response from p2p state sync'),
  "state_sync_retry_backoff": zod.array(zod.number().min(clientConfigResponseResultStateSyncRetryBackoffItemMin)).min(clientConfigResponseResultStateSyncRetryBackoffMin).max(clientConfigResponseResultStateSyncRetryBackoffMax).describe('How long to wait after a failed state sync request'),
  "sync_check_period": zod.array(zod.number().min(clientConfigResponseResultSyncCheckPeriodItemMin)).min(clientConfigResponseResultSyncCheckPeriodMin).max(clientConfigResponseResultSyncCheckPeriodMax).describe('How often to check that we are not out of sync.'),
  "sync_height_threshold": zod.number().min(clientConfigResponseResultSyncHeightThresholdMin).describe('Sync height threshold: below this difference in height don\'t start syncing.'),
  "sync_max_block_requests": zod.number().min(clientConfigResponseResultSyncMaxBlockRequestsMin).describe('Maximum number of block requests to send to peers to sync'),
  "sync_step_period": zod.array(zod.number().min(clientConfigResponseResultSyncStepPeriodItemMin)).min(clientConfigResponseResultSyncStepPeriodMin).max(clientConfigResponseResultSyncStepPeriodMax).describe('While syncing, how long to check for each step.'),
  "tracked_shards_config": zod.enum(['NoShards']).describe('Tracks no shards (light client).').or(zod.object({
  "Shards": zod.array(zod.object({
  "shard_id": zod.number().min(clientConfigResponseResultTrackedShardsConfigShardsItemShardIdMin),
  "version": zod.number().min(clientConfigResponseResultTrackedShardsConfigShardsItemVersionMin)
}).describe('`ShardUId` is a unique representation for shards from different shard layouts.\n\n Comparing to `ShardId`, which is just an ordinal number ranging from 0 to NUM_SHARDS-1,\n `ShardUId` provides a way to unique identify shards when shard layouts may change across epochs.\n This is important because we store states indexed by shards in our database, so we need a\n way to unique identify shard even when shards change across epochs.\n Another difference between `ShardUId` and `ShardId` is that `ShardUId` should only exist in\n a node\'s internal state while `ShardId` can be exposed to outside APIs and used in protocol\n level information (for example, `ShardChunkHeader` contains `ShardId` instead of `ShardUId`)'))
}).describe('Tracks arbitrary shards.')).or(zod.enum(['AllShards']).describe('Tracks all shards.')).or(zod.object({
  "ShadowValidator": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}).describe('Tracks shards that are assigned to given validator account.')).or(zod.object({
  "Schedule": zod.array(zod.array(zod.number().min(clientConfigResponseResultTrackedShardsConfigScheduleItemItemMin).describe('The shard identifier. It may be an arbitrary number - it does not need to be\n a number in the range 0..NUM_SHARDS. The shard ids do not need to be\n sequential or contiguous.\n\n The shard id is wrapped in a new type to prevent the old pattern of using\n indices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\n if fully complete it potentially may be simplified to a regular type alias.')))
}).describe('Rotate between these sets of tracked shards.\n Used to simulate the behavior of chunk only producers without staking tokens.')).or(zod.object({
  "Accounts": zod.array(zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'))
}).describe('Tracks shards that contain one of the given account.')).describe('Describes the expected behavior of the node regarding shard tracking.\n If the node is an active validator, it will also track the shards it is responsible for as a validator.'),
  "transaction_pool_size_limit": zod.number().min(clientConfigResponseResultTransactionPoolSizeLimitMin).nullish().describe('Limit of the size of per-shard transaction pool measured in bytes. If not set, the size\n will be unbounded.'),
  "transaction_request_handler_threads": zod.number().min(clientConfigResponseResultTransactionRequestHandlerThreadsMin),
  "trie_viewer_state_size_limit": zod.number().min(clientConfigResponseResultTrieViewerStateSizeLimitMin).nullish().describe('Upper bound of the byte size of contract state that is still viewable. None is no limit'),
  "ttl_account_id_router": zod.array(zod.number().min(clientConfigResponseResultTtlAccountIdRouterItemMin)).min(clientConfigResponseResultTtlAccountIdRouterMin).max(clientConfigResponseResultTtlAccountIdRouterMax).describe('Time to persist Accounts Id in the router without removing them.'),
  "tx_routing_height_horizon": zod.number().min(clientConfigResponseResultTxRoutingHeightHorizonMin).describe('If the node is not a chunk producer within that many blocks, then route\n to upcoming chunk producers.'),
  "version": zod.object({
  "build": zod.string(),
  "commit": zod.string(),
  "rustc_version": zod.string().optional(),
  "version": zod.string()
}).describe('Data structure for semver version and github tag or commit.').describe('Version of the binary.'),
  "view_client_threads": zod.number().min(clientConfigResponseResultViewClientThreadsMin).describe('Number of threads for ViewClientActor pool.'),
  "view_client_throttle_period": zod.array(zod.number().min(clientConfigResponseResultViewClientThrottlePeriodItemMin)).min(clientConfigResponseResultViewClientThrottlePeriodMin).max(clientConfigResponseResultViewClientThrottlePeriodMax).describe('Number of seconds between state requests for view client.')
}).describe('ClientConfig where some fields can be updated at runtime.')
}).or(zod.object({
  "error": zod.object({
  "cause": zod.object({
  "info": zod.object({
  "method_name": zod.string()
}),
  "name": zod.enum(['METHOD_NOT_FOUND'])
}).or(zod.object({
  "info": zod.object({
  "error_message": zod.string()
}),
  "name": zod.enum(['PARSE_ERROR'])
})),
  "name": zod.enum(['REQUEST_VALIDATION_ERROR'])
}).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['HANDLER_ERROR'])
})).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['INTERNAL_ERROR'])
})).describe('This struct may be returned from JSON RPC server in case of error\n It is expected that this struct has impl From<_> all other RPC errors\n like [RpcBlockError](crate::types::blocks::RpcBlockError)')
}))


export const gasPriceBodyParamsBlockIdMinTwo = 0;


export const gasPriceBody = zod.object({
  "id": zod.string(),
  "jsonrpc": zod.string(),
  "method": zod.enum(['gas_price']),
  "params": zod.object({
  "block_id": zod.number().min(gasPriceBodyParamsBlockIdMinTwo).or(zod.string()).nullish()
})
})

export const gasPriceResponse = zod.object({
  "result": zod.object({
  "gas_price": zod.string()
})
}).or(zod.object({
  "error": zod.object({
  "cause": zod.object({
  "info": zod.object({
  "method_name": zod.string()
}),
  "name": zod.enum(['METHOD_NOT_FOUND'])
}).or(zod.object({
  "info": zod.object({
  "error_message": zod.string()
}),
  "name": zod.enum(['PARSE_ERROR'])
})),
  "name": zod.enum(['REQUEST_VALIDATION_ERROR'])
}).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['HANDLER_ERROR'])
})).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['INTERNAL_ERROR'])
})).describe('This struct may be returned from JSON RPC server in case of error\n It is expected that this struct has impl From<_> all other RPC errors\n like [RpcBlockError](crate::types::blocks::RpcBlockError)')
}))


export const healthBody = zod.object({
  "id": zod.string(),
  "jsonrpc": zod.string(),
  "method": zod.enum(['health']),
  "params": zod.object({

})
})

export const healthResponse = zod.object({
  "result": zod.object({

}).nullable()
}).or(zod.object({
  "error": zod.object({
  "cause": zod.object({
  "info": zod.object({
  "method_name": zod.string()
}),
  "name": zod.enum(['METHOD_NOT_FOUND'])
}).or(zod.object({
  "info": zod.object({
  "error_message": zod.string()
}),
  "name": zod.enum(['PARSE_ERROR'])
})),
  "name": zod.enum(['REQUEST_VALIDATION_ERROR'])
}).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['HANDLER_ERROR'])
})).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['INTERNAL_ERROR'])
})).describe('This struct may be returned from JSON RPC server in case of error\n It is expected that this struct has impl From<_> all other RPC errors\n like [RpcBlockError](crate::types::blocks::RpcBlockError)')
}))


export const lightClientProofBody = zod.object({
  "id": zod.string(),
  "jsonrpc": zod.string(),
  "method": zod.enum(['light_client_proof']),
  "params": zod.object({
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "transaction_hash": zod.string(),
  "type": zod.enum(['transaction'])
}).or(zod.object({
  "receipt_id": zod.string(),
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "type": zod.enum(['receipt'])
}))
})

export const lightClientProofResponseResultBlockHeaderLiteInnerLiteHeightMin = 0;
export const lightClientProofResponseResultBlockHeaderLiteInnerLiteTimestampMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeGasBurntMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeMetadataVersionMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeMetadataDefault = { version: 1 };export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorIndexMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorInvalidNonceAkNonceMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorInvalidNonceTxNonceMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorNonceTooLargeTxNonceMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededLimitMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededSizeMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorShardCongestedShardIdMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorShardStuckMissedChunksMin = 0;
export const lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorShardStuckShardIdMin = 0;


export const lightClientProofResponse = zod.object({
  "result": zod.object({
  "block_header_lite": zod.object({
  "inner_lite": zod.object({
  "block_merkle_root": zod.string(),
  "epoch_id": zod.string(),
  "height": zod.number().min(lightClientProofResponseResultBlockHeaderLiteInnerLiteHeightMin),
  "next_bp_hash": zod.string(),
  "next_epoch_id": zod.string(),
  "outcome_root": zod.string(),
  "prev_state_root": zod.string(),
  "timestamp": zod.number().min(lightClientProofResponseResultBlockHeaderLiteInnerLiteTimestampMin).describe('Legacy json number. Should not be used.'),
  "timestamp_nanosec": zod.string()
}),
  "inner_rest_hash": zod.string(),
  "prev_block_hash": zod.string()
}),
  "block_proof": zod.array(zod.object({
  "direction": zod.enum(['Left', 'Right']),
  "hash": zod.string()
})),
  "outcome_proof": zod.object({
  "block_hash": zod.string(),
  "id": zod.string(),
  "outcome": zod.object({
  "executor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('The id of the account on which the execution happens. For transaction this is signer_id,\n for receipt this is receiver_id.'),
  "gas_burnt": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeGasBurntMin).describe('The amount of the gas burnt by the given transaction or receipt.'),
  "logs": zod.array(zod.string()).describe('Logs from this transaction or receipt.'),
  "metadata": zod.object({
  "gas_profile": zod.array(zod.object({
  "cost": zod.string(),
  "cost_category": zod.string(),
  "gas_used": zod.string()
})).nullish(),
  "version": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeMetadataVersionMin)
}).default(lightClientProofResponseResultOutcomeProofOutcomeMetadataDefault).describe('Execution metadata, versioned'),
  "receipt_ids": zod.array(zod.string()).describe('Receipt IDs generated by this transaction or receipt.'),
  "status": zod.enum(['Unknown']).describe('The execution is pending or unknown.').or(zod.object({
  "Failure": zod.object({
  "ActionError": zod.object({
  "index": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorIndexMin).nullish().describe('Index of the failed action in the transaction.\n Action index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`'),
  "kind": zod.object({
  "AccountAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage').or(zod.object({
  "AccountDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when TX receiver_id doesn\'t exist (but action is not Action::CreateAccount)')).or(zod.object({
  "CreateAccountOnlyByRegistrar": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "registrar_account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A top-level account ID can only be created by registrar.')).or(zod.object({
  "CreateAccountNotAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A newly created account must be under a namespace of the creator account')).or(zod.object({
  "ActorNoPermission": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "actor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\n or the first TX action is a `CreateAccount` action')).or(zod.object({
  "DeleteKeyDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('Account tries to remove an access key that doesn\'t exist')).or(zod.object({
  "AddKeyAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The public key is already used for an existing access key')).or(zod.object({
  "DeleteAccountStaking": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is staking and can not be deleted')).or(zod.object({
  "LackBalanceForState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which needs balance'),
  "amount": zod.string().describe('Balance required to complete an action.')
})
}).describe('ActionReceipt can\'t be completed, because the remaining balance will not be enough to cover storage.')).or(zod.object({
  "TriesToUnstake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is not yet staked, but tries to unstake')).or(zod.object({
  "TriesToStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "balance": zod.string(),
  "locked": zod.string(),
  "stake": zod.string()
})
}).describe('The account doesn\'t have enough balance to increase the stake.')).or(zod.object({
  "InsufficientStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "minimum_stake": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "FunctionCallError": zod.enum(['WasmUnknownError', '_EVMError']).or(zod.object({
  "CompilationError": zod.object({
  "CodeDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).or(zod.object({
  "PrepareError": zod.enum(['Serialization']).describe('Error happened while serializing the module.').or(zod.enum(['Deserialization']).describe('Error happened while deserializing the module.')).or(zod.enum(['InternalMemoryDeclared']).describe('Internal memory declaration has been found in the module.')).or(zod.enum(['GasInstrumentation']).describe('Gas instrumentation failed.\n\n This most likely indicates the module isn\'t valid.')).or(zod.enum(['StackHeightInstrumentation']).describe('Stack instrumentation failed.\n\n This  most likely indicates the module isn\'t valid.')).or(zod.enum(['Instantiate']).describe('Error happened during instantiation.\n\n This might indicate that `start` function trapped, or module isn\'t\n instantiable and/or un-linkable.')).or(zod.enum(['Memory']).describe('Error creating memory.')).or(zod.enum(['TooManyFunctions']).describe('Contract contains too many functions.')).or(zod.enum(['TooManyLocals']).describe('Contract contains too many locals.')).describe('Error that can occur while preparing or executing Wasm smart-contract.')
})).or(zod.object({
  "WasmerCompileError": zod.object({
  "msg": zod.string()
})
}).describe('This is for defense in depth.\n We expect our runtime-independent preparation code to fully catch all invalid wasms,\n but, if it ever misses something we‚Äôll emit this error'))
}).describe('Wasm compilation error')).or(zod.object({
  "LinkError": zod.object({
  "msg": zod.string()
})
}).describe('Wasm binary env link error\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "MethodResolveError": zod.enum(['MethodEmptyName', 'MethodNotFound', 'MethodInvalidSignature'])
}).describe('Import/export resolve error')).or(zod.object({
  "WasmTrap": zod.enum(['Unreachable']).describe('An `unreachable` opcode was executed.').or(zod.enum(['IncorrectCallIndirectSignature']).describe('Call indirect incorrect signature trap.')).or(zod.enum(['MemoryOutOfBounds']).describe('Memory out of bounds trap.')).or(zod.enum(['CallIndirectOOB']).describe('Call indirect out of bounds trap.')).or(zod.enum(['IllegalArithmetic']).describe('An arithmetic exception, e.g. divided by zero.')).or(zod.enum(['MisalignedAtomicAccess']).describe('Misaligned atomic access trap.')).or(zod.enum(['IndirectCallToNull']).describe('Indirect call to null.')).or(zod.enum(['StackOverflow']).describe('Stack overflow.')).or(zod.enum(['GenericTrap']).describe('Generic trap.')).describe('A kind of a trap happened during execution of a binary')
}).describe('A trap happened during execution of a binary\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "HostError": zod.enum(['BadUTF16']).describe('String encoding is bad UTF-16 sequence').or(zod.enum(['BadUTF8']).describe('String encoding is bad UTF-8 sequence')).or(zod.enum(['GasExceeded']).describe('Exceeded the prepaid gas')).or(zod.enum(['GasLimitExceeded']).describe('Exceeded the maximum amount of gas allowed to burn per contract')).or(zod.enum(['BalanceExceeded']).describe('Exceeded the account balance')).or(zod.enum(['EmptyMethodName']).describe('Tried to call an empty method name')).or(zod.object({
  "GuestPanic": zod.object({
  "panic_msg": zod.string()
})
}).describe('Smart contract panicked')).or(zod.enum(['IntegerOverflow']).describe('IntegerOverflow happened during a contract execution')).or(zod.object({
  "InvalidPromiseIndex": zod.object({
  "promise_idx": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMin)
})
}).describe('`promise_idx` does not correspond to existing promises')).or(zod.enum(['CannotAppendActionToJointPromise']).describe('Actions can only be appended to non-joint promise.')).or(zod.enum(['CannotReturnJointPromise']).describe('Returning joint promise is currently prohibited')).or(zod.object({
  "InvalidPromiseResultIndex": zod.object({
  "result_idx": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMin)
})
}).describe('Accessed invalid promise result index')).or(zod.object({
  "InvalidRegisterId": zod.object({
  "register_id": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMin)
})
}).describe('Accessed invalid register id')).or(zod.object({
  "IteratorWasInvalidated": zod.object({
  "iterator_index": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMin)
})
}).describe('Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie')).or(zod.enum(['MemoryAccessViolation']).describe('Accessed memory outside the bounds')).or(zod.object({
  "InvalidReceiptIndex": zod.object({
  "receipt_index": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMin)
})
}).describe('VM Logic returned an invalid receipt index')).or(zod.object({
  "InvalidIteratorIndex": zod.object({
  "iterator_index": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMin)
})
}).describe('Iterator index `iterator_index` does not exist')).or(zod.enum(['InvalidAccountId']).describe('VM Logic returned an invalid account id')).or(zod.enum(['InvalidMethodName']).describe('VM Logic returned an invalid method name')).or(zod.enum(['InvalidPublicKey']).describe('VM Logic provided an invalid public key')).or(zod.object({
  "ProhibitedInView": zod.object({
  "method_name": zod.string()
})
}).describe('`method_name` is not allowed in view calls')).or(zod.object({
  "NumberOfLogsExceeded": zod.object({
  "limit": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMin)
})
}).describe('The total number of logs will exceed the limit.')).or(zod.object({
  "KeyLengthExceeded": zod.object({
  "length": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMin),
  "limit": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMin)
})
}).describe('The storage key length exceeded the limit.')).or(zod.object({
  "ValueLengthExceeded": zod.object({
  "length": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMin),
  "limit": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMin)
})
}).describe('The storage value length exceeded the limit.')).or(zod.object({
  "TotalLogLengthExceeded": zod.object({
  "length": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMin),
  "limit": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMin)
})
}).describe('The total log length exceeded the limit.')).or(zod.object({
  "NumberPromisesExceeded": zod.object({
  "limit": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMin),
  "number_of_promises": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMin)
})
}).describe('The maximum number of promises within a FunctionCall exceeded the limit.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMin),
  "number_of_input_data_dependencies": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin)
})
}).describe('The maximum number of input data dependencies exceeded the limit.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMin),
  "limit": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMin)
})
}).describe('The returned value length exceeded the limit.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMin),
  "size": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMin)
})
}).describe('The contract size for DeployContract action exceeded the limit.')).or(zod.object({
  "Deprecated": zod.object({
  "method_name": zod.string()
})
}).describe('The host function was deprecated.')).or(zod.object({
  "ECRecoverError": zod.object({
  "msg": zod.string()
})
}).describe('General errors for ECDSA recover.')).or(zod.object({
  "AltBn128InvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to alt_bn128 family of functions (e.g., point which isn\'t\n on the curve).')).or(zod.object({
  "Ed25519VerifyInvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to ed25519 signature verification function (e.g. signature cannot be\n derived from bytes).'))
}).describe('Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "ExecutionError": zod.string()
})).describe('Serializable version of `near-vm-runner::FunctionCallError`.\n\n Must never reorder/remove elements, can only add new variants at the end (but do that very\n carefully). It describes stable serialization format, and only used by serialization logic.')
}).describe('An error occurred during a `FunctionCall` Action, parameter is debug message.')).or(zod.object({
  "NewReceiptValidationError": zod.object({
  "InvalidPredecessorId": zod.object({
  "account_id": zod.string()
})
}).describe('The `predecessor_id` of a Receipt is not valid.').or(zod.object({
  "InvalidReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a Receipt is not valid.')).or(zod.object({
  "InvalidSignerId": zod.object({
  "account_id": zod.string()
})
}).describe('The `signer_id` of an ActionReceipt is not valid.')).or(zod.object({
  "InvalidDataReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a DataReceiver within an ActionReceipt is not valid.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMin),
  "limit": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMin)
})
}).describe('The length of the returned data exceeded the limit in a DataReceipt.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMin),
  "number_of_input_data_dependencies": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin)
})
}).describe('The number of input data dependencies exceeds the limit in an ActionReceipt.')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMin),
  "total_prepaid_gas": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMin),
  "total_number_of_actions": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin),
  "total_number_of_bytes": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMin),
  "size": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMin)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin),
  "limit": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMin)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of an ActionReceipt.')).or(zod.object({
  "ReceiptSizeExceeded": zod.object({
  "limit": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMin),
  "size": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMin)
})
}).describe('Receipt is bigger than the limit.')).describe('Describes the error for validating a receipt.')
}).describe('Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\n receipt validation.')).or(zod.object({
  "OnlyImplicitAccountCreationAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\n See NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\n Also, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\n TODO(#8598): This error is named very poorly. A better name would be\n `OnlyNamedAccountCreationAllowed`.')).or(zod.object({
  "DeleteAccountWithLargeState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Delete account whose state is large is temporarily banned.')).or(zod.enum(['DelegateActionInvalidSignature']).describe('Signature does not match the provided actions and given signer public key.')).or(zod.object({
  "DelegateActionSenderDoesNotMatchTxReceiver": zod.object({
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Receiver of the transaction doesn\'t match Sender of the delegate action')).or(zod.enum(['DelegateActionExpired']).describe('Delegate action has expired. `max_block_height` is less than actual block height.')).or(zod.object({
  "DelegateActionAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('The given public key doesn\'t exist for Sender account')).or(zod.object({
  "DelegateActionInvalidNonce": zod.object({
  "ak_nonce": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMin),
  "delegate_nonce": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMin)
})
}).describe('DelegateAction nonce must be greater sender[public_key].nonce')).or(zod.object({
  "DelegateActionNonceTooLarge": zod.object({
  "delegate_nonce": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMin),
  "upper_bound": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMin)
})
}).describe('DelegateAction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "GlobalContractDoesNotExist": zod.object({
  "identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
})
})).describe('The kind of ActionError happened')
}).describe('An error happened during Action execution')
}).describe('An error happened during Action execution').or(zod.object({
  "InvalidTxError": zod.object({
  "InvalidAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('Happens if a wrong AccessKey used or AccessKey has not enough permissions').or(zod.object({
  "InvalidSignerId": zod.object({
  "signer_id": zod.string()
})
}).describe('TX signer_id is not a valid [`AccountId`]')).or(zod.object({
  "SignerDoesNotExist": zod.object({
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('TX signer_id is not found in a storage')).or(zod.object({
  "InvalidNonce": zod.object({
  "ak_nonce": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorInvalidNonceAkNonceMin),
  "tx_nonce": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorInvalidNonceTxNonceMin)
})
}).describe('Transaction nonce must be strictly greater than `account[access_key].nonce`.')).or(zod.object({
  "NonceTooLarge": zod.object({
  "tx_nonce": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorNonceTooLargeTxNonceMin),
  "upper_bound": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMin)
})
}).describe('Transaction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "InvalidReceiverId": zod.object({
  "receiver_id": zod.string()
})
}).describe('TX receiver_id is not a valid AccountId')).or(zod.enum(['InvalidSignature']).describe('TX signature is not valid')).or(zod.object({
  "NotEnoughBalance": zod.object({
  "balance": zod.string(),
  "cost": zod.string(),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account does not have enough balance to cover TX cost')).or(zod.object({
  "LackBalanceForState": zod.object({
  "amount": zod.string().describe('Required balance to cover the state.'),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which doesn\'t have enough balance to cover storage.')
})
}).describe('Signer account doesn\'t have enough balance after transaction.')).or(zod.enum(['CostOverflow']).describe('An integer overflow occurred during transaction cost estimation.')).or(zod.enum(['InvalidChain']).describe('Transaction parent block hash doesn\'t belong to the current chain')).or(zod.enum(['Expired']).describe('Transaction has expired')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMin),
  "total_prepaid_gas": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMin),
  "total_number_of_actions": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin),
  "total_number_of_bytes": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMin),
  "size": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMin)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin),
  "limit": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMin)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of a Transaction.')).or(zod.object({
  "TransactionSizeExceeded": zod.object({
  "limit": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededLimitMin),
  "size": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededSizeMin)
})
}).describe('The size of serialized transaction exceeded the limit.')).or(zod.enum(['InvalidTransactionVersion']).describe('Transaction version is invalid.')).or(zod.object({
  "StorageError": zod.enum(['StorageInternalError']).describe('Key-value db internal failure').or(zod.object({
  "MissingTrieValue": zod.object({
  "context": zod.enum(['TrieIterator']).describe('Missing trie value when reading from TrieIterator.').or(zod.enum(['TriePrefetchingStorage']).describe('Missing trie value when reading from TriePrefetchingStorage.')).or(zod.enum(['TrieMemoryPartialStorage']).describe('Missing trie value when reading from TrieMemoryPartialStorage.')).or(zod.enum(['TrieStorage']).describe('Missing trie value when reading from TrieStorage.')).describe('Contexts in which `StorageError::MissingTrieValue` error might occur.'),
  "hash": zod.string()
})
}).describe('Requested trie value by its hash which is missing in storage.')).or(zod.enum(['UnexpectedTrieValue']).describe('Found trie node which shouldn\'t be part of state. Raised during\n validation of state sync parts where incorrect node was passed.\n TODO (#8997): consider including hash of trie node.')).or(zod.object({
  "StorageInconsistentState": zod.string()
}).describe('Either invalid state or key-value db is corrupted.\n For PartialStorage it cannot be corrupted.\n Error message is unreliable and for debugging purposes only. It\'s also probably ok to\n panic in every place that produces this error.\n We can check if db is corrupted by verifying everything in the state trie.')).or(zod.object({
  "FlatStorageBlockNotSupported": zod.string()
}).describe('Flat storage error, meaning that it doesn\'t support some block anymore.\n We guarantee that such block cannot become final, thus block processing\n must resume normally.')).or(zod.object({
  "MemTrieLoadingError": zod.string()
}).describe('In-memory trie could not be loaded for some reason.')).describe('Errors which may occur during working with trie storages, storing\n trie values (trie nodes and state values) by their hashes.')
})).or(zod.object({
  "ShardCongested": zod.object({
  "congestion_level": zod.number().describe('A value between 0 (no congestion) and 1 (max congestion).'),
  "shard_id": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorShardCongestedShardIdMin).describe('The congested shard.')
})
}).describe('The receiver shard of the transaction is too congested to accept new\n transactions at the moment.')).or(zod.object({
  "ShardStuck": zod.object({
  "missed_chunks": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorShardStuckMissedChunksMin).describe('The number of blocks since the last included chunk of the shard.'),
  "shard_id": zod.number().min(lightClientProofResponseResultOutcomeProofOutcomeStatusFailureInvalidTxErrorShardStuckShardIdMin).describe('The shard that fails making progress.')
})
}).describe('The receiver shard of the transaction missed several chunks and rejects\n new transaction until it can make progress again.')).describe('An error happened during TX execution')
}).describe('An error happened during Transaction execution')).describe('Error returned in the ExecutionOutcome in case of failure')
}).describe('The execution has failed.')).or(zod.object({
  "SuccessValue": zod.string()
}).describe('The final action succeeded and returned some value or an empty vec encoded in base64.')).or(zod.object({
  "SuccessReceiptId": zod.string()
}).describe('The final action of the receipt returned a promise or the signed transaction was converted\n to a receipt. Contains the receipt_id of the generated receipt.')).describe('Execution status. Contains the result in case of successful execution.'),
  "tokens_burnt": zod.string().describe('The amount of tokens burnt corresponding to the burnt gas amount.\n This value doesn\'t always equal to the `gas_burnt` multiplied by the gas price, because\n the prepaid gas price might be lower than the actual gas price and it creates a deficit.\n `tokens_burnt` also contains the penalty subtracted from refunds, while\n `gas_burnt` only contains the gas that we actually burn for the execution.')
}),
  "proof": zod.array(zod.object({
  "direction": zod.enum(['Left', 'Right']),
  "hash": zod.string()
}))
}),
  "outcome_root_proof": zod.array(zod.object({
  "direction": zod.enum(['Left', 'Right']),
  "hash": zod.string()
}))
})
}).or(zod.object({
  "error": zod.object({
  "cause": zod.object({
  "info": zod.object({
  "method_name": zod.string()
}),
  "name": zod.enum(['METHOD_NOT_FOUND'])
}).or(zod.object({
  "info": zod.object({
  "error_message": zod.string()
}),
  "name": zod.enum(['PARSE_ERROR'])
})),
  "name": zod.enum(['REQUEST_VALIDATION_ERROR'])
}).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['HANDLER_ERROR'])
})).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['INTERNAL_ERROR'])
})).describe('This struct may be returned from JSON RPC server in case of error\n It is expected that this struct has impl From<_> all other RPC errors\n like [RpcBlockError](crate::types::blocks::RpcBlockError)')
}))


export const networkInfoBody = zod.object({
  "id": zod.string(),
  "jsonrpc": zod.string(),
  "method": zod.enum(['network_info']),
  "params": zod.object({

})
})

export const networkInfoResponseResultNumActivePeersMin = 0;
export const networkInfoResponseResultPeerMaxCountMin = 0;
export const networkInfoResponseResultReceivedBytesPerSecMin = 0;
export const networkInfoResponseResultSentBytesPerSecMin = 0;


export const networkInfoResponse = zod.object({
  "result": zod.object({
  "active_peers": zod.array(zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').nullish(),
  "addr": zod.string().nullish(),
  "id": zod.string().describe('Peer id is the public key.')
})),
  "known_producers": zod.array(zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "addr": zod.string().nullish(),
  "peer_id": zod.string().describe('Peer id is the public key.')
})).describe('Accounts of known block and chunk producers from routing table.'),
  "num_active_peers": zod.number().min(networkInfoResponseResultNumActivePeersMin),
  "peer_max_count": zod.number().min(networkInfoResponseResultPeerMaxCountMin),
  "received_bytes_per_sec": zod.number().min(networkInfoResponseResultReceivedBytesPerSecMin),
  "sent_bytes_per_sec": zod.number().min(networkInfoResponseResultSentBytesPerSecMin)
})
}).or(zod.object({
  "error": zod.object({
  "cause": zod.object({
  "info": zod.object({
  "method_name": zod.string()
}),
  "name": zod.enum(['METHOD_NOT_FOUND'])
}).or(zod.object({
  "info": zod.object({
  "error_message": zod.string()
}),
  "name": zod.enum(['PARSE_ERROR'])
})),
  "name": zod.enum(['REQUEST_VALIDATION_ERROR'])
}).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['HANDLER_ERROR'])
})).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['INTERNAL_ERROR'])
})).describe('This struct may be returned from JSON RPC server in case of error\n It is expected that this struct has impl From<_> all other RPC errors\n like [RpcBlockError](crate::types::blocks::RpcBlockError)')
}))


export const nextLightClientBlockBody = zod.object({
  "id": zod.string(),
  "jsonrpc": zod.string(),
  "method": zod.enum(['next_light_client_block']),
  "params": zod.object({
  "last_block_hash": zod.string()
})
})

export const nextLightClientBlockResponseResultInnerLiteHeightMin = 0;
export const nextLightClientBlockResponseResultInnerLiteTimestampMin = 0;


export const nextLightClientBlockResponse = zod.object({
  "result": zod.object({
  "approvals_after_next": zod.array(zod.string().nullable()).optional(),
  "inner_lite": zod.object({
  "block_merkle_root": zod.string(),
  "epoch_id": zod.string(),
  "height": zod.number().min(nextLightClientBlockResponseResultInnerLiteHeightMin),
  "next_bp_hash": zod.string(),
  "next_epoch_id": zod.string(),
  "outcome_root": zod.string(),
  "prev_state_root": zod.string(),
  "timestamp": zod.number().min(nextLightClientBlockResponseResultInnerLiteTimestampMin).describe('Legacy json number. Should not be used.'),
  "timestamp_nanosec": zod.string()
}).optional(),
  "inner_rest_hash": zod.string().optional(),
  "next_block_inner_hash": zod.string().optional(),
  "next_bps": zod.array(zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string(),
  "stake": zod.string()
})).nullish(),
  "prev_block_hash": zod.string().optional()
})
}).or(zod.object({
  "error": zod.object({
  "cause": zod.object({
  "info": zod.object({
  "method_name": zod.string()
}),
  "name": zod.enum(['METHOD_NOT_FOUND'])
}).or(zod.object({
  "info": zod.object({
  "error_message": zod.string()
}),
  "name": zod.enum(['PARSE_ERROR'])
})),
  "name": zod.enum(['REQUEST_VALIDATION_ERROR'])
}).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['HANDLER_ERROR'])
})).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['INTERNAL_ERROR'])
})).describe('This struct may be returned from JSON RPC server in case of error\n It is expected that this struct has impl From<_> all other RPC errors\n like [RpcBlockError](crate::types::blocks::RpcBlockError)')
}))


export const queryBodyParamsBlockIdMinOne = 0;


export const queryBody = zod.object({
  "id": zod.string(),
  "jsonrpc": zod.string(),
  "method": zod.enum(['query']),
  "params": zod.object({
  "block_id": zod.number().min(queryBodyParamsBlockIdMinOne).or(zod.string())
}).or(zod.object({
  "finality": zod.enum(['optimistic', 'near-final', 'final']).describe('Different types of finality.')
})).or(zod.object({
  "sync_checkpoint": zod.enum(['genesis', 'earliest_available'])
})).and(zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "request_type": zod.enum(['view_account'])
}).or(zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "request_type": zod.enum(['view_code'])
})).or(zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "include_proof": zod.boolean().optional(),
  "prefix_base64": zod.string(),
  "request_type": zod.enum(['view_state'])
})).or(zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string(),
  "request_type": zod.enum(['view_access_key'])
})).or(zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "request_type": zod.enum(['view_access_key_list'])
})).or(zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "args_base64": zod.string(),
  "method_name": zod.string(),
  "request_type": zod.enum(['call_function'])
})).or(zod.object({
  "code_hash": zod.string(),
  "request_type": zod.enum(['view_global_contract_code'])
})).or(zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "request_type": zod.enum(['view_global_contract_code_by_account_id'])
})))
})

export const queryResponseResultStoragePaidAtDefault = 0;
export const queryResponseResultStoragePaidAtMin = 0;
export const queryResponseResultStorageUsageMin = 0;
export const queryResponseResultResultItemMin = 0;
export const queryResponseResultNonceMin = 0;
export const queryResponseResultKeysItemAccessKeyNonceMin = 0;


export const queryResponse = zod.object({
  "result": zod.object({
  "amount": zod.string(),
  "code_hash": zod.string(),
  "global_contract_account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').nullish(),
  "global_contract_hash": zod.string().nullish(),
  "locked": zod.string(),
  "storage_paid_at": zod.number().min(queryResponseResultStoragePaidAtMin).optional().describe('TODO(2271): deprecated.'),
  "storage_usage": zod.number().min(queryResponseResultStorageUsageMin)
}).describe('A view of the account').or(zod.object({
  "code_base64": zod.string(),
  "hash": zod.string()
}).describe('A view of the contract code.')).or(zod.object({
  "proof": zod.array(zod.string()).optional(),
  "values": zod.array(zod.object({
  "key": zod.string(),
  "value": zod.string()
}).describe('Item of the state, key and value are serialized in base64 and proof for inclusion of given state item.'))
})).or(zod.object({
  "logs": zod.array(zod.string()),
  "result": zod.array(zod.number().min(queryResponseResultResultItemMin))
})).or(zod.object({
  "nonce": zod.number().min(queryResponseResultNonceMin),
  "permission": zod.enum(['FullAccess']).or(zod.object({
  "FunctionCall": zod.object({
  "allowance": zod.string().nullish(),
  "method_names": zod.array(zod.string()),
  "receiver_id": zod.string()
})
}))
})).or(zod.object({
  "keys": zod.array(zod.object({
  "access_key": zod.object({
  "nonce": zod.number().min(queryResponseResultKeysItemAccessKeyNonceMin),
  "permission": zod.enum(['FullAccess']).or(zod.object({
  "FunctionCall": zod.object({
  "allowance": zod.string().nullish(),
  "method_names": zod.array(zod.string()),
  "receiver_id": zod.string()
})
}))
}),
  "public_key": zod.string()
}))
}))
}).or(zod.object({
  "error": zod.object({
  "cause": zod.object({
  "info": zod.object({
  "method_name": zod.string()
}),
  "name": zod.enum(['METHOD_NOT_FOUND'])
}).or(zod.object({
  "info": zod.object({
  "error_message": zod.string()
}),
  "name": zod.enum(['PARSE_ERROR'])
})),
  "name": zod.enum(['REQUEST_VALIDATION_ERROR'])
}).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['HANDLER_ERROR'])
})).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['INTERNAL_ERROR'])
})).describe('This struct may be returned from JSON RPC server in case of error\n It is expected that this struct has impl From<_> all other RPC errors\n like [RpcBlockError](crate::types::blocks::RpcBlockError)')
}))


export const sendTxBodyParamsWaitUntilDefault = "EXECUTED_OPTIMISTIC";

export const sendTxBody = zod.object({
  "id": zod.string(),
  "jsonrpc": zod.string(),
  "method": zod.enum(['send_tx']),
  "params": zod.object({
  "signed_tx_base64": zod.string(),
  "wait_until": zod.enum(['NONE']).describe('Transaction is waiting to be included into the block').or(zod.enum(['INCLUDED']).describe('Transaction is included into the block. The block may be not finalized yet')).or(zod.enum(['EXECUTED_OPTIMISTIC']).describe('Transaction is included into the block +\n All non-refund transaction receipts finished their execution.\n The corresponding blocks for tx and each receipt may be not finalized yet')).or(zod.enum(['INCLUDED_FINAL']).describe('Transaction is included into finalized block')).or(zod.enum(['EXECUTED']).describe('Transaction is included into finalized block +\n All non-refund transaction receipts finished their execution.\n The corresponding blocks for each receipt may be not finalized yet')).or(zod.enum(['FINAL']).describe('Transaction is included into finalized block +\n Execution of all transaction receipts is finalized, including refund receipts')).default(sendTxBodyParamsWaitUntilDefault)
})
})

export const sendTxResponseResultReceiptsItemPriorityDefault = 0;
export const sendTxResponseResultReceiptsItemPriorityMin = 0;
export const sendTxResponseResultReceiptsItemReceiptActionActionsItemFunctionCallGasMin = 0;
export const sendTxResponseResultReceiptsItemReceiptActionActionsItemAddKeyAccessKeyNonceMin = 0;
export const sendTxResponseResultReceiptsItemReceiptActionActionsItemDelegateDelegateActionActionsItemFunctionCallGasMin = 0;
export const sendTxResponseResultReceiptsItemReceiptActionActionsItemDelegateDelegateActionActionsItemAddKeyAccessKeyNonceMin = 0;
export const sendTxResponseResultReceiptsItemReceiptActionActionsItemDelegateDelegateActionMaxBlockHeightMin = 0;
export const sendTxResponseResultReceiptsItemReceiptActionActionsItemDelegateDelegateActionNonceMin = 0;
export const sendTxResponseResultReceiptsItemReceiptActionIsPromiseYieldDefault = false;export const sendTxResponseResultReceiptsItemReceiptDataDataDefault = null;export const sendTxResponseResultReceiptsItemReceiptDataIsPromiseResumeDefault = false;export const sendTxResponseResultReceiptsItemReceiptGlobalContractDistributionAlreadyDeliveredShardsItemMin = 0;
export const sendTxResponseResultReceiptsItemReceiptGlobalContractDistributionTargetShardMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeGasBurntMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeMetadataVersionMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeMetadataDefault = { version: 1 };export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorIndexMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorInvalidNonceAkNonceMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorInvalidNonceTxNonceMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorNonceTooLargeTxNonceMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededLimitMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededSizeMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardCongestedShardIdMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardStuckMissedChunksMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardStuckShardIdMin = 0;
export const sendTxResponseResultStatusFailureActionErrorIndexMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMin = 0;
export const sendTxResponseResultStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMin = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorInvalidNonceAkNonceMin = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorInvalidNonceTxNonceMin = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorNonceTooLargeTxNonceMin = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMin = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMin = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMin = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMin = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMin = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMin = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorTransactionSizeExceededLimitMin = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorTransactionSizeExceededSizeMin = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorShardCongestedShardIdMin = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorShardStuckMissedChunksMin = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorShardStuckShardIdMin = 0;
export const sendTxResponseResultTransactionActionsItemFunctionCallGasMin = 0;
export const sendTxResponseResultTransactionActionsItemAddKeyAccessKeyNonceMin = 0;
export const sendTxResponseResultTransactionActionsItemDelegateDelegateActionActionsItemFunctionCallGasMin = 0;
export const sendTxResponseResultTransactionActionsItemDelegateDelegateActionActionsItemAddKeyAccessKeyNonceMin = 0;
export const sendTxResponseResultTransactionActionsItemDelegateDelegateActionMaxBlockHeightMin = 0;
export const sendTxResponseResultTransactionActionsItemDelegateDelegateActionNonceMin = 0;
export const sendTxResponseResultTransactionNonceMin = 0;
export const sendTxResponseResultTransactionPriorityFeeDefault = 0;
export const sendTxResponseResultTransactionPriorityFeeMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeGasBurntMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeMetadataVersionMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeMetadataDefault = { version: 1 };export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorIndexMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorInvalidNonceAkNonceMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorInvalidNonceTxNonceMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorNonceTooLargeTxNonceMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededLimitMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededSizeMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardCongestedShardIdMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardStuckMissedChunksMin = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardStuckShardIdMin = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeGasBurntMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeMetadataVersionMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeMetadataDefaultTwo = { version: 1 };export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorIndexMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorInvalidNonceAkNonceMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorInvalidNonceTxNonceMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorNonceTooLargeTxNonceMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededLimitMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededSizeMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardCongestedShardIdMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardStuckMissedChunksMinOne = 0;
export const sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardStuckShardIdMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorIndexMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMinOne = 0;
export const sendTxResponseResultStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMinOne = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorInvalidNonceAkNonceMinOne = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorInvalidNonceTxNonceMinOne = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorNonceTooLargeTxNonceMinOne = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMinOne = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMinOne = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMinOne = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMinOne = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorTransactionSizeExceededLimitMinOne = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorTransactionSizeExceededSizeMinOne = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorShardCongestedShardIdMinOne = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorShardStuckMissedChunksMinOne = 0;
export const sendTxResponseResultStatusFailureInvalidTxErrorShardStuckShardIdMinOne = 0;
export const sendTxResponseResultTransactionActionsItemFunctionCallGasMinOne = 0;
export const sendTxResponseResultTransactionActionsItemAddKeyAccessKeyNonceMinOne = 0;
export const sendTxResponseResultTransactionActionsItemDelegateDelegateActionActionsItemFunctionCallGasMinOne = 0;
export const sendTxResponseResultTransactionActionsItemDelegateDelegateActionActionsItemAddKeyAccessKeyNonceMinOne = 0;
export const sendTxResponseResultTransactionActionsItemDelegateDelegateActionMaxBlockHeightMinOne = 0;
export const sendTxResponseResultTransactionActionsItemDelegateDelegateActionNonceMinOne = 0;
export const sendTxResponseResultTransactionNonceMinOne = 0;
export const sendTxResponseResultTransactionPriorityFeeDefaultOne = 0;
export const sendTxResponseResultTransactionPriorityFeeMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeGasBurntMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeMetadataVersionMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeMetadataDefaultTwo = { version: 1 };export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorIndexMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorInvalidNonceAkNonceMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorInvalidNonceTxNonceMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorNonceTooLargeTxNonceMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededLimitMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededSizeMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardCongestedShardIdMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardStuckMissedChunksMinOne = 0;
export const sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardStuckShardIdMinOne = 0;


export const sendTxResponse = zod.object({
  "result": zod.object({
  "receipts": zod.array(zod.object({
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "priority": zod.number().min(sendTxResponseResultReceiptsItemPriorityMin).optional(),
  "receipt": zod.object({
  "Action": zod.object({
  "actions": zod.array(zod.enum(['CreateAccount']).or(zod.object({
  "DeployContract": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "FunctionCall": zod.object({
  "args": zod.string(),
  "deposit": zod.string(),
  "gas": zod.number().min(sendTxResponseResultReceiptsItemReceiptActionActionsItemFunctionCallGasMin),
  "method_name": zod.string()
})
})).or(zod.object({
  "Transfer": zod.object({
  "deposit": zod.string()
})
})).or(zod.object({
  "Stake": zod.object({
  "public_key": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "AddKey": zod.object({
  "access_key": zod.object({
  "nonce": zod.number().min(sendTxResponseResultReceiptsItemReceiptActionActionsItemAddKeyAccessKeyNonceMin),
  "permission": zod.enum(['FullAccess']).or(zod.object({
  "FunctionCall": zod.object({
  "allowance": zod.string().nullish(),
  "method_names": zod.array(zod.string()),
  "receiver_id": zod.string()
})
}))
}),
  "public_key": zod.string()
})
})).or(zod.object({
  "DeleteKey": zod.object({
  "public_key": zod.string()
})
})).or(zod.object({
  "DeleteAccount": zod.object({
  "beneficiary_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
})).or(zod.object({
  "Delegate": zod.object({
  "delegate_action": zod.object({
  "actions": zod.array(zod.object({
  "CreateAccount": zod.object({

}).describe('Create account action')
}).describe('Create an (sub)account using a transaction `receiver_id` as an ID for\n a new account ID must pass validation rules described here\n <http://nomicon.io/Primitives/Account.html>.').or(zod.object({
  "DeployContract": zod.object({
  "code": zod.string().describe('WebAssembly binary')
}).describe('Deploy contract action')
}).describe('Sets a Wasm code to a receiver_id')).or(zod.object({
  "FunctionCall": zod.object({
  "args": zod.string(),
  "deposit": zod.string(),
  "gas": zod.number().min(sendTxResponseResultReceiptsItemReceiptActionActionsItemDelegateDelegateActionActionsItemFunctionCallGasMin),
  "method_name": zod.string()
})
})).or(zod.object({
  "Transfer": zod.object({
  "deposit": zod.string()
})
})).or(zod.object({
  "Stake": zod.object({
  "public_key": zod.string().describe('Validator key which will be used to sign transactions on behalf of signer_id'),
  "stake": zod.string().describe('Amount of tokens to stake.')
}).describe('An action which stakes signer_id tokens and setup\'s validator public key')
})).or(zod.object({
  "AddKey": zod.object({
  "access_key": zod.object({
  "nonce": zod.number().min(sendTxResponseResultReceiptsItemReceiptActionActionsItemDelegateDelegateActionActionsItemAddKeyAccessKeyNonceMin).describe('Nonce for this access key, used for tx nonce generation. When access key is created, nonce\n is set to `(block_height - 1) * 1e6` to avoid tx hash collision on access key re-creation.\n See <https://github.com/near/nearcore/issues/3779> for more details.'),
  "permission": zod.object({
  "FunctionCall": zod.object({
  "allowance": zod.string().nullish().describe('Allowance is a balance limit to use by this access key to pay for function call gas and\n transaction fees. When this access key is used, both account balance and the allowance is\n decreased by the same value.\n `None` means unlimited allowance.\n NOTE: To change or increase the allowance, the old access key needs to be deleted and a new\n access key should be created.'),
  "method_names": zod.array(zod.string()).describe('A list of method names that can be used. The access key only allows transactions with the\n function call of one of the given method names.\n Empty list means any method name can be used.'),
  "receiver_id": zod.string().describe('The access key only allows transactions with the given receiver\'s account id.')
}).describe('Grants limited permission to make transactions with FunctionCallActions\n The permission can limit the allowed balance to be spent on the prepaid gas.\n It also restrict the account ID of the receiver for this function call.\n It also can restrict the method name for the allowed function calls.')
}).or(zod.enum(['FullAccess']).describe('Grants full access to the account.\n NOTE: It\'s used to replace account-level public keys.')).describe('Defines permissions for AccessKey').describe('Defines permissions for this access key.')
}).describe('Access key provides limited access to an account. Each access key belongs to some account and\n is identified by a unique (within the account) public key. One account may have large number of\n access keys. Access keys allow to act on behalf of the account by restricting transactions\n that can be issued.\n `account_id,public_key` is a key in the state').describe('An access key with the permission'),
  "public_key": zod.string().describe('A public key which will be associated with an access_key')
})
})).or(zod.object({
  "DeleteKey": zod.object({
  "public_key": zod.string().describe('A public key associated with the access_key to be deleted.')
})
})).or(zod.object({
  "DeleteAccount": zod.object({
  "beneficiary_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
})).or(zod.object({
  "Delegate": zod.object({
  "delegate_action": zod.any(),
  "signature": zod.string()
})
})).or(zod.object({
  "DeployGlobalContract": zod.object({
  "code": zod.string().describe('WebAssembly binary'),
  "deploy_mode": zod.enum(['CodeHash']).describe('Contract is deployed under its code hash.\n Users will be able reference it by that hash.\n This effectively makes the contract immutable.').or(zod.enum(['AccountId']).describe('Contract is deployed under the owner account id.\n Users will be able reference it by that account id.\n This allows the owner to update the contract for all its users.'))
}).describe('Deploy global contract action')
})).or(zod.object({
  "UseGlobalContract": zod.object({
  "contract_identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
}).describe('Use global contract action')
})).describe('This is Action which mustn\'t contain DelegateAction.\n\n This struct is needed to avoid the recursion when Action/DelegateAction is deserialized.\n\n Important: Don\'t make the inner Action public, this must only be constructed\n through the correct interface that ensures the inner Action is actually not\n a delegate action. That would break an assumption of this type, which we use\n in several places. For example, borsh de-/serialization relies on it. If the\n invariant is broken, we may end up with a `Transaction` or `Receipt` that we\n can serialize but deserializing it back causes a parsing error.')).describe('List of actions to be executed.\n\n With the meta transactions MVP defined in NEP-366, nested\n DelegateActions are not allowed. A separate type is used to enforce it.'),
  "max_block_height": zod.number().min(sendTxResponseResultReceiptsItemReceiptActionActionsItemDelegateDelegateActionMaxBlockHeightMin).describe('The maximal height of the block in the blockchain below which the given DelegateAction is valid.'),
  "nonce": zod.number().min(sendTxResponseResultReceiptsItemReceiptActionActionsItemDelegateDelegateActionNonceMin).describe('Nonce to ensure that the same delegate action is not sent twice by a\n relayer and should match for given account\'s `public_key`.\n After this action is processed it will increment.'),
  "public_key": zod.string().describe('Public key used to sign this delegated action.'),
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('Receiver of the delegated actions.'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('Signer of the delegated actions')
}).describe('This action allows to execute the inner actions behalf of the defined sender.'),
  "signature": zod.string()
})
})).or(zod.object({
  "DeployGlobalContract": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "DeployGlobalContractByAccountId": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "UseGlobalContract": zod.object({
  "code_hash": zod.string()
})
})).or(zod.object({
  "UseGlobalContractByAccountId": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}))),
  "gas_price": zod.string(),
  "input_data_ids": zod.array(zod.string()),
  "is_promise_yield": zod.boolean().optional(),
  "output_data_receivers": zod.array(zod.object({
  "data_id": zod.string(),
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "signer_public_key": zod.string()
})
}).or(zod.object({
  "Data": zod.object({
  "data": zod.string().nullish(),
  "data_id": zod.string(),
  "is_promise_resume": zod.boolean().optional()
})
})).or(zod.object({
  "GlobalContractDistribution": zod.object({
  "already_delivered_shards": zod.array(zod.number().min(sendTxResponseResultReceiptsItemReceiptGlobalContractDistributionAlreadyDeliveredShardsItemMin).describe('The shard identifier. It may be an arbitrary number - it does not need to be\n a number in the range 0..NUM_SHARDS. The shard ids do not need to be\n sequential or contiguous.\n\n The shard id is wrapped in a new type to prevent the old pattern of using\n indices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\n if fully complete it potentially may be simplified to a regular type alias.')),
  "code": zod.string(),
  "id": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})),
  "target_shard": zod.number().min(sendTxResponseResultReceiptsItemReceiptGlobalContractDistributionTargetShardMin).describe('The shard identifier. It may be an arbitrary number - it does not need to be\n a number in the range 0..NUM_SHARDS. The shard ids do not need to be\n sequential or contiguous.\n\n The shard id is wrapped in a new type to prevent the old pattern of using\n indices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\n if fully complete it potentially may be simplified to a regular type alias.')
})
})),
  "receipt_id": zod.string(),
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})).describe('Receipts generated from the transaction'),
  "receipts_outcome": zod.array(zod.object({
  "block_hash": zod.string(),
  "id": zod.string(),
  "outcome": zod.object({
  "executor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('The id of the account on which the execution happens. For transaction this is signer_id,\n for receipt this is receiver_id.'),
  "gas_burnt": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeGasBurntMin).describe('The amount of the gas burnt by the given transaction or receipt.'),
  "logs": zod.array(zod.string()).describe('Logs from this transaction or receipt.'),
  "metadata": zod.object({
  "gas_profile": zod.array(zod.object({
  "cost": zod.string(),
  "cost_category": zod.string(),
  "gas_used": zod.string()
})).nullish(),
  "version": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeMetadataVersionMin)
}).default(sendTxResponseResultReceiptsOutcomeItemOutcomeMetadataDefault).describe('Execution metadata, versioned'),
  "receipt_ids": zod.array(zod.string()).describe('Receipt IDs generated by this transaction or receipt.'),
  "status": zod.enum(['Unknown']).describe('The execution is pending or unknown.').or(zod.object({
  "Failure": zod.object({
  "ActionError": zod.object({
  "index": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorIndexMin).nullish().describe('Index of the failed action in the transaction.\n Action index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`'),
  "kind": zod.object({
  "AccountAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage').or(zod.object({
  "AccountDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when TX receiver_id doesn\'t exist (but action is not Action::CreateAccount)')).or(zod.object({
  "CreateAccountOnlyByRegistrar": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "registrar_account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A top-level account ID can only be created by registrar.')).or(zod.object({
  "CreateAccountNotAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A newly created account must be under a namespace of the creator account')).or(zod.object({
  "ActorNoPermission": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "actor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\n or the first TX action is a `CreateAccount` action')).or(zod.object({
  "DeleteKeyDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('Account tries to remove an access key that doesn\'t exist')).or(zod.object({
  "AddKeyAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The public key is already used for an existing access key')).or(zod.object({
  "DeleteAccountStaking": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is staking and can not be deleted')).or(zod.object({
  "LackBalanceForState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which needs balance'),
  "amount": zod.string().describe('Balance required to complete an action.')
})
}).describe('ActionReceipt can\'t be completed, because the remaining balance will not be enough to cover storage.')).or(zod.object({
  "TriesToUnstake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is not yet staked, but tries to unstake')).or(zod.object({
  "TriesToStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "balance": zod.string(),
  "locked": zod.string(),
  "stake": zod.string()
})
}).describe('The account doesn\'t have enough balance to increase the stake.')).or(zod.object({
  "InsufficientStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "minimum_stake": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "FunctionCallError": zod.enum(['WasmUnknownError', '_EVMError']).or(zod.object({
  "CompilationError": zod.object({
  "CodeDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).or(zod.object({
  "PrepareError": zod.enum(['Serialization']).describe('Error happened while serializing the module.').or(zod.enum(['Deserialization']).describe('Error happened while deserializing the module.')).or(zod.enum(['InternalMemoryDeclared']).describe('Internal memory declaration has been found in the module.')).or(zod.enum(['GasInstrumentation']).describe('Gas instrumentation failed.\n\n This most likely indicates the module isn\'t valid.')).or(zod.enum(['StackHeightInstrumentation']).describe('Stack instrumentation failed.\n\n This  most likely indicates the module isn\'t valid.')).or(zod.enum(['Instantiate']).describe('Error happened during instantiation.\n\n This might indicate that `start` function trapped, or module isn\'t\n instantiable and/or un-linkable.')).or(zod.enum(['Memory']).describe('Error creating memory.')).or(zod.enum(['TooManyFunctions']).describe('Contract contains too many functions.')).or(zod.enum(['TooManyLocals']).describe('Contract contains too many locals.')).describe('Error that can occur while preparing or executing Wasm smart-contract.')
})).or(zod.object({
  "WasmerCompileError": zod.object({
  "msg": zod.string()
})
}).describe('This is for defense in depth.\n We expect our runtime-independent preparation code to fully catch all invalid wasms,\n but, if it ever misses something we‚Äôll emit this error'))
}).describe('Wasm compilation error')).or(zod.object({
  "LinkError": zod.object({
  "msg": zod.string()
})
}).describe('Wasm binary env link error\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "MethodResolveError": zod.enum(['MethodEmptyName', 'MethodNotFound', 'MethodInvalidSignature'])
}).describe('Import/export resolve error')).or(zod.object({
  "WasmTrap": zod.enum(['Unreachable']).describe('An `unreachable` opcode was executed.').or(zod.enum(['IncorrectCallIndirectSignature']).describe('Call indirect incorrect signature trap.')).or(zod.enum(['MemoryOutOfBounds']).describe('Memory out of bounds trap.')).or(zod.enum(['CallIndirectOOB']).describe('Call indirect out of bounds trap.')).or(zod.enum(['IllegalArithmetic']).describe('An arithmetic exception, e.g. divided by zero.')).or(zod.enum(['MisalignedAtomicAccess']).describe('Misaligned atomic access trap.')).or(zod.enum(['IndirectCallToNull']).describe('Indirect call to null.')).or(zod.enum(['StackOverflow']).describe('Stack overflow.')).or(zod.enum(['GenericTrap']).describe('Generic trap.')).describe('A kind of a trap happened during execution of a binary')
}).describe('A trap happened during execution of a binary\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "HostError": zod.enum(['BadUTF16']).describe('String encoding is bad UTF-16 sequence').or(zod.enum(['BadUTF8']).describe('String encoding is bad UTF-8 sequence')).or(zod.enum(['GasExceeded']).describe('Exceeded the prepaid gas')).or(zod.enum(['GasLimitExceeded']).describe('Exceeded the maximum amount of gas allowed to burn per contract')).or(zod.enum(['BalanceExceeded']).describe('Exceeded the account balance')).or(zod.enum(['EmptyMethodName']).describe('Tried to call an empty method name')).or(zod.object({
  "GuestPanic": zod.object({
  "panic_msg": zod.string()
})
}).describe('Smart contract panicked')).or(zod.enum(['IntegerOverflow']).describe('IntegerOverflow happened during a contract execution')).or(zod.object({
  "InvalidPromiseIndex": zod.object({
  "promise_idx": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMin)
})
}).describe('`promise_idx` does not correspond to existing promises')).or(zod.enum(['CannotAppendActionToJointPromise']).describe('Actions can only be appended to non-joint promise.')).or(zod.enum(['CannotReturnJointPromise']).describe('Returning joint promise is currently prohibited')).or(zod.object({
  "InvalidPromiseResultIndex": zod.object({
  "result_idx": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMin)
})
}).describe('Accessed invalid promise result index')).or(zod.object({
  "InvalidRegisterId": zod.object({
  "register_id": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMin)
})
}).describe('Accessed invalid register id')).or(zod.object({
  "IteratorWasInvalidated": zod.object({
  "iterator_index": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMin)
})
}).describe('Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie')).or(zod.enum(['MemoryAccessViolation']).describe('Accessed memory outside the bounds')).or(zod.object({
  "InvalidReceiptIndex": zod.object({
  "receipt_index": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMin)
})
}).describe('VM Logic returned an invalid receipt index')).or(zod.object({
  "InvalidIteratorIndex": zod.object({
  "iterator_index": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMin)
})
}).describe('Iterator index `iterator_index` does not exist')).or(zod.enum(['InvalidAccountId']).describe('VM Logic returned an invalid account id')).or(zod.enum(['InvalidMethodName']).describe('VM Logic returned an invalid method name')).or(zod.enum(['InvalidPublicKey']).describe('VM Logic provided an invalid public key')).or(zod.object({
  "ProhibitedInView": zod.object({
  "method_name": zod.string()
})
}).describe('`method_name` is not allowed in view calls')).or(zod.object({
  "NumberOfLogsExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMin)
})
}).describe('The total number of logs will exceed the limit.')).or(zod.object({
  "KeyLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMin),
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMin)
})
}).describe('The storage key length exceeded the limit.')).or(zod.object({
  "ValueLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMin),
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMin)
})
}).describe('The storage value length exceeded the limit.')).or(zod.object({
  "TotalLogLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMin),
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMin)
})
}).describe('The total log length exceeded the limit.')).or(zod.object({
  "NumberPromisesExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMin),
  "number_of_promises": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMin)
})
}).describe('The maximum number of promises within a FunctionCall exceeded the limit.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMin),
  "number_of_input_data_dependencies": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin)
})
}).describe('The maximum number of input data dependencies exceeded the limit.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMin),
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMin)
})
}).describe('The returned value length exceeded the limit.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMin),
  "size": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMin)
})
}).describe('The contract size for DeployContract action exceeded the limit.')).or(zod.object({
  "Deprecated": zod.object({
  "method_name": zod.string()
})
}).describe('The host function was deprecated.')).or(zod.object({
  "ECRecoverError": zod.object({
  "msg": zod.string()
})
}).describe('General errors for ECDSA recover.')).or(zod.object({
  "AltBn128InvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to alt_bn128 family of functions (e.g., point which isn\'t\n on the curve).')).or(zod.object({
  "Ed25519VerifyInvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to ed25519 signature verification function (e.g. signature cannot be\n derived from bytes).'))
}).describe('Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "ExecutionError": zod.string()
})).describe('Serializable version of `near-vm-runner::FunctionCallError`.\n\n Must never reorder/remove elements, can only add new variants at the end (but do that very\n carefully). It describes stable serialization format, and only used by serialization logic.')
}).describe('An error occurred during a `FunctionCall` Action, parameter is debug message.')).or(zod.object({
  "NewReceiptValidationError": zod.object({
  "InvalidPredecessorId": zod.object({
  "account_id": zod.string()
})
}).describe('The `predecessor_id` of a Receipt is not valid.').or(zod.object({
  "InvalidReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a Receipt is not valid.')).or(zod.object({
  "InvalidSignerId": zod.object({
  "account_id": zod.string()
})
}).describe('The `signer_id` of an ActionReceipt is not valid.')).or(zod.object({
  "InvalidDataReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a DataReceiver within an ActionReceipt is not valid.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMin),
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMin)
})
}).describe('The length of the returned data exceeded the limit in a DataReceipt.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMin),
  "number_of_input_data_dependencies": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin)
})
}).describe('The number of input data dependencies exceeds the limit in an ActionReceipt.')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMin),
  "total_prepaid_gas": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMin),
  "total_number_of_actions": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin),
  "total_number_of_bytes": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMin),
  "size": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMin)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin),
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMin)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of an ActionReceipt.')).or(zod.object({
  "ReceiptSizeExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMin),
  "size": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMin)
})
}).describe('Receipt is bigger than the limit.')).describe('Describes the error for validating a receipt.')
}).describe('Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\n receipt validation.')).or(zod.object({
  "OnlyImplicitAccountCreationAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\n See NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\n Also, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\n TODO(#8598): This error is named very poorly. A better name would be\n `OnlyNamedAccountCreationAllowed`.')).or(zod.object({
  "DeleteAccountWithLargeState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Delete account whose state is large is temporarily banned.')).or(zod.enum(['DelegateActionInvalidSignature']).describe('Signature does not match the provided actions and given signer public key.')).or(zod.object({
  "DelegateActionSenderDoesNotMatchTxReceiver": zod.object({
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Receiver of the transaction doesn\'t match Sender of the delegate action')).or(zod.enum(['DelegateActionExpired']).describe('Delegate action has expired. `max_block_height` is less than actual block height.')).or(zod.object({
  "DelegateActionAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('The given public key doesn\'t exist for Sender account')).or(zod.object({
  "DelegateActionInvalidNonce": zod.object({
  "ak_nonce": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMin),
  "delegate_nonce": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMin)
})
}).describe('DelegateAction nonce must be greater sender[public_key].nonce')).or(zod.object({
  "DelegateActionNonceTooLarge": zod.object({
  "delegate_nonce": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMin),
  "upper_bound": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMin)
})
}).describe('DelegateAction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "GlobalContractDoesNotExist": zod.object({
  "identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
})
})).describe('The kind of ActionError happened')
}).describe('An error happened during Action execution')
}).describe('An error happened during Action execution').or(zod.object({
  "InvalidTxError": zod.object({
  "InvalidAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('Happens if a wrong AccessKey used or AccessKey has not enough permissions').or(zod.object({
  "InvalidSignerId": zod.object({
  "signer_id": zod.string()
})
}).describe('TX signer_id is not a valid [`AccountId`]')).or(zod.object({
  "SignerDoesNotExist": zod.object({
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('TX signer_id is not found in a storage')).or(zod.object({
  "InvalidNonce": zod.object({
  "ak_nonce": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorInvalidNonceAkNonceMin),
  "tx_nonce": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorInvalidNonceTxNonceMin)
})
}).describe('Transaction nonce must be strictly greater than `account[access_key].nonce`.')).or(zod.object({
  "NonceTooLarge": zod.object({
  "tx_nonce": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorNonceTooLargeTxNonceMin),
  "upper_bound": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMin)
})
}).describe('Transaction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "InvalidReceiverId": zod.object({
  "receiver_id": zod.string()
})
}).describe('TX receiver_id is not a valid AccountId')).or(zod.enum(['InvalidSignature']).describe('TX signature is not valid')).or(zod.object({
  "NotEnoughBalance": zod.object({
  "balance": zod.string(),
  "cost": zod.string(),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account does not have enough balance to cover TX cost')).or(zod.object({
  "LackBalanceForState": zod.object({
  "amount": zod.string().describe('Required balance to cover the state.'),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which doesn\'t have enough balance to cover storage.')
})
}).describe('Signer account doesn\'t have enough balance after transaction.')).or(zod.enum(['CostOverflow']).describe('An integer overflow occurred during transaction cost estimation.')).or(zod.enum(['InvalidChain']).describe('Transaction parent block hash doesn\'t belong to the current chain')).or(zod.enum(['Expired']).describe('Transaction has expired')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMin),
  "total_prepaid_gas": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMin),
  "total_number_of_actions": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin),
  "total_number_of_bytes": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMin),
  "size": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMin)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin),
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMin)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of a Transaction.')).or(zod.object({
  "TransactionSizeExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededLimitMin),
  "size": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededSizeMin)
})
}).describe('The size of serialized transaction exceeded the limit.')).or(zod.enum(['InvalidTransactionVersion']).describe('Transaction version is invalid.')).or(zod.object({
  "StorageError": zod.enum(['StorageInternalError']).describe('Key-value db internal failure').or(zod.object({
  "MissingTrieValue": zod.object({
  "context": zod.enum(['TrieIterator']).describe('Missing trie value when reading from TrieIterator.').or(zod.enum(['TriePrefetchingStorage']).describe('Missing trie value when reading from TriePrefetchingStorage.')).or(zod.enum(['TrieMemoryPartialStorage']).describe('Missing trie value when reading from TrieMemoryPartialStorage.')).or(zod.enum(['TrieStorage']).describe('Missing trie value when reading from TrieStorage.')).describe('Contexts in which `StorageError::MissingTrieValue` error might occur.'),
  "hash": zod.string()
})
}).describe('Requested trie value by its hash which is missing in storage.')).or(zod.enum(['UnexpectedTrieValue']).describe('Found trie node which shouldn\'t be part of state. Raised during\n validation of state sync parts where incorrect node was passed.\n TODO (#8997): consider including hash of trie node.')).or(zod.object({
  "StorageInconsistentState": zod.string()
}).describe('Either invalid state or key-value db is corrupted.\n For PartialStorage it cannot be corrupted.\n Error message is unreliable and for debugging purposes only. It\'s also probably ok to\n panic in every place that produces this error.\n We can check if db is corrupted by verifying everything in the state trie.')).or(zod.object({
  "FlatStorageBlockNotSupported": zod.string()
}).describe('Flat storage error, meaning that it doesn\'t support some block anymore.\n We guarantee that such block cannot become final, thus block processing\n must resume normally.')).or(zod.object({
  "MemTrieLoadingError": zod.string()
}).describe('In-memory trie could not be loaded for some reason.')).describe('Errors which may occur during working with trie storages, storing\n trie values (trie nodes and state values) by their hashes.')
})).or(zod.object({
  "ShardCongested": zod.object({
  "congestion_level": zod.number().describe('A value between 0 (no congestion) and 1 (max congestion).'),
  "shard_id": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardCongestedShardIdMin).describe('The congested shard.')
})
}).describe('The receiver shard of the transaction is too congested to accept new\n transactions at the moment.')).or(zod.object({
  "ShardStuck": zod.object({
  "missed_chunks": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardStuckMissedChunksMin).describe('The number of blocks since the last included chunk of the shard.'),
  "shard_id": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardStuckShardIdMin).describe('The shard that fails making progress.')
})
}).describe('The receiver shard of the transaction missed several chunks and rejects\n new transaction until it can make progress again.')).describe('An error happened during TX execution')
}).describe('An error happened during Transaction execution')).describe('Error returned in the ExecutionOutcome in case of failure')
}).describe('The execution has failed.')).or(zod.object({
  "SuccessValue": zod.string()
}).describe('The final action succeeded and returned some value or an empty vec encoded in base64.')).or(zod.object({
  "SuccessReceiptId": zod.string()
}).describe('The final action of the receipt returned a promise or the signed transaction was converted\n to a receipt. Contains the receipt_id of the generated receipt.')).describe('Execution status. Contains the result in case of successful execution.'),
  "tokens_burnt": zod.string().describe('The amount of tokens burnt corresponding to the burnt gas amount.\n This value doesn\'t always equal to the `gas_burnt` multiplied by the gas price, because\n the prepaid gas price might be lower than the actual gas price and it creates a deficit.\n `tokens_burnt` also contains the penalty subtracted from refunds, while\n `gas_burnt` only contains the gas that we actually burn for the execution.')
}),
  "proof": zod.array(zod.object({
  "direction": zod.enum(['Left', 'Right']),
  "hash": zod.string()
}))
})).describe('The execution outcome of receipts.'),
  "status": zod.enum(['NotStarted']).describe('The execution has not yet started.').or(zod.enum(['Started']).describe('The execution has started and still going.')).or(zod.object({
  "Failure": zod.object({
  "ActionError": zod.object({
  "index": zod.number().min(sendTxResponseResultStatusFailureActionErrorIndexMin).nullish().describe('Index of the failed action in the transaction.\n Action index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`'),
  "kind": zod.object({
  "AccountAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage').or(zod.object({
  "AccountDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when TX receiver_id doesn\'t exist (but action is not Action::CreateAccount)')).or(zod.object({
  "CreateAccountOnlyByRegistrar": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "registrar_account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A top-level account ID can only be created by registrar.')).or(zod.object({
  "CreateAccountNotAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A newly created account must be under a namespace of the creator account')).or(zod.object({
  "ActorNoPermission": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "actor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\n or the first TX action is a `CreateAccount` action')).or(zod.object({
  "DeleteKeyDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('Account tries to remove an access key that doesn\'t exist')).or(zod.object({
  "AddKeyAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The public key is already used for an existing access key')).or(zod.object({
  "DeleteAccountStaking": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is staking and can not be deleted')).or(zod.object({
  "LackBalanceForState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which needs balance'),
  "amount": zod.string().describe('Balance required to complete an action.')
})
}).describe('ActionReceipt can\'t be completed, because the remaining balance will not be enough to cover storage.')).or(zod.object({
  "TriesToUnstake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is not yet staked, but tries to unstake')).or(zod.object({
  "TriesToStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "balance": zod.string(),
  "locked": zod.string(),
  "stake": zod.string()
})
}).describe('The account doesn\'t have enough balance to increase the stake.')).or(zod.object({
  "InsufficientStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "minimum_stake": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "FunctionCallError": zod.enum(['WasmUnknownError', '_EVMError']).or(zod.object({
  "CompilationError": zod.object({
  "CodeDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).or(zod.object({
  "PrepareError": zod.enum(['Serialization']).describe('Error happened while serializing the module.').or(zod.enum(['Deserialization']).describe('Error happened while deserializing the module.')).or(zod.enum(['InternalMemoryDeclared']).describe('Internal memory declaration has been found in the module.')).or(zod.enum(['GasInstrumentation']).describe('Gas instrumentation failed.\n\n This most likely indicates the module isn\'t valid.')).or(zod.enum(['StackHeightInstrumentation']).describe('Stack instrumentation failed.\n\n This  most likely indicates the module isn\'t valid.')).or(zod.enum(['Instantiate']).describe('Error happened during instantiation.\n\n This might indicate that `start` function trapped, or module isn\'t\n instantiable and/or un-linkable.')).or(zod.enum(['Memory']).describe('Error creating memory.')).or(zod.enum(['TooManyFunctions']).describe('Contract contains too many functions.')).or(zod.enum(['TooManyLocals']).describe('Contract contains too many locals.')).describe('Error that can occur while preparing or executing Wasm smart-contract.')
})).or(zod.object({
  "WasmerCompileError": zod.object({
  "msg": zod.string()
})
}).describe('This is for defense in depth.\n We expect our runtime-independent preparation code to fully catch all invalid wasms,\n but, if it ever misses something we‚Äôll emit this error'))
}).describe('Wasm compilation error')).or(zod.object({
  "LinkError": zod.object({
  "msg": zod.string()
})
}).describe('Wasm binary env link error\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "MethodResolveError": zod.enum(['MethodEmptyName', 'MethodNotFound', 'MethodInvalidSignature'])
}).describe('Import/export resolve error')).or(zod.object({
  "WasmTrap": zod.enum(['Unreachable']).describe('An `unreachable` opcode was executed.').or(zod.enum(['IncorrectCallIndirectSignature']).describe('Call indirect incorrect signature trap.')).or(zod.enum(['MemoryOutOfBounds']).describe('Memory out of bounds trap.')).or(zod.enum(['CallIndirectOOB']).describe('Call indirect out of bounds trap.')).or(zod.enum(['IllegalArithmetic']).describe('An arithmetic exception, e.g. divided by zero.')).or(zod.enum(['MisalignedAtomicAccess']).describe('Misaligned atomic access trap.')).or(zod.enum(['IndirectCallToNull']).describe('Indirect call to null.')).or(zod.enum(['StackOverflow']).describe('Stack overflow.')).or(zod.enum(['GenericTrap']).describe('Generic trap.')).describe('A kind of a trap happened during execution of a binary')
}).describe('A trap happened during execution of a binary\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "HostError": zod.enum(['BadUTF16']).describe('String encoding is bad UTF-16 sequence').or(zod.enum(['BadUTF8']).describe('String encoding is bad UTF-8 sequence')).or(zod.enum(['GasExceeded']).describe('Exceeded the prepaid gas')).or(zod.enum(['GasLimitExceeded']).describe('Exceeded the maximum amount of gas allowed to burn per contract')).or(zod.enum(['BalanceExceeded']).describe('Exceeded the account balance')).or(zod.enum(['EmptyMethodName']).describe('Tried to call an empty method name')).or(zod.object({
  "GuestPanic": zod.object({
  "panic_msg": zod.string()
})
}).describe('Smart contract panicked')).or(zod.enum(['IntegerOverflow']).describe('IntegerOverflow happened during a contract execution')).or(zod.object({
  "InvalidPromiseIndex": zod.object({
  "promise_idx": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMin)
})
}).describe('`promise_idx` does not correspond to existing promises')).or(zod.enum(['CannotAppendActionToJointPromise']).describe('Actions can only be appended to non-joint promise.')).or(zod.enum(['CannotReturnJointPromise']).describe('Returning joint promise is currently prohibited')).or(zod.object({
  "InvalidPromiseResultIndex": zod.object({
  "result_idx": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMin)
})
}).describe('Accessed invalid promise result index')).or(zod.object({
  "InvalidRegisterId": zod.object({
  "register_id": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMin)
})
}).describe('Accessed invalid register id')).or(zod.object({
  "IteratorWasInvalidated": zod.object({
  "iterator_index": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMin)
})
}).describe('Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie')).or(zod.enum(['MemoryAccessViolation']).describe('Accessed memory outside the bounds')).or(zod.object({
  "InvalidReceiptIndex": zod.object({
  "receipt_index": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMin)
})
}).describe('VM Logic returned an invalid receipt index')).or(zod.object({
  "InvalidIteratorIndex": zod.object({
  "iterator_index": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMin)
})
}).describe('Iterator index `iterator_index` does not exist')).or(zod.enum(['InvalidAccountId']).describe('VM Logic returned an invalid account id')).or(zod.enum(['InvalidMethodName']).describe('VM Logic returned an invalid method name')).or(zod.enum(['InvalidPublicKey']).describe('VM Logic provided an invalid public key')).or(zod.object({
  "ProhibitedInView": zod.object({
  "method_name": zod.string()
})
}).describe('`method_name` is not allowed in view calls')).or(zod.object({
  "NumberOfLogsExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMin)
})
}).describe('The total number of logs will exceed the limit.')).or(zod.object({
  "KeyLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMin),
  "limit": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMin)
})
}).describe('The storage key length exceeded the limit.')).or(zod.object({
  "ValueLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMin),
  "limit": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMin)
})
}).describe('The storage value length exceeded the limit.')).or(zod.object({
  "TotalLogLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMin),
  "limit": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMin)
})
}).describe('The total log length exceeded the limit.')).or(zod.object({
  "NumberPromisesExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMin),
  "number_of_promises": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMin)
})
}).describe('The maximum number of promises within a FunctionCall exceeded the limit.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMin),
  "number_of_input_data_dependencies": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin)
})
}).describe('The maximum number of input data dependencies exceeded the limit.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMin),
  "limit": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMin)
})
}).describe('The returned value length exceeded the limit.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMin),
  "size": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMin)
})
}).describe('The contract size for DeployContract action exceeded the limit.')).or(zod.object({
  "Deprecated": zod.object({
  "method_name": zod.string()
})
}).describe('The host function was deprecated.')).or(zod.object({
  "ECRecoverError": zod.object({
  "msg": zod.string()
})
}).describe('General errors for ECDSA recover.')).or(zod.object({
  "AltBn128InvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to alt_bn128 family of functions (e.g., point which isn\'t\n on the curve).')).or(zod.object({
  "Ed25519VerifyInvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to ed25519 signature verification function (e.g. signature cannot be\n derived from bytes).'))
}).describe('Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "ExecutionError": zod.string()
})).describe('Serializable version of `near-vm-runner::FunctionCallError`.\n\n Must never reorder/remove elements, can only add new variants at the end (but do that very\n carefully). It describes stable serialization format, and only used by serialization logic.')
}).describe('An error occurred during a `FunctionCall` Action, parameter is debug message.')).or(zod.object({
  "NewReceiptValidationError": zod.object({
  "InvalidPredecessorId": zod.object({
  "account_id": zod.string()
})
}).describe('The `predecessor_id` of a Receipt is not valid.').or(zod.object({
  "InvalidReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a Receipt is not valid.')).or(zod.object({
  "InvalidSignerId": zod.object({
  "account_id": zod.string()
})
}).describe('The `signer_id` of an ActionReceipt is not valid.')).or(zod.object({
  "InvalidDataReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a DataReceiver within an ActionReceipt is not valid.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMin),
  "limit": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMin)
})
}).describe('The length of the returned data exceeded the limit in a DataReceipt.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMin),
  "number_of_input_data_dependencies": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin)
})
}).describe('The number of input data dependencies exceeds the limit in an ActionReceipt.')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMin),
  "total_prepaid_gas": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMin),
  "total_number_of_actions": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin),
  "total_number_of_bytes": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMin),
  "size": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMin)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin),
  "limit": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMin)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of an ActionReceipt.')).or(zod.object({
  "ReceiptSizeExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMin),
  "size": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMin)
})
}).describe('Receipt is bigger than the limit.')).describe('Describes the error for validating a receipt.')
}).describe('Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\n receipt validation.')).or(zod.object({
  "OnlyImplicitAccountCreationAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\n See NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\n Also, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\n TODO(#8598): This error is named very poorly. A better name would be\n `OnlyNamedAccountCreationAllowed`.')).or(zod.object({
  "DeleteAccountWithLargeState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Delete account whose state is large is temporarily banned.')).or(zod.enum(['DelegateActionInvalidSignature']).describe('Signature does not match the provided actions and given signer public key.')).or(zod.object({
  "DelegateActionSenderDoesNotMatchTxReceiver": zod.object({
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Receiver of the transaction doesn\'t match Sender of the delegate action')).or(zod.enum(['DelegateActionExpired']).describe('Delegate action has expired. `max_block_height` is less than actual block height.')).or(zod.object({
  "DelegateActionAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('The given public key doesn\'t exist for Sender account')).or(zod.object({
  "DelegateActionInvalidNonce": zod.object({
  "ak_nonce": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMin),
  "delegate_nonce": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMin)
})
}).describe('DelegateAction nonce must be greater sender[public_key].nonce')).or(zod.object({
  "DelegateActionNonceTooLarge": zod.object({
  "delegate_nonce": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMin),
  "upper_bound": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMin)
})
}).describe('DelegateAction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "GlobalContractDoesNotExist": zod.object({
  "identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
})
})).describe('The kind of ActionError happened')
}).describe('An error happened during Action execution')
}).describe('An error happened during Action execution').or(zod.object({
  "InvalidTxError": zod.object({
  "InvalidAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('Happens if a wrong AccessKey used or AccessKey has not enough permissions').or(zod.object({
  "InvalidSignerId": zod.object({
  "signer_id": zod.string()
})
}).describe('TX signer_id is not a valid [`AccountId`]')).or(zod.object({
  "SignerDoesNotExist": zod.object({
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('TX signer_id is not found in a storage')).or(zod.object({
  "InvalidNonce": zod.object({
  "ak_nonce": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorInvalidNonceAkNonceMin),
  "tx_nonce": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorInvalidNonceTxNonceMin)
})
}).describe('Transaction nonce must be strictly greater than `account[access_key].nonce`.')).or(zod.object({
  "NonceTooLarge": zod.object({
  "tx_nonce": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorNonceTooLargeTxNonceMin),
  "upper_bound": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMin)
})
}).describe('Transaction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "InvalidReceiverId": zod.object({
  "receiver_id": zod.string()
})
}).describe('TX receiver_id is not a valid AccountId')).or(zod.enum(['InvalidSignature']).describe('TX signature is not valid')).or(zod.object({
  "NotEnoughBalance": zod.object({
  "balance": zod.string(),
  "cost": zod.string(),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account does not have enough balance to cover TX cost')).or(zod.object({
  "LackBalanceForState": zod.object({
  "amount": zod.string().describe('Required balance to cover the state.'),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which doesn\'t have enough balance to cover storage.')
})
}).describe('Signer account doesn\'t have enough balance after transaction.')).or(zod.enum(['CostOverflow']).describe('An integer overflow occurred during transaction cost estimation.')).or(zod.enum(['InvalidChain']).describe('Transaction parent block hash doesn\'t belong to the current chain')).or(zod.enum(['Expired']).describe('Transaction has expired')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMin),
  "total_prepaid_gas": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMin),
  "total_number_of_actions": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin),
  "total_number_of_bytes": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMin),
  "size": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMin)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin),
  "limit": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMin)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of a Transaction.')).or(zod.object({
  "TransactionSizeExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorTransactionSizeExceededLimitMin),
  "size": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorTransactionSizeExceededSizeMin)
})
}).describe('The size of serialized transaction exceeded the limit.')).or(zod.enum(['InvalidTransactionVersion']).describe('Transaction version is invalid.')).or(zod.object({
  "StorageError": zod.enum(['StorageInternalError']).describe('Key-value db internal failure').or(zod.object({
  "MissingTrieValue": zod.object({
  "context": zod.enum(['TrieIterator']).describe('Missing trie value when reading from TrieIterator.').or(zod.enum(['TriePrefetchingStorage']).describe('Missing trie value when reading from TriePrefetchingStorage.')).or(zod.enum(['TrieMemoryPartialStorage']).describe('Missing trie value when reading from TrieMemoryPartialStorage.')).or(zod.enum(['TrieStorage']).describe('Missing trie value when reading from TrieStorage.')).describe('Contexts in which `StorageError::MissingTrieValue` error might occur.'),
  "hash": zod.string()
})
}).describe('Requested trie value by its hash which is missing in storage.')).or(zod.enum(['UnexpectedTrieValue']).describe('Found trie node which shouldn\'t be part of state. Raised during\n validation of state sync parts where incorrect node was passed.\n TODO (#8997): consider including hash of trie node.')).or(zod.object({
  "StorageInconsistentState": zod.string()
}).describe('Either invalid state or key-value db is corrupted.\n For PartialStorage it cannot be corrupted.\n Error message is unreliable and for debugging purposes only. It\'s also probably ok to\n panic in every place that produces this error.\n We can check if db is corrupted by verifying everything in the state trie.')).or(zod.object({
  "FlatStorageBlockNotSupported": zod.string()
}).describe('Flat storage error, meaning that it doesn\'t support some block anymore.\n We guarantee that such block cannot become final, thus block processing\n must resume normally.')).or(zod.object({
  "MemTrieLoadingError": zod.string()
}).describe('In-memory trie could not be loaded for some reason.')).describe('Errors which may occur during working with trie storages, storing\n trie values (trie nodes and state values) by their hashes.')
})).or(zod.object({
  "ShardCongested": zod.object({
  "congestion_level": zod.number().describe('A value between 0 (no congestion) and 1 (max congestion).'),
  "shard_id": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorShardCongestedShardIdMin).describe('The congested shard.')
})
}).describe('The receiver shard of the transaction is too congested to accept new\n transactions at the moment.')).or(zod.object({
  "ShardStuck": zod.object({
  "missed_chunks": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorShardStuckMissedChunksMin).describe('The number of blocks since the last included chunk of the shard.'),
  "shard_id": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorShardStuckShardIdMin).describe('The shard that fails making progress.')
})
}).describe('The receiver shard of the transaction missed several chunks and rejects\n new transaction until it can make progress again.')).describe('An error happened during TX execution')
}).describe('An error happened during Transaction execution')).describe('Error returned in the ExecutionOutcome in case of failure')
}).describe('The execution has failed with the given error.')).or(zod.object({
  "SuccessValue": zod.string()
}).describe('The execution has succeeded and returned some value or an empty vec encoded in base64.')).describe('Execution status defined by chain.rs:get_final_transaction_result\n FinalExecutionStatus::NotStarted - the tx is not converted to the receipt yet\n FinalExecutionStatus::Started - we have at least 1 receipt, but the first leaf receipt_id (using dfs) hasn\'t finished the execution\n FinalExecutionStatus::Failure - the result of the first leaf receipt_id\n FinalExecutionStatus::SuccessValue - the result of the first leaf receipt_id'),
  "transaction": zod.object({
  "actions": zod.array(zod.enum(['CreateAccount']).or(zod.object({
  "DeployContract": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "FunctionCall": zod.object({
  "args": zod.string(),
  "deposit": zod.string(),
  "gas": zod.number().min(sendTxResponseResultTransactionActionsItemFunctionCallGasMin),
  "method_name": zod.string()
})
})).or(zod.object({
  "Transfer": zod.object({
  "deposit": zod.string()
})
})).or(zod.object({
  "Stake": zod.object({
  "public_key": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "AddKey": zod.object({
  "access_key": zod.object({
  "nonce": zod.number().min(sendTxResponseResultTransactionActionsItemAddKeyAccessKeyNonceMin),
  "permission": zod.enum(['FullAccess']).or(zod.object({
  "FunctionCall": zod.object({
  "allowance": zod.string().nullish(),
  "method_names": zod.array(zod.string()),
  "receiver_id": zod.string()
})
}))
}),
  "public_key": zod.string()
})
})).or(zod.object({
  "DeleteKey": zod.object({
  "public_key": zod.string()
})
})).or(zod.object({
  "DeleteAccount": zod.object({
  "beneficiary_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
})).or(zod.object({
  "Delegate": zod.object({
  "delegate_action": zod.object({
  "actions": zod.array(zod.object({
  "CreateAccount": zod.object({

}).describe('Create account action')
}).describe('Create an (sub)account using a transaction `receiver_id` as an ID for\n a new account ID must pass validation rules described here\n <http://nomicon.io/Primitives/Account.html>.').or(zod.object({
  "DeployContract": zod.object({
  "code": zod.string().describe('WebAssembly binary')
}).describe('Deploy contract action')
}).describe('Sets a Wasm code to a receiver_id')).or(zod.object({
  "FunctionCall": zod.object({
  "args": zod.string(),
  "deposit": zod.string(),
  "gas": zod.number().min(sendTxResponseResultTransactionActionsItemDelegateDelegateActionActionsItemFunctionCallGasMin),
  "method_name": zod.string()
})
})).or(zod.object({
  "Transfer": zod.object({
  "deposit": zod.string()
})
})).or(zod.object({
  "Stake": zod.object({
  "public_key": zod.string().describe('Validator key which will be used to sign transactions on behalf of signer_id'),
  "stake": zod.string().describe('Amount of tokens to stake.')
}).describe('An action which stakes signer_id tokens and setup\'s validator public key')
})).or(zod.object({
  "AddKey": zod.object({
  "access_key": zod.object({
  "nonce": zod.number().min(sendTxResponseResultTransactionActionsItemDelegateDelegateActionActionsItemAddKeyAccessKeyNonceMin).describe('Nonce for this access key, used for tx nonce generation. When access key is created, nonce\n is set to `(block_height - 1) * 1e6` to avoid tx hash collision on access key re-creation.\n See <https://github.com/near/nearcore/issues/3779> for more details.'),
  "permission": zod.object({
  "FunctionCall": zod.object({
  "allowance": zod.string().nullish().describe('Allowance is a balance limit to use by this access key to pay for function call gas and\n transaction fees. When this access key is used, both account balance and the allowance is\n decreased by the same value.\n `None` means unlimited allowance.\n NOTE: To change or increase the allowance, the old access key needs to be deleted and a new\n access key should be created.'),
  "method_names": zod.array(zod.string()).describe('A list of method names that can be used. The access key only allows transactions with the\n function call of one of the given method names.\n Empty list means any method name can be used.'),
  "receiver_id": zod.string().describe('The access key only allows transactions with the given receiver\'s account id.')
}).describe('Grants limited permission to make transactions with FunctionCallActions\n The permission can limit the allowed balance to be spent on the prepaid gas.\n It also restrict the account ID of the receiver for this function call.\n It also can restrict the method name for the allowed function calls.')
}).or(zod.enum(['FullAccess']).describe('Grants full access to the account.\n NOTE: It\'s used to replace account-level public keys.')).describe('Defines permissions for AccessKey').describe('Defines permissions for this access key.')
}).describe('Access key provides limited access to an account. Each access key belongs to some account and\n is identified by a unique (within the account) public key. One account may have large number of\n access keys. Access keys allow to act on behalf of the account by restricting transactions\n that can be issued.\n `account_id,public_key` is a key in the state').describe('An access key with the permission'),
  "public_key": zod.string().describe('A public key which will be associated with an access_key')
})
})).or(zod.object({
  "DeleteKey": zod.object({
  "public_key": zod.string().describe('A public key associated with the access_key to be deleted.')
})
})).or(zod.object({
  "DeleteAccount": zod.object({
  "beneficiary_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
})).or(zod.object({
  "Delegate": zod.object({
  "delegate_action": zod.any(),
  "signature": zod.string()
})
})).or(zod.object({
  "DeployGlobalContract": zod.object({
  "code": zod.string().describe('WebAssembly binary'),
  "deploy_mode": zod.enum(['CodeHash']).describe('Contract is deployed under its code hash.\n Users will be able reference it by that hash.\n This effectively makes the contract immutable.').or(zod.enum(['AccountId']).describe('Contract is deployed under the owner account id.\n Users will be able reference it by that account id.\n This allows the owner to update the contract for all its users.'))
}).describe('Deploy global contract action')
})).or(zod.object({
  "UseGlobalContract": zod.object({
  "contract_identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
}).describe('Use global contract action')
})).describe('This is Action which mustn\'t contain DelegateAction.\n\n This struct is needed to avoid the recursion when Action/DelegateAction is deserialized.\n\n Important: Don\'t make the inner Action public, this must only be constructed\n through the correct interface that ensures the inner Action is actually not\n a delegate action. That would break an assumption of this type, which we use\n in several places. For example, borsh de-/serialization relies on it. If the\n invariant is broken, we may end up with a `Transaction` or `Receipt` that we\n can serialize but deserializing it back causes a parsing error.')).describe('List of actions to be executed.\n\n With the meta transactions MVP defined in NEP-366, nested\n DelegateActions are not allowed. A separate type is used to enforce it.'),
  "max_block_height": zod.number().min(sendTxResponseResultTransactionActionsItemDelegateDelegateActionMaxBlockHeightMin).describe('The maximal height of the block in the blockchain below which the given DelegateAction is valid.'),
  "nonce": zod.number().min(sendTxResponseResultTransactionActionsItemDelegateDelegateActionNonceMin).describe('Nonce to ensure that the same delegate action is not sent twice by a\n relayer and should match for given account\'s `public_key`.\n After this action is processed it will increment.'),
  "public_key": zod.string().describe('Public key used to sign this delegated action.'),
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('Receiver of the delegated actions.'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('Signer of the delegated actions')
}).describe('This action allows to execute the inner actions behalf of the defined sender.'),
  "signature": zod.string()
})
})).or(zod.object({
  "DeployGlobalContract": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "DeployGlobalContractByAccountId": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "UseGlobalContract": zod.object({
  "code_hash": zod.string()
})
})).or(zod.object({
  "UseGlobalContractByAccountId": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}))),
  "hash": zod.string(),
  "nonce": zod.number().min(sendTxResponseResultTransactionNonceMin),
  "priority_fee": zod.number().min(sendTxResponseResultTransactionPriorityFeeMin).optional(),
  "public_key": zod.string(),
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "signature": zod.string(),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}).describe('Signed Transaction'),
  "transaction_outcome": zod.object({
  "block_hash": zod.string(),
  "id": zod.string(),
  "outcome": zod.object({
  "executor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('The id of the account on which the execution happens. For transaction this is signer_id,\n for receipt this is receiver_id.'),
  "gas_burnt": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeGasBurntMin).describe('The amount of the gas burnt by the given transaction or receipt.'),
  "logs": zod.array(zod.string()).describe('Logs from this transaction or receipt.'),
  "metadata": zod.object({
  "gas_profile": zod.array(zod.object({
  "cost": zod.string(),
  "cost_category": zod.string(),
  "gas_used": zod.string()
})).nullish(),
  "version": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeMetadataVersionMin)
}).default(sendTxResponseResultTransactionOutcomeOutcomeMetadataDefault).describe('Execution metadata, versioned'),
  "receipt_ids": zod.array(zod.string()).describe('Receipt IDs generated by this transaction or receipt.'),
  "status": zod.enum(['Unknown']).describe('The execution is pending or unknown.').or(zod.object({
  "Failure": zod.object({
  "ActionError": zod.object({
  "index": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorIndexMin).nullish().describe('Index of the failed action in the transaction.\n Action index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`'),
  "kind": zod.object({
  "AccountAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage').or(zod.object({
  "AccountDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when TX receiver_id doesn\'t exist (but action is not Action::CreateAccount)')).or(zod.object({
  "CreateAccountOnlyByRegistrar": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "registrar_account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A top-level account ID can only be created by registrar.')).or(zod.object({
  "CreateAccountNotAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A newly created account must be under a namespace of the creator account')).or(zod.object({
  "ActorNoPermission": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "actor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\n or the first TX action is a `CreateAccount` action')).or(zod.object({
  "DeleteKeyDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('Account tries to remove an access key that doesn\'t exist')).or(zod.object({
  "AddKeyAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The public key is already used for an existing access key')).or(zod.object({
  "DeleteAccountStaking": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is staking and can not be deleted')).or(zod.object({
  "LackBalanceForState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which needs balance'),
  "amount": zod.string().describe('Balance required to complete an action.')
})
}).describe('ActionReceipt can\'t be completed, because the remaining balance will not be enough to cover storage.')).or(zod.object({
  "TriesToUnstake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is not yet staked, but tries to unstake')).or(zod.object({
  "TriesToStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "balance": zod.string(),
  "locked": zod.string(),
  "stake": zod.string()
})
}).describe('The account doesn\'t have enough balance to increase the stake.')).or(zod.object({
  "InsufficientStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "minimum_stake": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "FunctionCallError": zod.enum(['WasmUnknownError', '_EVMError']).or(zod.object({
  "CompilationError": zod.object({
  "CodeDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).or(zod.object({
  "PrepareError": zod.enum(['Serialization']).describe('Error happened while serializing the module.').or(zod.enum(['Deserialization']).describe('Error happened while deserializing the module.')).or(zod.enum(['InternalMemoryDeclared']).describe('Internal memory declaration has been found in the module.')).or(zod.enum(['GasInstrumentation']).describe('Gas instrumentation failed.\n\n This most likely indicates the module isn\'t valid.')).or(zod.enum(['StackHeightInstrumentation']).describe('Stack instrumentation failed.\n\n This  most likely indicates the module isn\'t valid.')).or(zod.enum(['Instantiate']).describe('Error happened during instantiation.\n\n This might indicate that `start` function trapped, or module isn\'t\n instantiable and/or un-linkable.')).or(zod.enum(['Memory']).describe('Error creating memory.')).or(zod.enum(['TooManyFunctions']).describe('Contract contains too many functions.')).or(zod.enum(['TooManyLocals']).describe('Contract contains too many locals.')).describe('Error that can occur while preparing or executing Wasm smart-contract.')
})).or(zod.object({
  "WasmerCompileError": zod.object({
  "msg": zod.string()
})
}).describe('This is for defense in depth.\n We expect our runtime-independent preparation code to fully catch all invalid wasms,\n but, if it ever misses something we‚Äôll emit this error'))
}).describe('Wasm compilation error')).or(zod.object({
  "LinkError": zod.object({
  "msg": zod.string()
})
}).describe('Wasm binary env link error\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "MethodResolveError": zod.enum(['MethodEmptyName', 'MethodNotFound', 'MethodInvalidSignature'])
}).describe('Import/export resolve error')).or(zod.object({
  "WasmTrap": zod.enum(['Unreachable']).describe('An `unreachable` opcode was executed.').or(zod.enum(['IncorrectCallIndirectSignature']).describe('Call indirect incorrect signature trap.')).or(zod.enum(['MemoryOutOfBounds']).describe('Memory out of bounds trap.')).or(zod.enum(['CallIndirectOOB']).describe('Call indirect out of bounds trap.')).or(zod.enum(['IllegalArithmetic']).describe('An arithmetic exception, e.g. divided by zero.')).or(zod.enum(['MisalignedAtomicAccess']).describe('Misaligned atomic access trap.')).or(zod.enum(['IndirectCallToNull']).describe('Indirect call to null.')).or(zod.enum(['StackOverflow']).describe('Stack overflow.')).or(zod.enum(['GenericTrap']).describe('Generic trap.')).describe('A kind of a trap happened during execution of a binary')
}).describe('A trap happened during execution of a binary\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "HostError": zod.enum(['BadUTF16']).describe('String encoding is bad UTF-16 sequence').or(zod.enum(['BadUTF8']).describe('String encoding is bad UTF-8 sequence')).or(zod.enum(['GasExceeded']).describe('Exceeded the prepaid gas')).or(zod.enum(['GasLimitExceeded']).describe('Exceeded the maximum amount of gas allowed to burn per contract')).or(zod.enum(['BalanceExceeded']).describe('Exceeded the account balance')).or(zod.enum(['EmptyMethodName']).describe('Tried to call an empty method name')).or(zod.object({
  "GuestPanic": zod.object({
  "panic_msg": zod.string()
})
}).describe('Smart contract panicked')).or(zod.enum(['IntegerOverflow']).describe('IntegerOverflow happened during a contract execution')).or(zod.object({
  "InvalidPromiseIndex": zod.object({
  "promise_idx": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMin)
})
}).describe('`promise_idx` does not correspond to existing promises')).or(zod.enum(['CannotAppendActionToJointPromise']).describe('Actions can only be appended to non-joint promise.')).or(zod.enum(['CannotReturnJointPromise']).describe('Returning joint promise is currently prohibited')).or(zod.object({
  "InvalidPromiseResultIndex": zod.object({
  "result_idx": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMin)
})
}).describe('Accessed invalid promise result index')).or(zod.object({
  "InvalidRegisterId": zod.object({
  "register_id": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMin)
})
}).describe('Accessed invalid register id')).or(zod.object({
  "IteratorWasInvalidated": zod.object({
  "iterator_index": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMin)
})
}).describe('Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie')).or(zod.enum(['MemoryAccessViolation']).describe('Accessed memory outside the bounds')).or(zod.object({
  "InvalidReceiptIndex": zod.object({
  "receipt_index": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMin)
})
}).describe('VM Logic returned an invalid receipt index')).or(zod.object({
  "InvalidIteratorIndex": zod.object({
  "iterator_index": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMin)
})
}).describe('Iterator index `iterator_index` does not exist')).or(zod.enum(['InvalidAccountId']).describe('VM Logic returned an invalid account id')).or(zod.enum(['InvalidMethodName']).describe('VM Logic returned an invalid method name')).or(zod.enum(['InvalidPublicKey']).describe('VM Logic provided an invalid public key')).or(zod.object({
  "ProhibitedInView": zod.object({
  "method_name": zod.string()
})
}).describe('`method_name` is not allowed in view calls')).or(zod.object({
  "NumberOfLogsExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMin)
})
}).describe('The total number of logs will exceed the limit.')).or(zod.object({
  "KeyLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMin),
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMin)
})
}).describe('The storage key length exceeded the limit.')).or(zod.object({
  "ValueLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMin),
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMin)
})
}).describe('The storage value length exceeded the limit.')).or(zod.object({
  "TotalLogLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMin),
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMin)
})
}).describe('The total log length exceeded the limit.')).or(zod.object({
  "NumberPromisesExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMin),
  "number_of_promises": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMin)
})
}).describe('The maximum number of promises within a FunctionCall exceeded the limit.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMin),
  "number_of_input_data_dependencies": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin)
})
}).describe('The maximum number of input data dependencies exceeded the limit.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMin),
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMin)
})
}).describe('The returned value length exceeded the limit.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMin),
  "size": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMin)
})
}).describe('The contract size for DeployContract action exceeded the limit.')).or(zod.object({
  "Deprecated": zod.object({
  "method_name": zod.string()
})
}).describe('The host function was deprecated.')).or(zod.object({
  "ECRecoverError": zod.object({
  "msg": zod.string()
})
}).describe('General errors for ECDSA recover.')).or(zod.object({
  "AltBn128InvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to alt_bn128 family of functions (e.g., point which isn\'t\n on the curve).')).or(zod.object({
  "Ed25519VerifyInvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to ed25519 signature verification function (e.g. signature cannot be\n derived from bytes).'))
}).describe('Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "ExecutionError": zod.string()
})).describe('Serializable version of `near-vm-runner::FunctionCallError`.\n\n Must never reorder/remove elements, can only add new variants at the end (but do that very\n carefully). It describes stable serialization format, and only used by serialization logic.')
}).describe('An error occurred during a `FunctionCall` Action, parameter is debug message.')).or(zod.object({
  "NewReceiptValidationError": zod.object({
  "InvalidPredecessorId": zod.object({
  "account_id": zod.string()
})
}).describe('The `predecessor_id` of a Receipt is not valid.').or(zod.object({
  "InvalidReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a Receipt is not valid.')).or(zod.object({
  "InvalidSignerId": zod.object({
  "account_id": zod.string()
})
}).describe('The `signer_id` of an ActionReceipt is not valid.')).or(zod.object({
  "InvalidDataReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a DataReceiver within an ActionReceipt is not valid.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMin),
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMin)
})
}).describe('The length of the returned data exceeded the limit in a DataReceipt.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMin),
  "number_of_input_data_dependencies": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin)
})
}).describe('The number of input data dependencies exceeds the limit in an ActionReceipt.')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMin),
  "total_prepaid_gas": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMin),
  "total_number_of_actions": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin),
  "total_number_of_bytes": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMin),
  "size": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMin)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin),
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMin)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of an ActionReceipt.')).or(zod.object({
  "ReceiptSizeExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMin),
  "size": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMin)
})
}).describe('Receipt is bigger than the limit.')).describe('Describes the error for validating a receipt.')
}).describe('Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\n receipt validation.')).or(zod.object({
  "OnlyImplicitAccountCreationAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\n See NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\n Also, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\n TODO(#8598): This error is named very poorly. A better name would be\n `OnlyNamedAccountCreationAllowed`.')).or(zod.object({
  "DeleteAccountWithLargeState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Delete account whose state is large is temporarily banned.')).or(zod.enum(['DelegateActionInvalidSignature']).describe('Signature does not match the provided actions and given signer public key.')).or(zod.object({
  "DelegateActionSenderDoesNotMatchTxReceiver": zod.object({
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Receiver of the transaction doesn\'t match Sender of the delegate action')).or(zod.enum(['DelegateActionExpired']).describe('Delegate action has expired. `max_block_height` is less than actual block height.')).or(zod.object({
  "DelegateActionAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('The given public key doesn\'t exist for Sender account')).or(zod.object({
  "DelegateActionInvalidNonce": zod.object({
  "ak_nonce": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMin),
  "delegate_nonce": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMin)
})
}).describe('DelegateAction nonce must be greater sender[public_key].nonce')).or(zod.object({
  "DelegateActionNonceTooLarge": zod.object({
  "delegate_nonce": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMin),
  "upper_bound": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMin)
})
}).describe('DelegateAction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "GlobalContractDoesNotExist": zod.object({
  "identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
})
})).describe('The kind of ActionError happened')
}).describe('An error happened during Action execution')
}).describe('An error happened during Action execution').or(zod.object({
  "InvalidTxError": zod.object({
  "InvalidAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('Happens if a wrong AccessKey used or AccessKey has not enough permissions').or(zod.object({
  "InvalidSignerId": zod.object({
  "signer_id": zod.string()
})
}).describe('TX signer_id is not a valid [`AccountId`]')).or(zod.object({
  "SignerDoesNotExist": zod.object({
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('TX signer_id is not found in a storage')).or(zod.object({
  "InvalidNonce": zod.object({
  "ak_nonce": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorInvalidNonceAkNonceMin),
  "tx_nonce": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorInvalidNonceTxNonceMin)
})
}).describe('Transaction nonce must be strictly greater than `account[access_key].nonce`.')).or(zod.object({
  "NonceTooLarge": zod.object({
  "tx_nonce": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorNonceTooLargeTxNonceMin),
  "upper_bound": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMin)
})
}).describe('Transaction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "InvalidReceiverId": zod.object({
  "receiver_id": zod.string()
})
}).describe('TX receiver_id is not a valid AccountId')).or(zod.enum(['InvalidSignature']).describe('TX signature is not valid')).or(zod.object({
  "NotEnoughBalance": zod.object({
  "balance": zod.string(),
  "cost": zod.string(),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account does not have enough balance to cover TX cost')).or(zod.object({
  "LackBalanceForState": zod.object({
  "amount": zod.string().describe('Required balance to cover the state.'),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which doesn\'t have enough balance to cover storage.')
})
}).describe('Signer account doesn\'t have enough balance after transaction.')).or(zod.enum(['CostOverflow']).describe('An integer overflow occurred during transaction cost estimation.')).or(zod.enum(['InvalidChain']).describe('Transaction parent block hash doesn\'t belong to the current chain')).or(zod.enum(['Expired']).describe('Transaction has expired')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMin),
  "total_prepaid_gas": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMin),
  "total_number_of_actions": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin),
  "total_number_of_bytes": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMin),
  "size": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMin)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin),
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMin)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of a Transaction.')).or(zod.object({
  "TransactionSizeExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededLimitMin),
  "size": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededSizeMin)
})
}).describe('The size of serialized transaction exceeded the limit.')).or(zod.enum(['InvalidTransactionVersion']).describe('Transaction version is invalid.')).or(zod.object({
  "StorageError": zod.enum(['StorageInternalError']).describe('Key-value db internal failure').or(zod.object({
  "MissingTrieValue": zod.object({
  "context": zod.enum(['TrieIterator']).describe('Missing trie value when reading from TrieIterator.').or(zod.enum(['TriePrefetchingStorage']).describe('Missing trie value when reading from TriePrefetchingStorage.')).or(zod.enum(['TrieMemoryPartialStorage']).describe('Missing trie value when reading from TrieMemoryPartialStorage.')).or(zod.enum(['TrieStorage']).describe('Missing trie value when reading from TrieStorage.')).describe('Contexts in which `StorageError::MissingTrieValue` error might occur.'),
  "hash": zod.string()
})
}).describe('Requested trie value by its hash which is missing in storage.')).or(zod.enum(['UnexpectedTrieValue']).describe('Found trie node which shouldn\'t be part of state. Raised during\n validation of state sync parts where incorrect node was passed.\n TODO (#8997): consider including hash of trie node.')).or(zod.object({
  "StorageInconsistentState": zod.string()
}).describe('Either invalid state or key-value db is corrupted.\n For PartialStorage it cannot be corrupted.\n Error message is unreliable and for debugging purposes only. It\'s also probably ok to\n panic in every place that produces this error.\n We can check if db is corrupted by verifying everything in the state trie.')).or(zod.object({
  "FlatStorageBlockNotSupported": zod.string()
}).describe('Flat storage error, meaning that it doesn\'t support some block anymore.\n We guarantee that such block cannot become final, thus block processing\n must resume normally.')).or(zod.object({
  "MemTrieLoadingError": zod.string()
}).describe('In-memory trie could not be loaded for some reason.')).describe('Errors which may occur during working with trie storages, storing\n trie values (trie nodes and state values) by their hashes.')
})).or(zod.object({
  "ShardCongested": zod.object({
  "congestion_level": zod.number().describe('A value between 0 (no congestion) and 1 (max congestion).'),
  "shard_id": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardCongestedShardIdMin).describe('The congested shard.')
})
}).describe('The receiver shard of the transaction is too congested to accept new\n transactions at the moment.')).or(zod.object({
  "ShardStuck": zod.object({
  "missed_chunks": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardStuckMissedChunksMin).describe('The number of blocks since the last included chunk of the shard.'),
  "shard_id": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardStuckShardIdMin).describe('The shard that fails making progress.')
})
}).describe('The receiver shard of the transaction missed several chunks and rejects\n new transaction until it can make progress again.')).describe('An error happened during TX execution')
}).describe('An error happened during Transaction execution')).describe('Error returned in the ExecutionOutcome in case of failure')
}).describe('The execution has failed.')).or(zod.object({
  "SuccessValue": zod.string()
}).describe('The final action succeeded and returned some value or an empty vec encoded in base64.')).or(zod.object({
  "SuccessReceiptId": zod.string()
}).describe('The final action of the receipt returned a promise or the signed transaction was converted\n to a receipt. Contains the receipt_id of the generated receipt.')).describe('Execution status. Contains the result in case of successful execution.'),
  "tokens_burnt": zod.string().describe('The amount of tokens burnt corresponding to the burnt gas amount.\n This value doesn\'t always equal to the `gas_burnt` multiplied by the gas price, because\n the prepaid gas price might be lower than the actual gas price and it creates a deficit.\n `tokens_burnt` also contains the penalty subtracted from refunds, while\n `gas_burnt` only contains the gas that we actually burn for the execution.')
}),
  "proof": zod.array(zod.object({
  "direction": zod.enum(['Left', 'Right']),
  "hash": zod.string()
}))
}).describe('The execution outcome of the signed transaction.')
}).describe('Final execution outcome of the transaction and all of subsequent the receipts. Also includes\n the generated receipt.').or(zod.object({
  "receipts_outcome": zod.array(zod.object({
  "block_hash": zod.string(),
  "id": zod.string(),
  "outcome": zod.object({
  "executor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('The id of the account on which the execution happens. For transaction this is signer_id,\n for receipt this is receiver_id.'),
  "gas_burnt": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeGasBurntMinOne).describe('The amount of the gas burnt by the given transaction or receipt.'),
  "logs": zod.array(zod.string()).describe('Logs from this transaction or receipt.'),
  "metadata": zod.object({
  "gas_profile": zod.array(zod.object({
  "cost": zod.string(),
  "cost_category": zod.string(),
  "gas_used": zod.string()
})).nullish(),
  "version": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeMetadataVersionMinOne)
}).default(sendTxResponseResultReceiptsOutcomeItemOutcomeMetadataDefaultTwo).describe('Execution metadata, versioned'),
  "receipt_ids": zod.array(zod.string()).describe('Receipt IDs generated by this transaction or receipt.'),
  "status": zod.enum(['Unknown']).describe('The execution is pending or unknown.').or(zod.object({
  "Failure": zod.object({
  "ActionError": zod.object({
  "index": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorIndexMinOne).nullish().describe('Index of the failed action in the transaction.\n Action index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`'),
  "kind": zod.object({
  "AccountAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage').or(zod.object({
  "AccountDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when TX receiver_id doesn\'t exist (but action is not Action::CreateAccount)')).or(zod.object({
  "CreateAccountOnlyByRegistrar": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "registrar_account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A top-level account ID can only be created by registrar.')).or(zod.object({
  "CreateAccountNotAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A newly created account must be under a namespace of the creator account')).or(zod.object({
  "ActorNoPermission": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "actor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\n or the first TX action is a `CreateAccount` action')).or(zod.object({
  "DeleteKeyDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('Account tries to remove an access key that doesn\'t exist')).or(zod.object({
  "AddKeyAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The public key is already used for an existing access key')).or(zod.object({
  "DeleteAccountStaking": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is staking and can not be deleted')).or(zod.object({
  "LackBalanceForState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which needs balance'),
  "amount": zod.string().describe('Balance required to complete an action.')
})
}).describe('ActionReceipt can\'t be completed, because the remaining balance will not be enough to cover storage.')).or(zod.object({
  "TriesToUnstake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is not yet staked, but tries to unstake')).or(zod.object({
  "TriesToStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "balance": zod.string(),
  "locked": zod.string(),
  "stake": zod.string()
})
}).describe('The account doesn\'t have enough balance to increase the stake.')).or(zod.object({
  "InsufficientStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "minimum_stake": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "FunctionCallError": zod.enum(['WasmUnknownError', '_EVMError']).or(zod.object({
  "CompilationError": zod.object({
  "CodeDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).or(zod.object({
  "PrepareError": zod.enum(['Serialization']).describe('Error happened while serializing the module.').or(zod.enum(['Deserialization']).describe('Error happened while deserializing the module.')).or(zod.enum(['InternalMemoryDeclared']).describe('Internal memory declaration has been found in the module.')).or(zod.enum(['GasInstrumentation']).describe('Gas instrumentation failed.\n\n This most likely indicates the module isn\'t valid.')).or(zod.enum(['StackHeightInstrumentation']).describe('Stack instrumentation failed.\n\n This  most likely indicates the module isn\'t valid.')).or(zod.enum(['Instantiate']).describe('Error happened during instantiation.\n\n This might indicate that `start` function trapped, or module isn\'t\n instantiable and/or un-linkable.')).or(zod.enum(['Memory']).describe('Error creating memory.')).or(zod.enum(['TooManyFunctions']).describe('Contract contains too many functions.')).or(zod.enum(['TooManyLocals']).describe('Contract contains too many locals.')).describe('Error that can occur while preparing or executing Wasm smart-contract.')
})).or(zod.object({
  "WasmerCompileError": zod.object({
  "msg": zod.string()
})
}).describe('This is for defense in depth.\n We expect our runtime-independent preparation code to fully catch all invalid wasms,\n but, if it ever misses something we‚Äôll emit this error'))
}).describe('Wasm compilation error')).or(zod.object({
  "LinkError": zod.object({
  "msg": zod.string()
})
}).describe('Wasm binary env link error\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "MethodResolveError": zod.enum(['MethodEmptyName', 'MethodNotFound', 'MethodInvalidSignature'])
}).describe('Import/export resolve error')).or(zod.object({
  "WasmTrap": zod.enum(['Unreachable']).describe('An `unreachable` opcode was executed.').or(zod.enum(['IncorrectCallIndirectSignature']).describe('Call indirect incorrect signature trap.')).or(zod.enum(['MemoryOutOfBounds']).describe('Memory out of bounds trap.')).or(zod.enum(['CallIndirectOOB']).describe('Call indirect out of bounds trap.')).or(zod.enum(['IllegalArithmetic']).describe('An arithmetic exception, e.g. divided by zero.')).or(zod.enum(['MisalignedAtomicAccess']).describe('Misaligned atomic access trap.')).or(zod.enum(['IndirectCallToNull']).describe('Indirect call to null.')).or(zod.enum(['StackOverflow']).describe('Stack overflow.')).or(zod.enum(['GenericTrap']).describe('Generic trap.')).describe('A kind of a trap happened during execution of a binary')
}).describe('A trap happened during execution of a binary\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "HostError": zod.enum(['BadUTF16']).describe('String encoding is bad UTF-16 sequence').or(zod.enum(['BadUTF8']).describe('String encoding is bad UTF-8 sequence')).or(zod.enum(['GasExceeded']).describe('Exceeded the prepaid gas')).or(zod.enum(['GasLimitExceeded']).describe('Exceeded the maximum amount of gas allowed to burn per contract')).or(zod.enum(['BalanceExceeded']).describe('Exceeded the account balance')).or(zod.enum(['EmptyMethodName']).describe('Tried to call an empty method name')).or(zod.object({
  "GuestPanic": zod.object({
  "panic_msg": zod.string()
})
}).describe('Smart contract panicked')).or(zod.enum(['IntegerOverflow']).describe('IntegerOverflow happened during a contract execution')).or(zod.object({
  "InvalidPromiseIndex": zod.object({
  "promise_idx": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMinOne)
})
}).describe('`promise_idx` does not correspond to existing promises')).or(zod.enum(['CannotAppendActionToJointPromise']).describe('Actions can only be appended to non-joint promise.')).or(zod.enum(['CannotReturnJointPromise']).describe('Returning joint promise is currently prohibited')).or(zod.object({
  "InvalidPromiseResultIndex": zod.object({
  "result_idx": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMinOne)
})
}).describe('Accessed invalid promise result index')).or(zod.object({
  "InvalidRegisterId": zod.object({
  "register_id": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMinOne)
})
}).describe('Accessed invalid register id')).or(zod.object({
  "IteratorWasInvalidated": zod.object({
  "iterator_index": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMinOne)
})
}).describe('Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie')).or(zod.enum(['MemoryAccessViolation']).describe('Accessed memory outside the bounds')).or(zod.object({
  "InvalidReceiptIndex": zod.object({
  "receipt_index": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMinOne)
})
}).describe('VM Logic returned an invalid receipt index')).or(zod.object({
  "InvalidIteratorIndex": zod.object({
  "iterator_index": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMinOne)
})
}).describe('Iterator index `iterator_index` does not exist')).or(zod.enum(['InvalidAccountId']).describe('VM Logic returned an invalid account id')).or(zod.enum(['InvalidMethodName']).describe('VM Logic returned an invalid method name')).or(zod.enum(['InvalidPublicKey']).describe('VM Logic provided an invalid public key')).or(zod.object({
  "ProhibitedInView": zod.object({
  "method_name": zod.string()
})
}).describe('`method_name` is not allowed in view calls')).or(zod.object({
  "NumberOfLogsExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMinOne)
})
}).describe('The total number of logs will exceed the limit.')).or(zod.object({
  "KeyLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMinOne),
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMinOne)
})
}).describe('The storage key length exceeded the limit.')).or(zod.object({
  "ValueLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMinOne),
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMinOne)
})
}).describe('The storage value length exceeded the limit.')).or(zod.object({
  "TotalLogLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMinOne),
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMinOne)
})
}).describe('The total log length exceeded the limit.')).or(zod.object({
  "NumberPromisesExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMinOne),
  "number_of_promises": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMinOne)
})
}).describe('The maximum number of promises within a FunctionCall exceeded the limit.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMinOne),
  "number_of_input_data_dependencies": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne)
})
}).describe('The maximum number of input data dependencies exceeded the limit.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMinOne),
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMinOne)
})
}).describe('The returned value length exceeded the limit.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMinOne),
  "size": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMinOne)
})
}).describe('The contract size for DeployContract action exceeded the limit.')).or(zod.object({
  "Deprecated": zod.object({
  "method_name": zod.string()
})
}).describe('The host function was deprecated.')).or(zod.object({
  "ECRecoverError": zod.object({
  "msg": zod.string()
})
}).describe('General errors for ECDSA recover.')).or(zod.object({
  "AltBn128InvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to alt_bn128 family of functions (e.g., point which isn\'t\n on the curve).')).or(zod.object({
  "Ed25519VerifyInvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to ed25519 signature verification function (e.g. signature cannot be\n derived from bytes).'))
}).describe('Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "ExecutionError": zod.string()
})).describe('Serializable version of `near-vm-runner::FunctionCallError`.\n\n Must never reorder/remove elements, can only add new variants at the end (but do that very\n carefully). It describes stable serialization format, and only used by serialization logic.')
}).describe('An error occurred during a `FunctionCall` Action, parameter is debug message.')).or(zod.object({
  "NewReceiptValidationError": zod.object({
  "InvalidPredecessorId": zod.object({
  "account_id": zod.string()
})
}).describe('The `predecessor_id` of a Receipt is not valid.').or(zod.object({
  "InvalidReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a Receipt is not valid.')).or(zod.object({
  "InvalidSignerId": zod.object({
  "account_id": zod.string()
})
}).describe('The `signer_id` of an ActionReceipt is not valid.')).or(zod.object({
  "InvalidDataReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a DataReceiver within an ActionReceipt is not valid.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMinOne),
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMinOne)
})
}).describe('The length of the returned data exceeded the limit in a DataReceipt.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMinOne),
  "number_of_input_data_dependencies": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne)
})
}).describe('The number of input data dependencies exceeds the limit in an ActionReceipt.')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMinOne),
  "total_prepaid_gas": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne),
  "total_number_of_actions": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne),
  "total_number_of_bytes": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMinOne),
  "size": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMinOne)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne),
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of an ActionReceipt.')).or(zod.object({
  "ReceiptSizeExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMinOne),
  "size": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMinOne)
})
}).describe('Receipt is bigger than the limit.')).describe('Describes the error for validating a receipt.')
}).describe('Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\n receipt validation.')).or(zod.object({
  "OnlyImplicitAccountCreationAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\n See NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\n Also, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\n TODO(#8598): This error is named very poorly. A better name would be\n `OnlyNamedAccountCreationAllowed`.')).or(zod.object({
  "DeleteAccountWithLargeState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Delete account whose state is large is temporarily banned.')).or(zod.enum(['DelegateActionInvalidSignature']).describe('Signature does not match the provided actions and given signer public key.')).or(zod.object({
  "DelegateActionSenderDoesNotMatchTxReceiver": zod.object({
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Receiver of the transaction doesn\'t match Sender of the delegate action')).or(zod.enum(['DelegateActionExpired']).describe('Delegate action has expired. `max_block_height` is less than actual block height.')).or(zod.object({
  "DelegateActionAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('The given public key doesn\'t exist for Sender account')).or(zod.object({
  "DelegateActionInvalidNonce": zod.object({
  "ak_nonce": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMinOne),
  "delegate_nonce": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMinOne)
})
}).describe('DelegateAction nonce must be greater sender[public_key].nonce')).or(zod.object({
  "DelegateActionNonceTooLarge": zod.object({
  "delegate_nonce": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMinOne),
  "upper_bound": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMinOne)
})
}).describe('DelegateAction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "GlobalContractDoesNotExist": zod.object({
  "identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
})
})).describe('The kind of ActionError happened')
}).describe('An error happened during Action execution')
}).describe('An error happened during Action execution').or(zod.object({
  "InvalidTxError": zod.object({
  "InvalidAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('Happens if a wrong AccessKey used or AccessKey has not enough permissions').or(zod.object({
  "InvalidSignerId": zod.object({
  "signer_id": zod.string()
})
}).describe('TX signer_id is not a valid [`AccountId`]')).or(zod.object({
  "SignerDoesNotExist": zod.object({
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('TX signer_id is not found in a storage')).or(zod.object({
  "InvalidNonce": zod.object({
  "ak_nonce": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorInvalidNonceAkNonceMinOne),
  "tx_nonce": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorInvalidNonceTxNonceMinOne)
})
}).describe('Transaction nonce must be strictly greater than `account[access_key].nonce`.')).or(zod.object({
  "NonceTooLarge": zod.object({
  "tx_nonce": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorNonceTooLargeTxNonceMinOne),
  "upper_bound": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMinOne)
})
}).describe('Transaction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "InvalidReceiverId": zod.object({
  "receiver_id": zod.string()
})
}).describe('TX receiver_id is not a valid AccountId')).or(zod.enum(['InvalidSignature']).describe('TX signature is not valid')).or(zod.object({
  "NotEnoughBalance": zod.object({
  "balance": zod.string(),
  "cost": zod.string(),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account does not have enough balance to cover TX cost')).or(zod.object({
  "LackBalanceForState": zod.object({
  "amount": zod.string().describe('Required balance to cover the state.'),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which doesn\'t have enough balance to cover storage.')
})
}).describe('Signer account doesn\'t have enough balance after transaction.')).or(zod.enum(['CostOverflow']).describe('An integer overflow occurred during transaction cost estimation.')).or(zod.enum(['InvalidChain']).describe('Transaction parent block hash doesn\'t belong to the current chain')).or(zod.enum(['Expired']).describe('Transaction has expired')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMinOne),
  "total_prepaid_gas": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne),
  "total_number_of_actions": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne),
  "total_number_of_bytes": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMinOne),
  "size": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMinOne)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne),
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of a Transaction.')).or(zod.object({
  "TransactionSizeExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededLimitMinOne),
  "size": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededSizeMinOne)
})
}).describe('The size of serialized transaction exceeded the limit.')).or(zod.enum(['InvalidTransactionVersion']).describe('Transaction version is invalid.')).or(zod.object({
  "StorageError": zod.enum(['StorageInternalError']).describe('Key-value db internal failure').or(zod.object({
  "MissingTrieValue": zod.object({
  "context": zod.enum(['TrieIterator']).describe('Missing trie value when reading from TrieIterator.').or(zod.enum(['TriePrefetchingStorage']).describe('Missing trie value when reading from TriePrefetchingStorage.')).or(zod.enum(['TrieMemoryPartialStorage']).describe('Missing trie value when reading from TrieMemoryPartialStorage.')).or(zod.enum(['TrieStorage']).describe('Missing trie value when reading from TrieStorage.')).describe('Contexts in which `StorageError::MissingTrieValue` error might occur.'),
  "hash": zod.string()
})
}).describe('Requested trie value by its hash which is missing in storage.')).or(zod.enum(['UnexpectedTrieValue']).describe('Found trie node which shouldn\'t be part of state. Raised during\n validation of state sync parts where incorrect node was passed.\n TODO (#8997): consider including hash of trie node.')).or(zod.object({
  "StorageInconsistentState": zod.string()
}).describe('Either invalid state or key-value db is corrupted.\n For PartialStorage it cannot be corrupted.\n Error message is unreliable and for debugging purposes only. It\'s also probably ok to\n panic in every place that produces this error.\n We can check if db is corrupted by verifying everything in the state trie.')).or(zod.object({
  "FlatStorageBlockNotSupported": zod.string()
}).describe('Flat storage error, meaning that it doesn\'t support some block anymore.\n We guarantee that such block cannot become final, thus block processing\n must resume normally.')).or(zod.object({
  "MemTrieLoadingError": zod.string()
}).describe('In-memory trie could not be loaded for some reason.')).describe('Errors which may occur during working with trie storages, storing\n trie values (trie nodes and state values) by their hashes.')
})).or(zod.object({
  "ShardCongested": zod.object({
  "congestion_level": zod.number().describe('A value between 0 (no congestion) and 1 (max congestion).'),
  "shard_id": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardCongestedShardIdMinOne).describe('The congested shard.')
})
}).describe('The receiver shard of the transaction is too congested to accept new\n transactions at the moment.')).or(zod.object({
  "ShardStuck": zod.object({
  "missed_chunks": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardStuckMissedChunksMinOne).describe('The number of blocks since the last included chunk of the shard.'),
  "shard_id": zod.number().min(sendTxResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardStuckShardIdMinOne).describe('The shard that fails making progress.')
})
}).describe('The receiver shard of the transaction missed several chunks and rejects\n new transaction until it can make progress again.')).describe('An error happened during TX execution')
}).describe('An error happened during Transaction execution')).describe('Error returned in the ExecutionOutcome in case of failure')
}).describe('The execution has failed.')).or(zod.object({
  "SuccessValue": zod.string()
}).describe('The final action succeeded and returned some value or an empty vec encoded in base64.')).or(zod.object({
  "SuccessReceiptId": zod.string()
}).describe('The final action of the receipt returned a promise or the signed transaction was converted\n to a receipt. Contains the receipt_id of the generated receipt.')).describe('Execution status. Contains the result in case of successful execution.'),
  "tokens_burnt": zod.string().describe('The amount of tokens burnt corresponding to the burnt gas amount.\n This value doesn\'t always equal to the `gas_burnt` multiplied by the gas price, because\n the prepaid gas price might be lower than the actual gas price and it creates a deficit.\n `tokens_burnt` also contains the penalty subtracted from refunds, while\n `gas_burnt` only contains the gas that we actually burn for the execution.')
}),
  "proof": zod.array(zod.object({
  "direction": zod.enum(['Left', 'Right']),
  "hash": zod.string()
}))
})).describe('The execution outcome of receipts.'),
  "status": zod.enum(['NotStarted']).describe('The execution has not yet started.').or(zod.enum(['Started']).describe('The execution has started and still going.')).or(zod.object({
  "Failure": zod.object({
  "ActionError": zod.object({
  "index": zod.number().min(sendTxResponseResultStatusFailureActionErrorIndexMinOne).nullish().describe('Index of the failed action in the transaction.\n Action index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`'),
  "kind": zod.object({
  "AccountAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage').or(zod.object({
  "AccountDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when TX receiver_id doesn\'t exist (but action is not Action::CreateAccount)')).or(zod.object({
  "CreateAccountOnlyByRegistrar": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "registrar_account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A top-level account ID can only be created by registrar.')).or(zod.object({
  "CreateAccountNotAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A newly created account must be under a namespace of the creator account')).or(zod.object({
  "ActorNoPermission": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "actor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\n or the first TX action is a `CreateAccount` action')).or(zod.object({
  "DeleteKeyDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('Account tries to remove an access key that doesn\'t exist')).or(zod.object({
  "AddKeyAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The public key is already used for an existing access key')).or(zod.object({
  "DeleteAccountStaking": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is staking and can not be deleted')).or(zod.object({
  "LackBalanceForState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which needs balance'),
  "amount": zod.string().describe('Balance required to complete an action.')
})
}).describe('ActionReceipt can\'t be completed, because the remaining balance will not be enough to cover storage.')).or(zod.object({
  "TriesToUnstake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is not yet staked, but tries to unstake')).or(zod.object({
  "TriesToStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "balance": zod.string(),
  "locked": zod.string(),
  "stake": zod.string()
})
}).describe('The account doesn\'t have enough balance to increase the stake.')).or(zod.object({
  "InsufficientStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "minimum_stake": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "FunctionCallError": zod.enum(['WasmUnknownError', '_EVMError']).or(zod.object({
  "CompilationError": zod.object({
  "CodeDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).or(zod.object({
  "PrepareError": zod.enum(['Serialization']).describe('Error happened while serializing the module.').or(zod.enum(['Deserialization']).describe('Error happened while deserializing the module.')).or(zod.enum(['InternalMemoryDeclared']).describe('Internal memory declaration has been found in the module.')).or(zod.enum(['GasInstrumentation']).describe('Gas instrumentation failed.\n\n This most likely indicates the module isn\'t valid.')).or(zod.enum(['StackHeightInstrumentation']).describe('Stack instrumentation failed.\n\n This  most likely indicates the module isn\'t valid.')).or(zod.enum(['Instantiate']).describe('Error happened during instantiation.\n\n This might indicate that `start` function trapped, or module isn\'t\n instantiable and/or un-linkable.')).or(zod.enum(['Memory']).describe('Error creating memory.')).or(zod.enum(['TooManyFunctions']).describe('Contract contains too many functions.')).or(zod.enum(['TooManyLocals']).describe('Contract contains too many locals.')).describe('Error that can occur while preparing or executing Wasm smart-contract.')
})).or(zod.object({
  "WasmerCompileError": zod.object({
  "msg": zod.string()
})
}).describe('This is for defense in depth.\n We expect our runtime-independent preparation code to fully catch all invalid wasms,\n but, if it ever misses something we‚Äôll emit this error'))
}).describe('Wasm compilation error')).or(zod.object({
  "LinkError": zod.object({
  "msg": zod.string()
})
}).describe('Wasm binary env link error\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "MethodResolveError": zod.enum(['MethodEmptyName', 'MethodNotFound', 'MethodInvalidSignature'])
}).describe('Import/export resolve error')).or(zod.object({
  "WasmTrap": zod.enum(['Unreachable']).describe('An `unreachable` opcode was executed.').or(zod.enum(['IncorrectCallIndirectSignature']).describe('Call indirect incorrect signature trap.')).or(zod.enum(['MemoryOutOfBounds']).describe('Memory out of bounds trap.')).or(zod.enum(['CallIndirectOOB']).describe('Call indirect out of bounds trap.')).or(zod.enum(['IllegalArithmetic']).describe('An arithmetic exception, e.g. divided by zero.')).or(zod.enum(['MisalignedAtomicAccess']).describe('Misaligned atomic access trap.')).or(zod.enum(['IndirectCallToNull']).describe('Indirect call to null.')).or(zod.enum(['StackOverflow']).describe('Stack overflow.')).or(zod.enum(['GenericTrap']).describe('Generic trap.')).describe('A kind of a trap happened during execution of a binary')
}).describe('A trap happened during execution of a binary\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "HostError": zod.enum(['BadUTF16']).describe('String encoding is bad UTF-16 sequence').or(zod.enum(['BadUTF8']).describe('String encoding is bad UTF-8 sequence')).or(zod.enum(['GasExceeded']).describe('Exceeded the prepaid gas')).or(zod.enum(['GasLimitExceeded']).describe('Exceeded the maximum amount of gas allowed to burn per contract')).or(zod.enum(['BalanceExceeded']).describe('Exceeded the account balance')).or(zod.enum(['EmptyMethodName']).describe('Tried to call an empty method name')).or(zod.object({
  "GuestPanic": zod.object({
  "panic_msg": zod.string()
})
}).describe('Smart contract panicked')).or(zod.enum(['IntegerOverflow']).describe('IntegerOverflow happened during a contract execution')).or(zod.object({
  "InvalidPromiseIndex": zod.object({
  "promise_idx": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMinOne)
})
}).describe('`promise_idx` does not correspond to existing promises')).or(zod.enum(['CannotAppendActionToJointPromise']).describe('Actions can only be appended to non-joint promise.')).or(zod.enum(['CannotReturnJointPromise']).describe('Returning joint promise is currently prohibited')).or(zod.object({
  "InvalidPromiseResultIndex": zod.object({
  "result_idx": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMinOne)
})
}).describe('Accessed invalid promise result index')).or(zod.object({
  "InvalidRegisterId": zod.object({
  "register_id": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMinOne)
})
}).describe('Accessed invalid register id')).or(zod.object({
  "IteratorWasInvalidated": zod.object({
  "iterator_index": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMinOne)
})
}).describe('Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie')).or(zod.enum(['MemoryAccessViolation']).describe('Accessed memory outside the bounds')).or(zod.object({
  "InvalidReceiptIndex": zod.object({
  "receipt_index": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMinOne)
})
}).describe('VM Logic returned an invalid receipt index')).or(zod.object({
  "InvalidIteratorIndex": zod.object({
  "iterator_index": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMinOne)
})
}).describe('Iterator index `iterator_index` does not exist')).or(zod.enum(['InvalidAccountId']).describe('VM Logic returned an invalid account id')).or(zod.enum(['InvalidMethodName']).describe('VM Logic returned an invalid method name')).or(zod.enum(['InvalidPublicKey']).describe('VM Logic provided an invalid public key')).or(zod.object({
  "ProhibitedInView": zod.object({
  "method_name": zod.string()
})
}).describe('`method_name` is not allowed in view calls')).or(zod.object({
  "NumberOfLogsExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMinOne)
})
}).describe('The total number of logs will exceed the limit.')).or(zod.object({
  "KeyLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMinOne),
  "limit": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMinOne)
})
}).describe('The storage key length exceeded the limit.')).or(zod.object({
  "ValueLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMinOne),
  "limit": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMinOne)
})
}).describe('The storage value length exceeded the limit.')).or(zod.object({
  "TotalLogLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMinOne),
  "limit": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMinOne)
})
}).describe('The total log length exceeded the limit.')).or(zod.object({
  "NumberPromisesExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMinOne),
  "number_of_promises": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMinOne)
})
}).describe('The maximum number of promises within a FunctionCall exceeded the limit.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMinOne),
  "number_of_input_data_dependencies": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne)
})
}).describe('The maximum number of input data dependencies exceeded the limit.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMinOne),
  "limit": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMinOne)
})
}).describe('The returned value length exceeded the limit.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMinOne),
  "size": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMinOne)
})
}).describe('The contract size for DeployContract action exceeded the limit.')).or(zod.object({
  "Deprecated": zod.object({
  "method_name": zod.string()
})
}).describe('The host function was deprecated.')).or(zod.object({
  "ECRecoverError": zod.object({
  "msg": zod.string()
})
}).describe('General errors for ECDSA recover.')).or(zod.object({
  "AltBn128InvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to alt_bn128 family of functions (e.g., point which isn\'t\n on the curve).')).or(zod.object({
  "Ed25519VerifyInvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to ed25519 signature verification function (e.g. signature cannot be\n derived from bytes).'))
}).describe('Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "ExecutionError": zod.string()
})).describe('Serializable version of `near-vm-runner::FunctionCallError`.\n\n Must never reorder/remove elements, can only add new variants at the end (but do that very\n carefully). It describes stable serialization format, and only used by serialization logic.')
}).describe('An error occurred during a `FunctionCall` Action, parameter is debug message.')).or(zod.object({
  "NewReceiptValidationError": zod.object({
  "InvalidPredecessorId": zod.object({
  "account_id": zod.string()
})
}).describe('The `predecessor_id` of a Receipt is not valid.').or(zod.object({
  "InvalidReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a Receipt is not valid.')).or(zod.object({
  "InvalidSignerId": zod.object({
  "account_id": zod.string()
})
}).describe('The `signer_id` of an ActionReceipt is not valid.')).or(zod.object({
  "InvalidDataReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a DataReceiver within an ActionReceipt is not valid.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMinOne),
  "limit": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMinOne)
})
}).describe('The length of the returned data exceeded the limit in a DataReceipt.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMinOne),
  "number_of_input_data_dependencies": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne)
})
}).describe('The number of input data dependencies exceeds the limit in an ActionReceipt.')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMinOne),
  "total_prepaid_gas": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne),
  "total_number_of_actions": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne),
  "total_number_of_bytes": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMinOne),
  "size": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMinOne)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne),
  "limit": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of an ActionReceipt.')).or(zod.object({
  "ReceiptSizeExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMinOne),
  "size": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMinOne)
})
}).describe('Receipt is bigger than the limit.')).describe('Describes the error for validating a receipt.')
}).describe('Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\n receipt validation.')).or(zod.object({
  "OnlyImplicitAccountCreationAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\n See NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\n Also, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\n TODO(#8598): This error is named very poorly. A better name would be\n `OnlyNamedAccountCreationAllowed`.')).or(zod.object({
  "DeleteAccountWithLargeState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Delete account whose state is large is temporarily banned.')).or(zod.enum(['DelegateActionInvalidSignature']).describe('Signature does not match the provided actions and given signer public key.')).or(zod.object({
  "DelegateActionSenderDoesNotMatchTxReceiver": zod.object({
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Receiver of the transaction doesn\'t match Sender of the delegate action')).or(zod.enum(['DelegateActionExpired']).describe('Delegate action has expired. `max_block_height` is less than actual block height.')).or(zod.object({
  "DelegateActionAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('The given public key doesn\'t exist for Sender account')).or(zod.object({
  "DelegateActionInvalidNonce": zod.object({
  "ak_nonce": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMinOne),
  "delegate_nonce": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMinOne)
})
}).describe('DelegateAction nonce must be greater sender[public_key].nonce')).or(zod.object({
  "DelegateActionNonceTooLarge": zod.object({
  "delegate_nonce": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMinOne),
  "upper_bound": zod.number().min(sendTxResponseResultStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMinOne)
})
}).describe('DelegateAction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "GlobalContractDoesNotExist": zod.object({
  "identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
})
})).describe('The kind of ActionError happened')
}).describe('An error happened during Action execution')
}).describe('An error happened during Action execution').or(zod.object({
  "InvalidTxError": zod.object({
  "InvalidAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('Happens if a wrong AccessKey used or AccessKey has not enough permissions').or(zod.object({
  "InvalidSignerId": zod.object({
  "signer_id": zod.string()
})
}).describe('TX signer_id is not a valid [`AccountId`]')).or(zod.object({
  "SignerDoesNotExist": zod.object({
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('TX signer_id is not found in a storage')).or(zod.object({
  "InvalidNonce": zod.object({
  "ak_nonce": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorInvalidNonceAkNonceMinOne),
  "tx_nonce": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorInvalidNonceTxNonceMinOne)
})
}).describe('Transaction nonce must be strictly greater than `account[access_key].nonce`.')).or(zod.object({
  "NonceTooLarge": zod.object({
  "tx_nonce": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorNonceTooLargeTxNonceMinOne),
  "upper_bound": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMinOne)
})
}).describe('Transaction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "InvalidReceiverId": zod.object({
  "receiver_id": zod.string()
})
}).describe('TX receiver_id is not a valid AccountId')).or(zod.enum(['InvalidSignature']).describe('TX signature is not valid')).or(zod.object({
  "NotEnoughBalance": zod.object({
  "balance": zod.string(),
  "cost": zod.string(),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account does not have enough balance to cover TX cost')).or(zod.object({
  "LackBalanceForState": zod.object({
  "amount": zod.string().describe('Required balance to cover the state.'),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which doesn\'t have enough balance to cover storage.')
})
}).describe('Signer account doesn\'t have enough balance after transaction.')).or(zod.enum(['CostOverflow']).describe('An integer overflow occurred during transaction cost estimation.')).or(zod.enum(['InvalidChain']).describe('Transaction parent block hash doesn\'t belong to the current chain')).or(zod.enum(['Expired']).describe('Transaction has expired')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMinOne),
  "total_prepaid_gas": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne),
  "total_number_of_actions": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne),
  "total_number_of_bytes": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMinOne),
  "size": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMinOne)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne),
  "limit": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of a Transaction.')).or(zod.object({
  "TransactionSizeExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorTransactionSizeExceededLimitMinOne),
  "size": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorTransactionSizeExceededSizeMinOne)
})
}).describe('The size of serialized transaction exceeded the limit.')).or(zod.enum(['InvalidTransactionVersion']).describe('Transaction version is invalid.')).or(zod.object({
  "StorageError": zod.enum(['StorageInternalError']).describe('Key-value db internal failure').or(zod.object({
  "MissingTrieValue": zod.object({
  "context": zod.enum(['TrieIterator']).describe('Missing trie value when reading from TrieIterator.').or(zod.enum(['TriePrefetchingStorage']).describe('Missing trie value when reading from TriePrefetchingStorage.')).or(zod.enum(['TrieMemoryPartialStorage']).describe('Missing trie value when reading from TrieMemoryPartialStorage.')).or(zod.enum(['TrieStorage']).describe('Missing trie value when reading from TrieStorage.')).describe('Contexts in which `StorageError::MissingTrieValue` error might occur.'),
  "hash": zod.string()
})
}).describe('Requested trie value by its hash which is missing in storage.')).or(zod.enum(['UnexpectedTrieValue']).describe('Found trie node which shouldn\'t be part of state. Raised during\n validation of state sync parts where incorrect node was passed.\n TODO (#8997): consider including hash of trie node.')).or(zod.object({
  "StorageInconsistentState": zod.string()
}).describe('Either invalid state or key-value db is corrupted.\n For PartialStorage it cannot be corrupted.\n Error message is unreliable and for debugging purposes only. It\'s also probably ok to\n panic in every place that produces this error.\n We can check if db is corrupted by verifying everything in the state trie.')).or(zod.object({
  "FlatStorageBlockNotSupported": zod.string()
}).describe('Flat storage error, meaning that it doesn\'t support some block anymore.\n We guarantee that such block cannot become final, thus block processing\n must resume normally.')).or(zod.object({
  "MemTrieLoadingError": zod.string()
}).describe('In-memory trie could not be loaded for some reason.')).describe('Errors which may occur during working with trie storages, storing\n trie values (trie nodes and state values) by their hashes.')
})).or(zod.object({
  "ShardCongested": zod.object({
  "congestion_level": zod.number().describe('A value between 0 (no congestion) and 1 (max congestion).'),
  "shard_id": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorShardCongestedShardIdMinOne).describe('The congested shard.')
})
}).describe('The receiver shard of the transaction is too congested to accept new\n transactions at the moment.')).or(zod.object({
  "ShardStuck": zod.object({
  "missed_chunks": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorShardStuckMissedChunksMinOne).describe('The number of blocks since the last included chunk of the shard.'),
  "shard_id": zod.number().min(sendTxResponseResultStatusFailureInvalidTxErrorShardStuckShardIdMinOne).describe('The shard that fails making progress.')
})
}).describe('The receiver shard of the transaction missed several chunks and rejects\n new transaction until it can make progress again.')).describe('An error happened during TX execution')
}).describe('An error happened during Transaction execution')).describe('Error returned in the ExecutionOutcome in case of failure')
}).describe('The execution has failed with the given error.')).or(zod.object({
  "SuccessValue": zod.string()
}).describe('The execution has succeeded and returned some value or an empty vec encoded in base64.')).describe('Execution status defined by chain.rs:get_final_transaction_result\n FinalExecutionStatus::NotStarted - the tx is not converted to the receipt yet\n FinalExecutionStatus::Started - we have at least 1 receipt, but the first leaf receipt_id (using dfs) hasn\'t finished the execution\n FinalExecutionStatus::Failure - the result of the first leaf receipt_id\n FinalExecutionStatus::SuccessValue - the result of the first leaf receipt_id'),
  "transaction": zod.object({
  "actions": zod.array(zod.enum(['CreateAccount']).or(zod.object({
  "DeployContract": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "FunctionCall": zod.object({
  "args": zod.string(),
  "deposit": zod.string(),
  "gas": zod.number().min(sendTxResponseResultTransactionActionsItemFunctionCallGasMinOne),
  "method_name": zod.string()
})
})).or(zod.object({
  "Transfer": zod.object({
  "deposit": zod.string()
})
})).or(zod.object({
  "Stake": zod.object({
  "public_key": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "AddKey": zod.object({
  "access_key": zod.object({
  "nonce": zod.number().min(sendTxResponseResultTransactionActionsItemAddKeyAccessKeyNonceMinOne),
  "permission": zod.enum(['FullAccess']).or(zod.object({
  "FunctionCall": zod.object({
  "allowance": zod.string().nullish(),
  "method_names": zod.array(zod.string()),
  "receiver_id": zod.string()
})
}))
}),
  "public_key": zod.string()
})
})).or(zod.object({
  "DeleteKey": zod.object({
  "public_key": zod.string()
})
})).or(zod.object({
  "DeleteAccount": zod.object({
  "beneficiary_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
})).or(zod.object({
  "Delegate": zod.object({
  "delegate_action": zod.object({
  "actions": zod.array(zod.object({
  "CreateAccount": zod.object({

}).describe('Create account action')
}).describe('Create an (sub)account using a transaction `receiver_id` as an ID for\n a new account ID must pass validation rules described here\n <http://nomicon.io/Primitives/Account.html>.').or(zod.object({
  "DeployContract": zod.object({
  "code": zod.string().describe('WebAssembly binary')
}).describe('Deploy contract action')
}).describe('Sets a Wasm code to a receiver_id')).or(zod.object({
  "FunctionCall": zod.object({
  "args": zod.string(),
  "deposit": zod.string(),
  "gas": zod.number().min(sendTxResponseResultTransactionActionsItemDelegateDelegateActionActionsItemFunctionCallGasMinOne),
  "method_name": zod.string()
})
})).or(zod.object({
  "Transfer": zod.object({
  "deposit": zod.string()
})
})).or(zod.object({
  "Stake": zod.object({
  "public_key": zod.string().describe('Validator key which will be used to sign transactions on behalf of signer_id'),
  "stake": zod.string().describe('Amount of tokens to stake.')
}).describe('An action which stakes signer_id tokens and setup\'s validator public key')
})).or(zod.object({
  "AddKey": zod.object({
  "access_key": zod.object({
  "nonce": zod.number().min(sendTxResponseResultTransactionActionsItemDelegateDelegateActionActionsItemAddKeyAccessKeyNonceMinOne).describe('Nonce for this access key, used for tx nonce generation. When access key is created, nonce\n is set to `(block_height - 1) * 1e6` to avoid tx hash collision on access key re-creation.\n See <https://github.com/near/nearcore/issues/3779> for more details.'),
  "permission": zod.object({
  "FunctionCall": zod.object({
  "allowance": zod.string().nullish().describe('Allowance is a balance limit to use by this access key to pay for function call gas and\n transaction fees. When this access key is used, both account balance and the allowance is\n decreased by the same value.\n `None` means unlimited allowance.\n NOTE: To change or increase the allowance, the old access key needs to be deleted and a new\n access key should be created.'),
  "method_names": zod.array(zod.string()).describe('A list of method names that can be used. The access key only allows transactions with the\n function call of one of the given method names.\n Empty list means any method name can be used.'),
  "receiver_id": zod.string().describe('The access key only allows transactions with the given receiver\'s account id.')
}).describe('Grants limited permission to make transactions with FunctionCallActions\n The permission can limit the allowed balance to be spent on the prepaid gas.\n It also restrict the account ID of the receiver for this function call.\n It also can restrict the method name for the allowed function calls.')
}).or(zod.enum(['FullAccess']).describe('Grants full access to the account.\n NOTE: It\'s used to replace account-level public keys.')).describe('Defines permissions for AccessKey').describe('Defines permissions for this access key.')
}).describe('Access key provides limited access to an account. Each access key belongs to some account and\n is identified by a unique (within the account) public key. One account may have large number of\n access keys. Access keys allow to act on behalf of the account by restricting transactions\n that can be issued.\n `account_id,public_key` is a key in the state').describe('An access key with the permission'),
  "public_key": zod.string().describe('A public key which will be associated with an access_key')
})
})).or(zod.object({
  "DeleteKey": zod.object({
  "public_key": zod.string().describe('A public key associated with the access_key to be deleted.')
})
})).or(zod.object({
  "DeleteAccount": zod.object({
  "beneficiary_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
})).or(zod.object({
  "Delegate": zod.object({
  "delegate_action": zod.any(),
  "signature": zod.string()
})
})).or(zod.object({
  "DeployGlobalContract": zod.object({
  "code": zod.string().describe('WebAssembly binary'),
  "deploy_mode": zod.enum(['CodeHash']).describe('Contract is deployed under its code hash.\n Users will be able reference it by that hash.\n This effectively makes the contract immutable.').or(zod.enum(['AccountId']).describe('Contract is deployed under the owner account id.\n Users will be able reference it by that account id.\n This allows the owner to update the contract for all its users.'))
}).describe('Deploy global contract action')
})).or(zod.object({
  "UseGlobalContract": zod.object({
  "contract_identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
}).describe('Use global contract action')
})).describe('This is Action which mustn\'t contain DelegateAction.\n\n This struct is needed to avoid the recursion when Action/DelegateAction is deserialized.\n\n Important: Don\'t make the inner Action public, this must only be constructed\n through the correct interface that ensures the inner Action is actually not\n a delegate action. That would break an assumption of this type, which we use\n in several places. For example, borsh de-/serialization relies on it. If the\n invariant is broken, we may end up with a `Transaction` or `Receipt` that we\n can serialize but deserializing it back causes a parsing error.')).describe('List of actions to be executed.\n\n With the meta transactions MVP defined in NEP-366, nested\n DelegateActions are not allowed. A separate type is used to enforce it.'),
  "max_block_height": zod.number().min(sendTxResponseResultTransactionActionsItemDelegateDelegateActionMaxBlockHeightMinOne).describe('The maximal height of the block in the blockchain below which the given DelegateAction is valid.'),
  "nonce": zod.number().min(sendTxResponseResultTransactionActionsItemDelegateDelegateActionNonceMinOne).describe('Nonce to ensure that the same delegate action is not sent twice by a\n relayer and should match for given account\'s `public_key`.\n After this action is processed it will increment.'),
  "public_key": zod.string().describe('Public key used to sign this delegated action.'),
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('Receiver of the delegated actions.'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('Signer of the delegated actions')
}).describe('This action allows to execute the inner actions behalf of the defined sender.'),
  "signature": zod.string()
})
})).or(zod.object({
  "DeployGlobalContract": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "DeployGlobalContractByAccountId": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "UseGlobalContract": zod.object({
  "code_hash": zod.string()
})
})).or(zod.object({
  "UseGlobalContractByAccountId": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}))),
  "hash": zod.string(),
  "nonce": zod.number().min(sendTxResponseResultTransactionNonceMinOne),
  "priority_fee": zod.number().min(sendTxResponseResultTransactionPriorityFeeMinOne).optional(),
  "public_key": zod.string(),
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "signature": zod.string(),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}).describe('Signed Transaction'),
  "transaction_outcome": zod.object({
  "block_hash": zod.string(),
  "id": zod.string(),
  "outcome": zod.object({
  "executor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('The id of the account on which the execution happens. For transaction this is signer_id,\n for receipt this is receiver_id.'),
  "gas_burnt": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeGasBurntMinOne).describe('The amount of the gas burnt by the given transaction or receipt.'),
  "logs": zod.array(zod.string()).describe('Logs from this transaction or receipt.'),
  "metadata": zod.object({
  "gas_profile": zod.array(zod.object({
  "cost": zod.string(),
  "cost_category": zod.string(),
  "gas_used": zod.string()
})).nullish(),
  "version": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeMetadataVersionMinOne)
}).default(sendTxResponseResultTransactionOutcomeOutcomeMetadataDefaultTwo).describe('Execution metadata, versioned'),
  "receipt_ids": zod.array(zod.string()).describe('Receipt IDs generated by this transaction or receipt.'),
  "status": zod.enum(['Unknown']).describe('The execution is pending or unknown.').or(zod.object({
  "Failure": zod.object({
  "ActionError": zod.object({
  "index": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorIndexMinOne).nullish().describe('Index of the failed action in the transaction.\n Action index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`'),
  "kind": zod.object({
  "AccountAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage').or(zod.object({
  "AccountDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when TX receiver_id doesn\'t exist (but action is not Action::CreateAccount)')).or(zod.object({
  "CreateAccountOnlyByRegistrar": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "registrar_account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A top-level account ID can only be created by registrar.')).or(zod.object({
  "CreateAccountNotAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A newly created account must be under a namespace of the creator account')).or(zod.object({
  "ActorNoPermission": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "actor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\n or the first TX action is a `CreateAccount` action')).or(zod.object({
  "DeleteKeyDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('Account tries to remove an access key that doesn\'t exist')).or(zod.object({
  "AddKeyAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The public key is already used for an existing access key')).or(zod.object({
  "DeleteAccountStaking": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is staking and can not be deleted')).or(zod.object({
  "LackBalanceForState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which needs balance'),
  "amount": zod.string().describe('Balance required to complete an action.')
})
}).describe('ActionReceipt can\'t be completed, because the remaining balance will not be enough to cover storage.')).or(zod.object({
  "TriesToUnstake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is not yet staked, but tries to unstake')).or(zod.object({
  "TriesToStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "balance": zod.string(),
  "locked": zod.string(),
  "stake": zod.string()
})
}).describe('The account doesn\'t have enough balance to increase the stake.')).or(zod.object({
  "InsufficientStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "minimum_stake": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "FunctionCallError": zod.enum(['WasmUnknownError', '_EVMError']).or(zod.object({
  "CompilationError": zod.object({
  "CodeDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).or(zod.object({
  "PrepareError": zod.enum(['Serialization']).describe('Error happened while serializing the module.').or(zod.enum(['Deserialization']).describe('Error happened while deserializing the module.')).or(zod.enum(['InternalMemoryDeclared']).describe('Internal memory declaration has been found in the module.')).or(zod.enum(['GasInstrumentation']).describe('Gas instrumentation failed.\n\n This most likely indicates the module isn\'t valid.')).or(zod.enum(['StackHeightInstrumentation']).describe('Stack instrumentation failed.\n\n This  most likely indicates the module isn\'t valid.')).or(zod.enum(['Instantiate']).describe('Error happened during instantiation.\n\n This might indicate that `start` function trapped, or module isn\'t\n instantiable and/or un-linkable.')).or(zod.enum(['Memory']).describe('Error creating memory.')).or(zod.enum(['TooManyFunctions']).describe('Contract contains too many functions.')).or(zod.enum(['TooManyLocals']).describe('Contract contains too many locals.')).describe('Error that can occur while preparing or executing Wasm smart-contract.')
})).or(zod.object({
  "WasmerCompileError": zod.object({
  "msg": zod.string()
})
}).describe('This is for defense in depth.\n We expect our runtime-independent preparation code to fully catch all invalid wasms,\n but, if it ever misses something we‚Äôll emit this error'))
}).describe('Wasm compilation error')).or(zod.object({
  "LinkError": zod.object({
  "msg": zod.string()
})
}).describe('Wasm binary env link error\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "MethodResolveError": zod.enum(['MethodEmptyName', 'MethodNotFound', 'MethodInvalidSignature'])
}).describe('Import/export resolve error')).or(zod.object({
  "WasmTrap": zod.enum(['Unreachable']).describe('An `unreachable` opcode was executed.').or(zod.enum(['IncorrectCallIndirectSignature']).describe('Call indirect incorrect signature trap.')).or(zod.enum(['MemoryOutOfBounds']).describe('Memory out of bounds trap.')).or(zod.enum(['CallIndirectOOB']).describe('Call indirect out of bounds trap.')).or(zod.enum(['IllegalArithmetic']).describe('An arithmetic exception, e.g. divided by zero.')).or(zod.enum(['MisalignedAtomicAccess']).describe('Misaligned atomic access trap.')).or(zod.enum(['IndirectCallToNull']).describe('Indirect call to null.')).or(zod.enum(['StackOverflow']).describe('Stack overflow.')).or(zod.enum(['GenericTrap']).describe('Generic trap.')).describe('A kind of a trap happened during execution of a binary')
}).describe('A trap happened during execution of a binary\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "HostError": zod.enum(['BadUTF16']).describe('String encoding is bad UTF-16 sequence').or(zod.enum(['BadUTF8']).describe('String encoding is bad UTF-8 sequence')).or(zod.enum(['GasExceeded']).describe('Exceeded the prepaid gas')).or(zod.enum(['GasLimitExceeded']).describe('Exceeded the maximum amount of gas allowed to burn per contract')).or(zod.enum(['BalanceExceeded']).describe('Exceeded the account balance')).or(zod.enum(['EmptyMethodName']).describe('Tried to call an empty method name')).or(zod.object({
  "GuestPanic": zod.object({
  "panic_msg": zod.string()
})
}).describe('Smart contract panicked')).or(zod.enum(['IntegerOverflow']).describe('IntegerOverflow happened during a contract execution')).or(zod.object({
  "InvalidPromiseIndex": zod.object({
  "promise_idx": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMinOne)
})
}).describe('`promise_idx` does not correspond to existing promises')).or(zod.enum(['CannotAppendActionToJointPromise']).describe('Actions can only be appended to non-joint promise.')).or(zod.enum(['CannotReturnJointPromise']).describe('Returning joint promise is currently prohibited')).or(zod.object({
  "InvalidPromiseResultIndex": zod.object({
  "result_idx": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMinOne)
})
}).describe('Accessed invalid promise result index')).or(zod.object({
  "InvalidRegisterId": zod.object({
  "register_id": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMinOne)
})
}).describe('Accessed invalid register id')).or(zod.object({
  "IteratorWasInvalidated": zod.object({
  "iterator_index": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMinOne)
})
}).describe('Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie')).or(zod.enum(['MemoryAccessViolation']).describe('Accessed memory outside the bounds')).or(zod.object({
  "InvalidReceiptIndex": zod.object({
  "receipt_index": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMinOne)
})
}).describe('VM Logic returned an invalid receipt index')).or(zod.object({
  "InvalidIteratorIndex": zod.object({
  "iterator_index": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMinOne)
})
}).describe('Iterator index `iterator_index` does not exist')).or(zod.enum(['InvalidAccountId']).describe('VM Logic returned an invalid account id')).or(zod.enum(['InvalidMethodName']).describe('VM Logic returned an invalid method name')).or(zod.enum(['InvalidPublicKey']).describe('VM Logic provided an invalid public key')).or(zod.object({
  "ProhibitedInView": zod.object({
  "method_name": zod.string()
})
}).describe('`method_name` is not allowed in view calls')).or(zod.object({
  "NumberOfLogsExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMinOne)
})
}).describe('The total number of logs will exceed the limit.')).or(zod.object({
  "KeyLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMinOne),
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMinOne)
})
}).describe('The storage key length exceeded the limit.')).or(zod.object({
  "ValueLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMinOne),
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMinOne)
})
}).describe('The storage value length exceeded the limit.')).or(zod.object({
  "TotalLogLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMinOne),
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMinOne)
})
}).describe('The total log length exceeded the limit.')).or(zod.object({
  "NumberPromisesExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMinOne),
  "number_of_promises": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMinOne)
})
}).describe('The maximum number of promises within a FunctionCall exceeded the limit.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMinOne),
  "number_of_input_data_dependencies": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne)
})
}).describe('The maximum number of input data dependencies exceeded the limit.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMinOne),
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMinOne)
})
}).describe('The returned value length exceeded the limit.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMinOne),
  "size": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMinOne)
})
}).describe('The contract size for DeployContract action exceeded the limit.')).or(zod.object({
  "Deprecated": zod.object({
  "method_name": zod.string()
})
}).describe('The host function was deprecated.')).or(zod.object({
  "ECRecoverError": zod.object({
  "msg": zod.string()
})
}).describe('General errors for ECDSA recover.')).or(zod.object({
  "AltBn128InvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to alt_bn128 family of functions (e.g., point which isn\'t\n on the curve).')).or(zod.object({
  "Ed25519VerifyInvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to ed25519 signature verification function (e.g. signature cannot be\n derived from bytes).'))
}).describe('Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "ExecutionError": zod.string()
})).describe('Serializable version of `near-vm-runner::FunctionCallError`.\n\n Must never reorder/remove elements, can only add new variants at the end (but do that very\n carefully). It describes stable serialization format, and only used by serialization logic.')
}).describe('An error occurred during a `FunctionCall` Action, parameter is debug message.')).or(zod.object({
  "NewReceiptValidationError": zod.object({
  "InvalidPredecessorId": zod.object({
  "account_id": zod.string()
})
}).describe('The `predecessor_id` of a Receipt is not valid.').or(zod.object({
  "InvalidReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a Receipt is not valid.')).or(zod.object({
  "InvalidSignerId": zod.object({
  "account_id": zod.string()
})
}).describe('The `signer_id` of an ActionReceipt is not valid.')).or(zod.object({
  "InvalidDataReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a DataReceiver within an ActionReceipt is not valid.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMinOne),
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMinOne)
})
}).describe('The length of the returned data exceeded the limit in a DataReceipt.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMinOne),
  "number_of_input_data_dependencies": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne)
})
}).describe('The number of input data dependencies exceeds the limit in an ActionReceipt.')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMinOne),
  "total_prepaid_gas": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne),
  "total_number_of_actions": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne),
  "total_number_of_bytes": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMinOne),
  "size": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMinOne)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne),
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of an ActionReceipt.')).or(zod.object({
  "ReceiptSizeExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMinOne),
  "size": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMinOne)
})
}).describe('Receipt is bigger than the limit.')).describe('Describes the error for validating a receipt.')
}).describe('Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\n receipt validation.')).or(zod.object({
  "OnlyImplicitAccountCreationAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\n See NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\n Also, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\n TODO(#8598): This error is named very poorly. A better name would be\n `OnlyNamedAccountCreationAllowed`.')).or(zod.object({
  "DeleteAccountWithLargeState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Delete account whose state is large is temporarily banned.')).or(zod.enum(['DelegateActionInvalidSignature']).describe('Signature does not match the provided actions and given signer public key.')).or(zod.object({
  "DelegateActionSenderDoesNotMatchTxReceiver": zod.object({
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Receiver of the transaction doesn\'t match Sender of the delegate action')).or(zod.enum(['DelegateActionExpired']).describe('Delegate action has expired. `max_block_height` is less than actual block height.')).or(zod.object({
  "DelegateActionAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('The given public key doesn\'t exist for Sender account')).or(zod.object({
  "DelegateActionInvalidNonce": zod.object({
  "ak_nonce": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMinOne),
  "delegate_nonce": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMinOne)
})
}).describe('DelegateAction nonce must be greater sender[public_key].nonce')).or(zod.object({
  "DelegateActionNonceTooLarge": zod.object({
  "delegate_nonce": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMinOne),
  "upper_bound": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMinOne)
})
}).describe('DelegateAction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "GlobalContractDoesNotExist": zod.object({
  "identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
})
})).describe('The kind of ActionError happened')
}).describe('An error happened during Action execution')
}).describe('An error happened during Action execution').or(zod.object({
  "InvalidTxError": zod.object({
  "InvalidAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('Happens if a wrong AccessKey used or AccessKey has not enough permissions').or(zod.object({
  "InvalidSignerId": zod.object({
  "signer_id": zod.string()
})
}).describe('TX signer_id is not a valid [`AccountId`]')).or(zod.object({
  "SignerDoesNotExist": zod.object({
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('TX signer_id is not found in a storage')).or(zod.object({
  "InvalidNonce": zod.object({
  "ak_nonce": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorInvalidNonceAkNonceMinOne),
  "tx_nonce": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorInvalidNonceTxNonceMinOne)
})
}).describe('Transaction nonce must be strictly greater than `account[access_key].nonce`.')).or(zod.object({
  "NonceTooLarge": zod.object({
  "tx_nonce": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorNonceTooLargeTxNonceMinOne),
  "upper_bound": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMinOne)
})
}).describe('Transaction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "InvalidReceiverId": zod.object({
  "receiver_id": zod.string()
})
}).describe('TX receiver_id is not a valid AccountId')).or(zod.enum(['InvalidSignature']).describe('TX signature is not valid')).or(zod.object({
  "NotEnoughBalance": zod.object({
  "balance": zod.string(),
  "cost": zod.string(),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account does not have enough balance to cover TX cost')).or(zod.object({
  "LackBalanceForState": zod.object({
  "amount": zod.string().describe('Required balance to cover the state.'),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which doesn\'t have enough balance to cover storage.')
})
}).describe('Signer account doesn\'t have enough balance after transaction.')).or(zod.enum(['CostOverflow']).describe('An integer overflow occurred during transaction cost estimation.')).or(zod.enum(['InvalidChain']).describe('Transaction parent block hash doesn\'t belong to the current chain')).or(zod.enum(['Expired']).describe('Transaction has expired')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMinOne),
  "total_prepaid_gas": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne),
  "total_number_of_actions": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne),
  "total_number_of_bytes": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMinOne),
  "size": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMinOne)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne),
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of a Transaction.')).or(zod.object({
  "TransactionSizeExceeded": zod.object({
  "limit": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededLimitMinOne),
  "size": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededSizeMinOne)
})
}).describe('The size of serialized transaction exceeded the limit.')).or(zod.enum(['InvalidTransactionVersion']).describe('Transaction version is invalid.')).or(zod.object({
  "StorageError": zod.enum(['StorageInternalError']).describe('Key-value db internal failure').or(zod.object({
  "MissingTrieValue": zod.object({
  "context": zod.enum(['TrieIterator']).describe('Missing trie value when reading from TrieIterator.').or(zod.enum(['TriePrefetchingStorage']).describe('Missing trie value when reading from TriePrefetchingStorage.')).or(zod.enum(['TrieMemoryPartialStorage']).describe('Missing trie value when reading from TrieMemoryPartialStorage.')).or(zod.enum(['TrieStorage']).describe('Missing trie value when reading from TrieStorage.')).describe('Contexts in which `StorageError::MissingTrieValue` error might occur.'),
  "hash": zod.string()
})
}).describe('Requested trie value by its hash which is missing in storage.')).or(zod.enum(['UnexpectedTrieValue']).describe('Found trie node which shouldn\'t be part of state. Raised during\n validation of state sync parts where incorrect node was passed.\n TODO (#8997): consider including hash of trie node.')).or(zod.object({
  "StorageInconsistentState": zod.string()
}).describe('Either invalid state or key-value db is corrupted.\n For PartialStorage it cannot be corrupted.\n Error message is unreliable and for debugging purposes only. It\'s also probably ok to\n panic in every place that produces this error.\n We can check if db is corrupted by verifying everything in the state trie.')).or(zod.object({
  "FlatStorageBlockNotSupported": zod.string()
}).describe('Flat storage error, meaning that it doesn\'t support some block anymore.\n We guarantee that such block cannot become final, thus block processing\n must resume normally.')).or(zod.object({
  "MemTrieLoadingError": zod.string()
}).describe('In-memory trie could not be loaded for some reason.')).describe('Errors which may occur during working with trie storages, storing\n trie values (trie nodes and state values) by their hashes.')
})).or(zod.object({
  "ShardCongested": zod.object({
  "congestion_level": zod.number().describe('A value between 0 (no congestion) and 1 (max congestion).'),
  "shard_id": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardCongestedShardIdMinOne).describe('The congested shard.')
})
}).describe('The receiver shard of the transaction is too congested to accept new\n transactions at the moment.')).or(zod.object({
  "ShardStuck": zod.object({
  "missed_chunks": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardStuckMissedChunksMinOne).describe('The number of blocks since the last included chunk of the shard.'),
  "shard_id": zod.number().min(sendTxResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardStuckShardIdMinOne).describe('The shard that fails making progress.')
})
}).describe('The receiver shard of the transaction missed several chunks and rejects\n new transaction until it can make progress again.')).describe('An error happened during TX execution')
}).describe('An error happened during Transaction execution')).describe('Error returned in the ExecutionOutcome in case of failure')
}).describe('The execution has failed.')).or(zod.object({
  "SuccessValue": zod.string()
}).describe('The final action succeeded and returned some value or an empty vec encoded in base64.')).or(zod.object({
  "SuccessReceiptId": zod.string()
}).describe('The final action of the receipt returned a promise or the signed transaction was converted\n to a receipt. Contains the receipt_id of the generated receipt.')).describe('Execution status. Contains the result in case of successful execution.'),
  "tokens_burnt": zod.string().describe('The amount of tokens burnt corresponding to the burnt gas amount.\n This value doesn\'t always equal to the `gas_burnt` multiplied by the gas price, because\n the prepaid gas price might be lower than the actual gas price and it creates a deficit.\n `tokens_burnt` also contains the penalty subtracted from refunds, while\n `gas_burnt` only contains the gas that we actually burn for the execution.')
}),
  "proof": zod.array(zod.object({
  "direction": zod.enum(['Left', 'Right']),
  "hash": zod.string()
}))
}).describe('The execution outcome of the signed transaction.')
}).describe('Execution outcome of the transaction and all the subsequent receipts.\n Could be not finalized yet'))
}).or(zod.object({
  "error": zod.object({
  "cause": zod.object({
  "info": zod.object({
  "method_name": zod.string()
}),
  "name": zod.enum(['METHOD_NOT_FOUND'])
}).or(zod.object({
  "info": zod.object({
  "error_message": zod.string()
}),
  "name": zod.enum(['PARSE_ERROR'])
})),
  "name": zod.enum(['REQUEST_VALIDATION_ERROR'])
}).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['HANDLER_ERROR'])
})).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['INTERNAL_ERROR'])
})).describe('This struct may be returned from JSON RPC server in case of error\n It is expected that this struct has impl From<_> all other RPC errors\n like [RpcBlockError](crate::types::blocks::RpcBlockError)')
}))


export const statusBody = zod.object({
  "id": zod.string(),
  "jsonrpc": zod.string(),
  "method": zod.enum(['status']),
  "params": zod.object({

})
})

export const statusResponseResultDetailedDebugStatusBlockProductionDelayMillisMin = 0;
export const statusResponseResultDetailedDebugStatusCatchupStatusItemBlocksToCatchupItemHeightMin = 0;
export const statusResponseResultDetailedDebugStatusCatchupStatusItemSyncBlockHeightMin = 0;
export const statusResponseResultDetailedDebugStatusCurrentHeadStatusHeightMin = 0;
export const statusResponseResultDetailedDebugStatusCurrentHeaderHeadStatusHeightMin = 0;
export const statusResponseResultDetailedDebugStatusNetworkInfoConnectedPeersItemConnectionEstablishedTimeMillisMin = 0;
export const statusResponseResultDetailedDebugStatusNetworkInfoConnectedPeersItemHeightMin = 0;
export const statusResponseResultDetailedDebugStatusNetworkInfoConnectedPeersItemLastTimePeerRequestedMillisMin = 0;
export const statusResponseResultDetailedDebugStatusNetworkInfoConnectedPeersItemLastTimeReceivedMessageMillisMin = 0;
export const statusResponseResultDetailedDebugStatusNetworkInfoConnectedPeersItemNonceMin = 0;
export const statusResponseResultDetailedDebugStatusNetworkInfoConnectedPeersItemReceivedBytesPerSecMin = 0;
export const statusResponseResultDetailedDebugStatusNetworkInfoConnectedPeersItemSentBytesPerSecMin = 0;
export const statusResponseResultDetailedDebugStatusNetworkInfoConnectedPeersItemTrackedShardsItemMin = 0;
export const statusResponseResultDetailedDebugStatusNetworkInfoNumConnectedPeersMin = 0;
export const statusResponseResultDetailedDebugStatusNetworkInfoPeerMaxCountMin = 0;
export const statusResponseResultDetailedDebugStatusNetworkInfoTier1ConnectionsItemConnectionEstablishedTimeMillisMin = 0;
export const statusResponseResultDetailedDebugStatusNetworkInfoTier1ConnectionsItemHeightMin = 0;
export const statusResponseResultDetailedDebugStatusNetworkInfoTier1ConnectionsItemLastTimePeerRequestedMillisMin = 0;
export const statusResponseResultDetailedDebugStatusNetworkInfoTier1ConnectionsItemLastTimeReceivedMessageMillisMin = 0;
export const statusResponseResultDetailedDebugStatusNetworkInfoTier1ConnectionsItemNonceMin = 0;
export const statusResponseResultDetailedDebugStatusNetworkInfoTier1ConnectionsItemReceivedBytesPerSecMin = 0;
export const statusResponseResultDetailedDebugStatusNetworkInfoTier1ConnectionsItemSentBytesPerSecMin = 0;
export const statusResponseResultDetailedDebugStatusNetworkInfoTier1ConnectionsItemTrackedShardsItemMin = 0;
export const statusResponseResultLatestProtocolVersionMin = 0;
export const statusResponseResultProtocolVersionMin = 0;
export const statusResponseResultSyncInfoEarliestBlockHeightMin = 0;
export const statusResponseResultSyncInfoEpochStartHeightMin = 0;
export const statusResponseResultSyncInfoLatestBlockHeightMin = 0;
export const statusResponseResultVersionRustcVersionDefault = "";

export const statusResponse = zod.object({
  "result": zod.object({
  "chain_id": zod.string().describe('Unique chain id.'),
  "detailed_debug_status": zod.object({
  "block_production_delay_millis": zod.number().min(statusResponseResultDetailedDebugStatusBlockProductionDelayMillisMin),
  "catchup_status": zod.array(zod.object({
  "blocks_to_catchup": zod.array(zod.object({
  "hash": zod.string(),
  "height": zod.number().min(statusResponseResultDetailedDebugStatusCatchupStatusItemBlocksToCatchupItemHeightMin)
})),
  "shard_sync_status": zod.record(zod.string(), zod.string()),
  "sync_block_hash": zod.string(),
  "sync_block_height": zod.number().min(statusResponseResultDetailedDebugStatusCatchupStatusItemSyncBlockHeightMin)
})),
  "current_head_status": zod.object({
  "hash": zod.string(),
  "height": zod.number().min(statusResponseResultDetailedDebugStatusCurrentHeadStatusHeightMin)
}),
  "current_header_head_status": zod.object({
  "hash": zod.string(),
  "height": zod.number().min(statusResponseResultDetailedDebugStatusCurrentHeaderHeadStatusHeightMin)
}),
  "network_info": zod.object({
  "connected_peers": zod.array(zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').nullish(),
  "addr": zod.string(),
  "archival": zod.boolean(),
  "block_hash": zod.string().nullish(),
  "connection_established_time_millis": zod.number().min(statusResponseResultDetailedDebugStatusNetworkInfoConnectedPeersItemConnectionEstablishedTimeMillisMin),
  "height": zod.number().min(statusResponseResultDetailedDebugStatusNetworkInfoConnectedPeersItemHeightMin).nullish(),
  "is_highest_block_invalid": zod.boolean(),
  "is_outbound_peer": zod.boolean(),
  "last_time_peer_requested_millis": zod.number().min(statusResponseResultDetailedDebugStatusNetworkInfoConnectedPeersItemLastTimePeerRequestedMillisMin),
  "last_time_received_message_millis": zod.number().min(statusResponseResultDetailedDebugStatusNetworkInfoConnectedPeersItemLastTimeReceivedMessageMillisMin),
  "nonce": zod.number().min(statusResponseResultDetailedDebugStatusNetworkInfoConnectedPeersItemNonceMin).describe('Connection nonce.'),
  "peer_id": zod.string(),
  "received_bytes_per_sec": zod.number().min(statusResponseResultDetailedDebugStatusNetworkInfoConnectedPeersItemReceivedBytesPerSecMin),
  "sent_bytes_per_sec": zod.number().min(statusResponseResultDetailedDebugStatusNetworkInfoConnectedPeersItemSentBytesPerSecMin),
  "tracked_shards": zod.array(zod.number().min(statusResponseResultDetailedDebugStatusNetworkInfoConnectedPeersItemTrackedShardsItemMin).describe('The shard identifier. It may be an arbitrary number - it does not need to be\n a number in the range 0..NUM_SHARDS. The shard ids do not need to be\n sequential or contiguous.\n\n The shard id is wrapped in a new type to prevent the old pattern of using\n indices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\n if fully complete it potentially may be simplified to a regular type alias.'))
})),
  "known_producers": zod.array(zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "next_hops": zod.array(zod.string()).nullish(),
  "peer_id": zod.string()
}).describe('Information about a Producer: its account name, peer_id and a list of connected peers that\n the node can use to send message for this producer.')),
  "num_connected_peers": zod.number().min(statusResponseResultDetailedDebugStatusNetworkInfoNumConnectedPeersMin),
  "peer_max_count": zod.number().min(statusResponseResultDetailedDebugStatusNetworkInfoPeerMaxCountMin),
  "tier1_accounts_data": zod.array(zod.object({
  "account_key": zod.string(),
  "peer_id": zod.string(),
  "proxies": zod.array(zod.object({
  "addr": zod.string(),
  "peer_id": zod.string()
})),
  "timestamp": zod.string()
})),
  "tier1_accounts_keys": zod.array(zod.string()),
  "tier1_connections": zod.array(zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').nullish(),
  "addr": zod.string(),
  "archival": zod.boolean(),
  "block_hash": zod.string().nullish(),
  "connection_established_time_millis": zod.number().min(statusResponseResultDetailedDebugStatusNetworkInfoTier1ConnectionsItemConnectionEstablishedTimeMillisMin),
  "height": zod.number().min(statusResponseResultDetailedDebugStatusNetworkInfoTier1ConnectionsItemHeightMin).nullish(),
  "is_highest_block_invalid": zod.boolean(),
  "is_outbound_peer": zod.boolean(),
  "last_time_peer_requested_millis": zod.number().min(statusResponseResultDetailedDebugStatusNetworkInfoTier1ConnectionsItemLastTimePeerRequestedMillisMin),
  "last_time_received_message_millis": zod.number().min(statusResponseResultDetailedDebugStatusNetworkInfoTier1ConnectionsItemLastTimeReceivedMessageMillisMin),
  "nonce": zod.number().min(statusResponseResultDetailedDebugStatusNetworkInfoTier1ConnectionsItemNonceMin).describe('Connection nonce.'),
  "peer_id": zod.string(),
  "received_bytes_per_sec": zod.number().min(statusResponseResultDetailedDebugStatusNetworkInfoTier1ConnectionsItemReceivedBytesPerSecMin),
  "sent_bytes_per_sec": zod.number().min(statusResponseResultDetailedDebugStatusNetworkInfoTier1ConnectionsItemSentBytesPerSecMin),
  "tracked_shards": zod.array(zod.number().min(statusResponseResultDetailedDebugStatusNetworkInfoTier1ConnectionsItemTrackedShardsItemMin).describe('The shard identifier. It may be an arbitrary number - it does not need to be\n a number in the range 0..NUM_SHARDS. The shard ids do not need to be\n sequential or contiguous.\n\n The shard id is wrapped in a new type to prevent the old pattern of using\n indices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\n if fully complete it potentially may be simplified to a regular type alias.'))
}))
}),
  "sync_status": zod.string()
}).nullish().describe('Information about last blocks, network, epoch and chain & chunk info.'),
  "genesis_hash": zod.string().describe('Genesis hash of the chain.'),
  "latest_protocol_version": zod.number().min(statusResponseResultLatestProtocolVersionMin).describe('Latest protocol version that this client supports.'),
  "node_key": zod.string().nullish().describe('Deprecated; same as `validator_public_key` which you should use instead.'),
  "node_public_key": zod.string().describe('Public key of the node.'),
  "protocol_version": zod.number().min(statusResponseResultProtocolVersionMin).describe('Currently active protocol version.'),
  "rpc_addr": zod.string().nullish().describe('Address for RPC server.  None if node doesn\'t have RPC endpoint enabled.'),
  "sync_info": zod.object({
  "earliest_block_hash": zod.string().nullish(),
  "earliest_block_height": zod.number().min(statusResponseResultSyncInfoEarliestBlockHeightMin).nullish(),
  "earliest_block_time": zod.string().nullish(),
  "epoch_id": zod.string().describe('Epoch identifier -- wrapped hash, to make it easier to distinguish.\n EpochId of epoch T is the hash of last block in T-2\n EpochId of first two epochs is 0').nullish(),
  "epoch_start_height": zod.number().min(statusResponseResultSyncInfoEpochStartHeightMin).nullish(),
  "latest_block_hash": zod.string(),
  "latest_block_height": zod.number().min(statusResponseResultSyncInfoLatestBlockHeightMin),
  "latest_block_time": zod.string(),
  "latest_state_root": zod.string(),
  "syncing": zod.boolean()
}).describe('Sync status of the node.'),
  "uptime_sec": zod.number().describe('Uptime of the node.'),
  "validator_account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').nullish().describe('Validator id of the node'),
  "validator_public_key": zod.string().nullish().describe('Public key of the validator.'),
  "validators": zod.array(zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})).describe('Current epoch validators.'),
  "version": zod.object({
  "build": zod.string(),
  "commit": zod.string(),
  "rustc_version": zod.string().optional(),
  "version": zod.string()
}).describe('Data structure for semver version and github tag or commit.').describe('Binary version.')
})
}).or(zod.object({
  "error": zod.object({
  "cause": zod.object({
  "info": zod.object({
  "method_name": zod.string()
}),
  "name": zod.enum(['METHOD_NOT_FOUND'])
}).or(zod.object({
  "info": zod.object({
  "error_message": zod.string()
}),
  "name": zod.enum(['PARSE_ERROR'])
})),
  "name": zod.enum(['REQUEST_VALIDATION_ERROR'])
}).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['HANDLER_ERROR'])
})).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['INTERNAL_ERROR'])
})).describe('This struct may be returned from JSON RPC server in case of error\n It is expected that this struct has impl From<_> all other RPC errors\n like [RpcBlockError](crate::types::blocks::RpcBlockError)')
}))


export const txBody = zod.object({
  "id": zod.string(),
  "jsonrpc": zod.string(),
  "method": zod.enum(['tx']),
  "params": zod.object({
  "signed_tx_base64": zod.string()
}).or(zod.object({
  "sender_account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "tx_hash": zod.string()
}))
})

export const txResponseResultReceiptsItemPriorityDefault = 0;
export const txResponseResultReceiptsItemPriorityMin = 0;
export const txResponseResultReceiptsItemReceiptActionActionsItemFunctionCallGasMin = 0;
export const txResponseResultReceiptsItemReceiptActionActionsItemAddKeyAccessKeyNonceMin = 0;
export const txResponseResultReceiptsItemReceiptActionActionsItemDelegateDelegateActionActionsItemFunctionCallGasMin = 0;
export const txResponseResultReceiptsItemReceiptActionActionsItemDelegateDelegateActionActionsItemAddKeyAccessKeyNonceMin = 0;
export const txResponseResultReceiptsItemReceiptActionActionsItemDelegateDelegateActionMaxBlockHeightMin = 0;
export const txResponseResultReceiptsItemReceiptActionActionsItemDelegateDelegateActionNonceMin = 0;
export const txResponseResultReceiptsItemReceiptActionIsPromiseYieldDefault = false;export const txResponseResultReceiptsItemReceiptDataDataDefault = null;export const txResponseResultReceiptsItemReceiptDataIsPromiseResumeDefault = false;export const txResponseResultReceiptsItemReceiptGlobalContractDistributionAlreadyDeliveredShardsItemMin = 0;
export const txResponseResultReceiptsItemReceiptGlobalContractDistributionTargetShardMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeGasBurntMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeMetadataVersionMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeMetadataDefault = { version: 1 };export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorIndexMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorInvalidNonceAkNonceMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorInvalidNonceTxNonceMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorNonceTooLargeTxNonceMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededLimitMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededSizeMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardCongestedShardIdMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardStuckMissedChunksMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardStuckShardIdMin = 0;
export const txResponseResultStatusFailureActionErrorIndexMin = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMin = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMin = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMin = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMin = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMin = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMin = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMin = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMin = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMin = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMin = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMin = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMin = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMin = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMin = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMin = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMin = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMin = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMin = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMin = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMin = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMin = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMin = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMin = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMin = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMin = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMin = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMin = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMin = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMin = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMin = 0;
export const txResponseResultStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMin = 0;
export const txResponseResultStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMin = 0;
export const txResponseResultStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMin = 0;
export const txResponseResultStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMin = 0;
export const txResponseResultStatusFailureInvalidTxErrorInvalidNonceAkNonceMin = 0;
export const txResponseResultStatusFailureInvalidTxErrorInvalidNonceTxNonceMin = 0;
export const txResponseResultStatusFailureInvalidTxErrorNonceTooLargeTxNonceMin = 0;
export const txResponseResultStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMin = 0;
export const txResponseResultStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMin = 0;
export const txResponseResultStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin = 0;
export const txResponseResultStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMin = 0;
export const txResponseResultStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin = 0;
export const txResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin = 0;
export const txResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin = 0;
export const txResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin = 0;
export const txResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin = 0;
export const txResponseResultStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMin = 0;
export const txResponseResultStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMin = 0;
export const txResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin = 0;
export const txResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin = 0;
export const txResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin = 0;
export const txResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin = 0;
export const txResponseResultStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMin = 0;
export const txResponseResultStatusFailureInvalidTxErrorTransactionSizeExceededLimitMin = 0;
export const txResponseResultStatusFailureInvalidTxErrorTransactionSizeExceededSizeMin = 0;
export const txResponseResultStatusFailureInvalidTxErrorShardCongestedShardIdMin = 0;
export const txResponseResultStatusFailureInvalidTxErrorShardStuckMissedChunksMin = 0;
export const txResponseResultStatusFailureInvalidTxErrorShardStuckShardIdMin = 0;
export const txResponseResultTransactionActionsItemFunctionCallGasMin = 0;
export const txResponseResultTransactionActionsItemAddKeyAccessKeyNonceMin = 0;
export const txResponseResultTransactionActionsItemDelegateDelegateActionActionsItemFunctionCallGasMin = 0;
export const txResponseResultTransactionActionsItemDelegateDelegateActionActionsItemAddKeyAccessKeyNonceMin = 0;
export const txResponseResultTransactionActionsItemDelegateDelegateActionMaxBlockHeightMin = 0;
export const txResponseResultTransactionActionsItemDelegateDelegateActionNonceMin = 0;
export const txResponseResultTransactionNonceMin = 0;
export const txResponseResultTransactionPriorityFeeDefault = 0;
export const txResponseResultTransactionPriorityFeeMin = 0;
export const txResponseResultTransactionOutcomeOutcomeGasBurntMin = 0;
export const txResponseResultTransactionOutcomeOutcomeMetadataVersionMin = 0;
export const txResponseResultTransactionOutcomeOutcomeMetadataDefault = { version: 1 };export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorIndexMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorInvalidNonceAkNonceMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorInvalidNonceTxNonceMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorNonceTooLargeTxNonceMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededLimitMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededSizeMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardCongestedShardIdMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardStuckMissedChunksMin = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardStuckShardIdMin = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeGasBurntMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeMetadataVersionMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeMetadataDefaultTwo = { version: 1 };export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorIndexMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorInvalidNonceAkNonceMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorInvalidNonceTxNonceMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorNonceTooLargeTxNonceMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededLimitMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededSizeMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardCongestedShardIdMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardStuckMissedChunksMinOne = 0;
export const txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardStuckShardIdMinOne = 0;
export const txResponseResultStatusFailureActionErrorIndexMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMinOne = 0;
export const txResponseResultStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMinOne = 0;
export const txResponseResultStatusFailureInvalidTxErrorInvalidNonceAkNonceMinOne = 0;
export const txResponseResultStatusFailureInvalidTxErrorInvalidNonceTxNonceMinOne = 0;
export const txResponseResultStatusFailureInvalidTxErrorNonceTooLargeTxNonceMinOne = 0;
export const txResponseResultStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMinOne = 0;
export const txResponseResultStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMinOne = 0;
export const txResponseResultStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne = 0;
export const txResponseResultStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne = 0;
export const txResponseResultStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne = 0;
export const txResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne = 0;
export const txResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne = 0;
export const txResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne = 0;
export const txResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne = 0;
export const txResponseResultStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMinOne = 0;
export const txResponseResultStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMinOne = 0;
export const txResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne = 0;
export const txResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne = 0;
export const txResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne = 0;
export const txResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne = 0;
export const txResponseResultStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne = 0;
export const txResponseResultStatusFailureInvalidTxErrorTransactionSizeExceededLimitMinOne = 0;
export const txResponseResultStatusFailureInvalidTxErrorTransactionSizeExceededSizeMinOne = 0;
export const txResponseResultStatusFailureInvalidTxErrorShardCongestedShardIdMinOne = 0;
export const txResponseResultStatusFailureInvalidTxErrorShardStuckMissedChunksMinOne = 0;
export const txResponseResultStatusFailureInvalidTxErrorShardStuckShardIdMinOne = 0;
export const txResponseResultTransactionActionsItemFunctionCallGasMinOne = 0;
export const txResponseResultTransactionActionsItemAddKeyAccessKeyNonceMinOne = 0;
export const txResponseResultTransactionActionsItemDelegateDelegateActionActionsItemFunctionCallGasMinOne = 0;
export const txResponseResultTransactionActionsItemDelegateDelegateActionActionsItemAddKeyAccessKeyNonceMinOne = 0;
export const txResponseResultTransactionActionsItemDelegateDelegateActionMaxBlockHeightMinOne = 0;
export const txResponseResultTransactionActionsItemDelegateDelegateActionNonceMinOne = 0;
export const txResponseResultTransactionNonceMinOne = 0;
export const txResponseResultTransactionPriorityFeeDefaultOne = 0;
export const txResponseResultTransactionPriorityFeeMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeGasBurntMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeMetadataVersionMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeMetadataDefaultTwo = { version: 1 };export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorIndexMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorInvalidNonceAkNonceMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorInvalidNonceTxNonceMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorNonceTooLargeTxNonceMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededLimitMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededSizeMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardCongestedShardIdMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardStuckMissedChunksMinOne = 0;
export const txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardStuckShardIdMinOne = 0;


export const txResponse = zod.object({
  "result": zod.object({
  "receipts": zod.array(zod.object({
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "priority": zod.number().min(txResponseResultReceiptsItemPriorityMin).optional(),
  "receipt": zod.object({
  "Action": zod.object({
  "actions": zod.array(zod.enum(['CreateAccount']).or(zod.object({
  "DeployContract": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "FunctionCall": zod.object({
  "args": zod.string(),
  "deposit": zod.string(),
  "gas": zod.number().min(txResponseResultReceiptsItemReceiptActionActionsItemFunctionCallGasMin),
  "method_name": zod.string()
})
})).or(zod.object({
  "Transfer": zod.object({
  "deposit": zod.string()
})
})).or(zod.object({
  "Stake": zod.object({
  "public_key": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "AddKey": zod.object({
  "access_key": zod.object({
  "nonce": zod.number().min(txResponseResultReceiptsItemReceiptActionActionsItemAddKeyAccessKeyNonceMin),
  "permission": zod.enum(['FullAccess']).or(zod.object({
  "FunctionCall": zod.object({
  "allowance": zod.string().nullish(),
  "method_names": zod.array(zod.string()),
  "receiver_id": zod.string()
})
}))
}),
  "public_key": zod.string()
})
})).or(zod.object({
  "DeleteKey": zod.object({
  "public_key": zod.string()
})
})).or(zod.object({
  "DeleteAccount": zod.object({
  "beneficiary_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
})).or(zod.object({
  "Delegate": zod.object({
  "delegate_action": zod.object({
  "actions": zod.array(zod.object({
  "CreateAccount": zod.object({

}).describe('Create account action')
}).describe('Create an (sub)account using a transaction `receiver_id` as an ID for\n a new account ID must pass validation rules described here\n <http://nomicon.io/Primitives/Account.html>.').or(zod.object({
  "DeployContract": zod.object({
  "code": zod.string().describe('WebAssembly binary')
}).describe('Deploy contract action')
}).describe('Sets a Wasm code to a receiver_id')).or(zod.object({
  "FunctionCall": zod.object({
  "args": zod.string(),
  "deposit": zod.string(),
  "gas": zod.number().min(txResponseResultReceiptsItemReceiptActionActionsItemDelegateDelegateActionActionsItemFunctionCallGasMin),
  "method_name": zod.string()
})
})).or(zod.object({
  "Transfer": zod.object({
  "deposit": zod.string()
})
})).or(zod.object({
  "Stake": zod.object({
  "public_key": zod.string().describe('Validator key which will be used to sign transactions on behalf of signer_id'),
  "stake": zod.string().describe('Amount of tokens to stake.')
}).describe('An action which stakes signer_id tokens and setup\'s validator public key')
})).or(zod.object({
  "AddKey": zod.object({
  "access_key": zod.object({
  "nonce": zod.number().min(txResponseResultReceiptsItemReceiptActionActionsItemDelegateDelegateActionActionsItemAddKeyAccessKeyNonceMin).describe('Nonce for this access key, used for tx nonce generation. When access key is created, nonce\n is set to `(block_height - 1) * 1e6` to avoid tx hash collision on access key re-creation.\n See <https://github.com/near/nearcore/issues/3779> for more details.'),
  "permission": zod.object({
  "FunctionCall": zod.object({
  "allowance": zod.string().nullish().describe('Allowance is a balance limit to use by this access key to pay for function call gas and\n transaction fees. When this access key is used, both account balance and the allowance is\n decreased by the same value.\n `None` means unlimited allowance.\n NOTE: To change or increase the allowance, the old access key needs to be deleted and a new\n access key should be created.'),
  "method_names": zod.array(zod.string()).describe('A list of method names that can be used. The access key only allows transactions with the\n function call of one of the given method names.\n Empty list means any method name can be used.'),
  "receiver_id": zod.string().describe('The access key only allows transactions with the given receiver\'s account id.')
}).describe('Grants limited permission to make transactions with FunctionCallActions\n The permission can limit the allowed balance to be spent on the prepaid gas.\n It also restrict the account ID of the receiver for this function call.\n It also can restrict the method name for the allowed function calls.')
}).or(zod.enum(['FullAccess']).describe('Grants full access to the account.\n NOTE: It\'s used to replace account-level public keys.')).describe('Defines permissions for AccessKey').describe('Defines permissions for this access key.')
}).describe('Access key provides limited access to an account. Each access key belongs to some account and\n is identified by a unique (within the account) public key. One account may have large number of\n access keys. Access keys allow to act on behalf of the account by restricting transactions\n that can be issued.\n `account_id,public_key` is a key in the state').describe('An access key with the permission'),
  "public_key": zod.string().describe('A public key which will be associated with an access_key')
})
})).or(zod.object({
  "DeleteKey": zod.object({
  "public_key": zod.string().describe('A public key associated with the access_key to be deleted.')
})
})).or(zod.object({
  "DeleteAccount": zod.object({
  "beneficiary_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
})).or(zod.object({
  "Delegate": zod.object({
  "delegate_action": zod.any(),
  "signature": zod.string()
})
})).or(zod.object({
  "DeployGlobalContract": zod.object({
  "code": zod.string().describe('WebAssembly binary'),
  "deploy_mode": zod.enum(['CodeHash']).describe('Contract is deployed under its code hash.\n Users will be able reference it by that hash.\n This effectively makes the contract immutable.').or(zod.enum(['AccountId']).describe('Contract is deployed under the owner account id.\n Users will be able reference it by that account id.\n This allows the owner to update the contract for all its users.'))
}).describe('Deploy global contract action')
})).or(zod.object({
  "UseGlobalContract": zod.object({
  "contract_identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
}).describe('Use global contract action')
})).describe('This is Action which mustn\'t contain DelegateAction.\n\n This struct is needed to avoid the recursion when Action/DelegateAction is deserialized.\n\n Important: Don\'t make the inner Action public, this must only be constructed\n through the correct interface that ensures the inner Action is actually not\n a delegate action. That would break an assumption of this type, which we use\n in several places. For example, borsh de-/serialization relies on it. If the\n invariant is broken, we may end up with a `Transaction` or `Receipt` that we\n can serialize but deserializing it back causes a parsing error.')).describe('List of actions to be executed.\n\n With the meta transactions MVP defined in NEP-366, nested\n DelegateActions are not allowed. A separate type is used to enforce it.'),
  "max_block_height": zod.number().min(txResponseResultReceiptsItemReceiptActionActionsItemDelegateDelegateActionMaxBlockHeightMin).describe('The maximal height of the block in the blockchain below which the given DelegateAction is valid.'),
  "nonce": zod.number().min(txResponseResultReceiptsItemReceiptActionActionsItemDelegateDelegateActionNonceMin).describe('Nonce to ensure that the same delegate action is not sent twice by a\n relayer and should match for given account\'s `public_key`.\n After this action is processed it will increment.'),
  "public_key": zod.string().describe('Public key used to sign this delegated action.'),
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('Receiver of the delegated actions.'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('Signer of the delegated actions')
}).describe('This action allows to execute the inner actions behalf of the defined sender.'),
  "signature": zod.string()
})
})).or(zod.object({
  "DeployGlobalContract": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "DeployGlobalContractByAccountId": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "UseGlobalContract": zod.object({
  "code_hash": zod.string()
})
})).or(zod.object({
  "UseGlobalContractByAccountId": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}))),
  "gas_price": zod.string(),
  "input_data_ids": zod.array(zod.string()),
  "is_promise_yield": zod.boolean().optional(),
  "output_data_receivers": zod.array(zod.object({
  "data_id": zod.string(),
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "signer_public_key": zod.string()
})
}).or(zod.object({
  "Data": zod.object({
  "data": zod.string().nullish(),
  "data_id": zod.string(),
  "is_promise_resume": zod.boolean().optional()
})
})).or(zod.object({
  "GlobalContractDistribution": zod.object({
  "already_delivered_shards": zod.array(zod.number().min(txResponseResultReceiptsItemReceiptGlobalContractDistributionAlreadyDeliveredShardsItemMin).describe('The shard identifier. It may be an arbitrary number - it does not need to be\n a number in the range 0..NUM_SHARDS. The shard ids do not need to be\n sequential or contiguous.\n\n The shard id is wrapped in a new type to prevent the old pattern of using\n indices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\n if fully complete it potentially may be simplified to a regular type alias.')),
  "code": zod.string(),
  "id": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})),
  "target_shard": zod.number().min(txResponseResultReceiptsItemReceiptGlobalContractDistributionTargetShardMin).describe('The shard identifier. It may be an arbitrary number - it does not need to be\n a number in the range 0..NUM_SHARDS. The shard ids do not need to be\n sequential or contiguous.\n\n The shard id is wrapped in a new type to prevent the old pattern of using\n indices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\n if fully complete it potentially may be simplified to a regular type alias.')
})
})),
  "receipt_id": zod.string(),
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})).describe('Receipts generated from the transaction'),
  "receipts_outcome": zod.array(zod.object({
  "block_hash": zod.string(),
  "id": zod.string(),
  "outcome": zod.object({
  "executor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('The id of the account on which the execution happens. For transaction this is signer_id,\n for receipt this is receiver_id.'),
  "gas_burnt": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeGasBurntMin).describe('The amount of the gas burnt by the given transaction or receipt.'),
  "logs": zod.array(zod.string()).describe('Logs from this transaction or receipt.'),
  "metadata": zod.object({
  "gas_profile": zod.array(zod.object({
  "cost": zod.string(),
  "cost_category": zod.string(),
  "gas_used": zod.string()
})).nullish(),
  "version": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeMetadataVersionMin)
}).default(txResponseResultReceiptsOutcomeItemOutcomeMetadataDefault).describe('Execution metadata, versioned'),
  "receipt_ids": zod.array(zod.string()).describe('Receipt IDs generated by this transaction or receipt.'),
  "status": zod.enum(['Unknown']).describe('The execution is pending or unknown.').or(zod.object({
  "Failure": zod.object({
  "ActionError": zod.object({
  "index": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorIndexMin).nullish().describe('Index of the failed action in the transaction.\n Action index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`'),
  "kind": zod.object({
  "AccountAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage').or(zod.object({
  "AccountDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when TX receiver_id doesn\'t exist (but action is not Action::CreateAccount)')).or(zod.object({
  "CreateAccountOnlyByRegistrar": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "registrar_account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A top-level account ID can only be created by registrar.')).or(zod.object({
  "CreateAccountNotAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A newly created account must be under a namespace of the creator account')).or(zod.object({
  "ActorNoPermission": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "actor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\n or the first TX action is a `CreateAccount` action')).or(zod.object({
  "DeleteKeyDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('Account tries to remove an access key that doesn\'t exist')).or(zod.object({
  "AddKeyAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The public key is already used for an existing access key')).or(zod.object({
  "DeleteAccountStaking": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is staking and can not be deleted')).or(zod.object({
  "LackBalanceForState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which needs balance'),
  "amount": zod.string().describe('Balance required to complete an action.')
})
}).describe('ActionReceipt can\'t be completed, because the remaining balance will not be enough to cover storage.')).or(zod.object({
  "TriesToUnstake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is not yet staked, but tries to unstake')).or(zod.object({
  "TriesToStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "balance": zod.string(),
  "locked": zod.string(),
  "stake": zod.string()
})
}).describe('The account doesn\'t have enough balance to increase the stake.')).or(zod.object({
  "InsufficientStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "minimum_stake": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "FunctionCallError": zod.enum(['WasmUnknownError', '_EVMError']).or(zod.object({
  "CompilationError": zod.object({
  "CodeDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).or(zod.object({
  "PrepareError": zod.enum(['Serialization']).describe('Error happened while serializing the module.').or(zod.enum(['Deserialization']).describe('Error happened while deserializing the module.')).or(zod.enum(['InternalMemoryDeclared']).describe('Internal memory declaration has been found in the module.')).or(zod.enum(['GasInstrumentation']).describe('Gas instrumentation failed.\n\n This most likely indicates the module isn\'t valid.')).or(zod.enum(['StackHeightInstrumentation']).describe('Stack instrumentation failed.\n\n This  most likely indicates the module isn\'t valid.')).or(zod.enum(['Instantiate']).describe('Error happened during instantiation.\n\n This might indicate that `start` function trapped, or module isn\'t\n instantiable and/or un-linkable.')).or(zod.enum(['Memory']).describe('Error creating memory.')).or(zod.enum(['TooManyFunctions']).describe('Contract contains too many functions.')).or(zod.enum(['TooManyLocals']).describe('Contract contains too many locals.')).describe('Error that can occur while preparing or executing Wasm smart-contract.')
})).or(zod.object({
  "WasmerCompileError": zod.object({
  "msg": zod.string()
})
}).describe('This is for defense in depth.\n We expect our runtime-independent preparation code to fully catch all invalid wasms,\n but, if it ever misses something we‚Äôll emit this error'))
}).describe('Wasm compilation error')).or(zod.object({
  "LinkError": zod.object({
  "msg": zod.string()
})
}).describe('Wasm binary env link error\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "MethodResolveError": zod.enum(['MethodEmptyName', 'MethodNotFound', 'MethodInvalidSignature'])
}).describe('Import/export resolve error')).or(zod.object({
  "WasmTrap": zod.enum(['Unreachable']).describe('An `unreachable` opcode was executed.').or(zod.enum(['IncorrectCallIndirectSignature']).describe('Call indirect incorrect signature trap.')).or(zod.enum(['MemoryOutOfBounds']).describe('Memory out of bounds trap.')).or(zod.enum(['CallIndirectOOB']).describe('Call indirect out of bounds trap.')).or(zod.enum(['IllegalArithmetic']).describe('An arithmetic exception, e.g. divided by zero.')).or(zod.enum(['MisalignedAtomicAccess']).describe('Misaligned atomic access trap.')).or(zod.enum(['IndirectCallToNull']).describe('Indirect call to null.')).or(zod.enum(['StackOverflow']).describe('Stack overflow.')).or(zod.enum(['GenericTrap']).describe('Generic trap.')).describe('A kind of a trap happened during execution of a binary')
}).describe('A trap happened during execution of a binary\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "HostError": zod.enum(['BadUTF16']).describe('String encoding is bad UTF-16 sequence').or(zod.enum(['BadUTF8']).describe('String encoding is bad UTF-8 sequence')).or(zod.enum(['GasExceeded']).describe('Exceeded the prepaid gas')).or(zod.enum(['GasLimitExceeded']).describe('Exceeded the maximum amount of gas allowed to burn per contract')).or(zod.enum(['BalanceExceeded']).describe('Exceeded the account balance')).or(zod.enum(['EmptyMethodName']).describe('Tried to call an empty method name')).or(zod.object({
  "GuestPanic": zod.object({
  "panic_msg": zod.string()
})
}).describe('Smart contract panicked')).or(zod.enum(['IntegerOverflow']).describe('IntegerOverflow happened during a contract execution')).or(zod.object({
  "InvalidPromiseIndex": zod.object({
  "promise_idx": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMin)
})
}).describe('`promise_idx` does not correspond to existing promises')).or(zod.enum(['CannotAppendActionToJointPromise']).describe('Actions can only be appended to non-joint promise.')).or(zod.enum(['CannotReturnJointPromise']).describe('Returning joint promise is currently prohibited')).or(zod.object({
  "InvalidPromiseResultIndex": zod.object({
  "result_idx": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMin)
})
}).describe('Accessed invalid promise result index')).or(zod.object({
  "InvalidRegisterId": zod.object({
  "register_id": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMin)
})
}).describe('Accessed invalid register id')).or(zod.object({
  "IteratorWasInvalidated": zod.object({
  "iterator_index": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMin)
})
}).describe('Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie')).or(zod.enum(['MemoryAccessViolation']).describe('Accessed memory outside the bounds')).or(zod.object({
  "InvalidReceiptIndex": zod.object({
  "receipt_index": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMin)
})
}).describe('VM Logic returned an invalid receipt index')).or(zod.object({
  "InvalidIteratorIndex": zod.object({
  "iterator_index": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMin)
})
}).describe('Iterator index `iterator_index` does not exist')).or(zod.enum(['InvalidAccountId']).describe('VM Logic returned an invalid account id')).or(zod.enum(['InvalidMethodName']).describe('VM Logic returned an invalid method name')).or(zod.enum(['InvalidPublicKey']).describe('VM Logic provided an invalid public key')).or(zod.object({
  "ProhibitedInView": zod.object({
  "method_name": zod.string()
})
}).describe('`method_name` is not allowed in view calls')).or(zod.object({
  "NumberOfLogsExceeded": zod.object({
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMin)
})
}).describe('The total number of logs will exceed the limit.')).or(zod.object({
  "KeyLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMin),
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMin)
})
}).describe('The storage key length exceeded the limit.')).or(zod.object({
  "ValueLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMin),
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMin)
})
}).describe('The storage value length exceeded the limit.')).or(zod.object({
  "TotalLogLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMin),
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMin)
})
}).describe('The total log length exceeded the limit.')).or(zod.object({
  "NumberPromisesExceeded": zod.object({
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMin),
  "number_of_promises": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMin)
})
}).describe('The maximum number of promises within a FunctionCall exceeded the limit.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMin),
  "number_of_input_data_dependencies": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin)
})
}).describe('The maximum number of input data dependencies exceeded the limit.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMin),
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMin)
})
}).describe('The returned value length exceeded the limit.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMin),
  "size": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMin)
})
}).describe('The contract size for DeployContract action exceeded the limit.')).or(zod.object({
  "Deprecated": zod.object({
  "method_name": zod.string()
})
}).describe('The host function was deprecated.')).or(zod.object({
  "ECRecoverError": zod.object({
  "msg": zod.string()
})
}).describe('General errors for ECDSA recover.')).or(zod.object({
  "AltBn128InvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to alt_bn128 family of functions (e.g., point which isn\'t\n on the curve).')).or(zod.object({
  "Ed25519VerifyInvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to ed25519 signature verification function (e.g. signature cannot be\n derived from bytes).'))
}).describe('Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "ExecutionError": zod.string()
})).describe('Serializable version of `near-vm-runner::FunctionCallError`.\n\n Must never reorder/remove elements, can only add new variants at the end (but do that very\n carefully). It describes stable serialization format, and only used by serialization logic.')
}).describe('An error occurred during a `FunctionCall` Action, parameter is debug message.')).or(zod.object({
  "NewReceiptValidationError": zod.object({
  "InvalidPredecessorId": zod.object({
  "account_id": zod.string()
})
}).describe('The `predecessor_id` of a Receipt is not valid.').or(zod.object({
  "InvalidReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a Receipt is not valid.')).or(zod.object({
  "InvalidSignerId": zod.object({
  "account_id": zod.string()
})
}).describe('The `signer_id` of an ActionReceipt is not valid.')).or(zod.object({
  "InvalidDataReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a DataReceiver within an ActionReceipt is not valid.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMin),
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMin)
})
}).describe('The length of the returned data exceeded the limit in a DataReceipt.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMin),
  "number_of_input_data_dependencies": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin)
})
}).describe('The number of input data dependencies exceeds the limit in an ActionReceipt.')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMin),
  "total_prepaid_gas": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMin),
  "total_number_of_actions": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin),
  "total_number_of_bytes": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMin),
  "size": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMin)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin),
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMin)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of an ActionReceipt.')).or(zod.object({
  "ReceiptSizeExceeded": zod.object({
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMin),
  "size": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMin)
})
}).describe('Receipt is bigger than the limit.')).describe('Describes the error for validating a receipt.')
}).describe('Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\n receipt validation.')).or(zod.object({
  "OnlyImplicitAccountCreationAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\n See NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\n Also, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\n TODO(#8598): This error is named very poorly. A better name would be\n `OnlyNamedAccountCreationAllowed`.')).or(zod.object({
  "DeleteAccountWithLargeState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Delete account whose state is large is temporarily banned.')).or(zod.enum(['DelegateActionInvalidSignature']).describe('Signature does not match the provided actions and given signer public key.')).or(zod.object({
  "DelegateActionSenderDoesNotMatchTxReceiver": zod.object({
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Receiver of the transaction doesn\'t match Sender of the delegate action')).or(zod.enum(['DelegateActionExpired']).describe('Delegate action has expired. `max_block_height` is less than actual block height.')).or(zod.object({
  "DelegateActionAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('The given public key doesn\'t exist for Sender account')).or(zod.object({
  "DelegateActionInvalidNonce": zod.object({
  "ak_nonce": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMin),
  "delegate_nonce": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMin)
})
}).describe('DelegateAction nonce must be greater sender[public_key].nonce')).or(zod.object({
  "DelegateActionNonceTooLarge": zod.object({
  "delegate_nonce": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMin),
  "upper_bound": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMin)
})
}).describe('DelegateAction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "GlobalContractDoesNotExist": zod.object({
  "identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
})
})).describe('The kind of ActionError happened')
}).describe('An error happened during Action execution')
}).describe('An error happened during Action execution').or(zod.object({
  "InvalidTxError": zod.object({
  "InvalidAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('Happens if a wrong AccessKey used or AccessKey has not enough permissions').or(zod.object({
  "InvalidSignerId": zod.object({
  "signer_id": zod.string()
})
}).describe('TX signer_id is not a valid [`AccountId`]')).or(zod.object({
  "SignerDoesNotExist": zod.object({
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('TX signer_id is not found in a storage')).or(zod.object({
  "InvalidNonce": zod.object({
  "ak_nonce": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorInvalidNonceAkNonceMin),
  "tx_nonce": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorInvalidNonceTxNonceMin)
})
}).describe('Transaction nonce must be strictly greater than `account[access_key].nonce`.')).or(zod.object({
  "NonceTooLarge": zod.object({
  "tx_nonce": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorNonceTooLargeTxNonceMin),
  "upper_bound": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMin)
})
}).describe('Transaction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "InvalidReceiverId": zod.object({
  "receiver_id": zod.string()
})
}).describe('TX receiver_id is not a valid AccountId')).or(zod.enum(['InvalidSignature']).describe('TX signature is not valid')).or(zod.object({
  "NotEnoughBalance": zod.object({
  "balance": zod.string(),
  "cost": zod.string(),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account does not have enough balance to cover TX cost')).or(zod.object({
  "LackBalanceForState": zod.object({
  "amount": zod.string().describe('Required balance to cover the state.'),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which doesn\'t have enough balance to cover storage.')
})
}).describe('Signer account doesn\'t have enough balance after transaction.')).or(zod.enum(['CostOverflow']).describe('An integer overflow occurred during transaction cost estimation.')).or(zod.enum(['InvalidChain']).describe('Transaction parent block hash doesn\'t belong to the current chain')).or(zod.enum(['Expired']).describe('Transaction has expired')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMin),
  "total_prepaid_gas": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMin),
  "total_number_of_actions": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin),
  "total_number_of_bytes": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMin),
  "size": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMin)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin),
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMin)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of a Transaction.')).or(zod.object({
  "TransactionSizeExceeded": zod.object({
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededLimitMin),
  "size": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededSizeMin)
})
}).describe('The size of serialized transaction exceeded the limit.')).or(zod.enum(['InvalidTransactionVersion']).describe('Transaction version is invalid.')).or(zod.object({
  "StorageError": zod.enum(['StorageInternalError']).describe('Key-value db internal failure').or(zod.object({
  "MissingTrieValue": zod.object({
  "context": zod.enum(['TrieIterator']).describe('Missing trie value when reading from TrieIterator.').or(zod.enum(['TriePrefetchingStorage']).describe('Missing trie value when reading from TriePrefetchingStorage.')).or(zod.enum(['TrieMemoryPartialStorage']).describe('Missing trie value when reading from TrieMemoryPartialStorage.')).or(zod.enum(['TrieStorage']).describe('Missing trie value when reading from TrieStorage.')).describe('Contexts in which `StorageError::MissingTrieValue` error might occur.'),
  "hash": zod.string()
})
}).describe('Requested trie value by its hash which is missing in storage.')).or(zod.enum(['UnexpectedTrieValue']).describe('Found trie node which shouldn\'t be part of state. Raised during\n validation of state sync parts where incorrect node was passed.\n TODO (#8997): consider including hash of trie node.')).or(zod.object({
  "StorageInconsistentState": zod.string()
}).describe('Either invalid state or key-value db is corrupted.\n For PartialStorage it cannot be corrupted.\n Error message is unreliable and for debugging purposes only. It\'s also probably ok to\n panic in every place that produces this error.\n We can check if db is corrupted by verifying everything in the state trie.')).or(zod.object({
  "FlatStorageBlockNotSupported": zod.string()
}).describe('Flat storage error, meaning that it doesn\'t support some block anymore.\n We guarantee that such block cannot become final, thus block processing\n must resume normally.')).or(zod.object({
  "MemTrieLoadingError": zod.string()
}).describe('In-memory trie could not be loaded for some reason.')).describe('Errors which may occur during working with trie storages, storing\n trie values (trie nodes and state values) by their hashes.')
})).or(zod.object({
  "ShardCongested": zod.object({
  "congestion_level": zod.number().describe('A value between 0 (no congestion) and 1 (max congestion).'),
  "shard_id": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardCongestedShardIdMin).describe('The congested shard.')
})
}).describe('The receiver shard of the transaction is too congested to accept new\n transactions at the moment.')).or(zod.object({
  "ShardStuck": zod.object({
  "missed_chunks": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardStuckMissedChunksMin).describe('The number of blocks since the last included chunk of the shard.'),
  "shard_id": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardStuckShardIdMin).describe('The shard that fails making progress.')
})
}).describe('The receiver shard of the transaction missed several chunks and rejects\n new transaction until it can make progress again.')).describe('An error happened during TX execution')
}).describe('An error happened during Transaction execution')).describe('Error returned in the ExecutionOutcome in case of failure')
}).describe('The execution has failed.')).or(zod.object({
  "SuccessValue": zod.string()
}).describe('The final action succeeded and returned some value or an empty vec encoded in base64.')).or(zod.object({
  "SuccessReceiptId": zod.string()
}).describe('The final action of the receipt returned a promise or the signed transaction was converted\n to a receipt. Contains the receipt_id of the generated receipt.')).describe('Execution status. Contains the result in case of successful execution.'),
  "tokens_burnt": zod.string().describe('The amount of tokens burnt corresponding to the burnt gas amount.\n This value doesn\'t always equal to the `gas_burnt` multiplied by the gas price, because\n the prepaid gas price might be lower than the actual gas price and it creates a deficit.\n `tokens_burnt` also contains the penalty subtracted from refunds, while\n `gas_burnt` only contains the gas that we actually burn for the execution.')
}),
  "proof": zod.array(zod.object({
  "direction": zod.enum(['Left', 'Right']),
  "hash": zod.string()
}))
})).describe('The execution outcome of receipts.'),
  "status": zod.enum(['NotStarted']).describe('The execution has not yet started.').or(zod.enum(['Started']).describe('The execution has started and still going.')).or(zod.object({
  "Failure": zod.object({
  "ActionError": zod.object({
  "index": zod.number().min(txResponseResultStatusFailureActionErrorIndexMin).nullish().describe('Index of the failed action in the transaction.\n Action index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`'),
  "kind": zod.object({
  "AccountAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage').or(zod.object({
  "AccountDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when TX receiver_id doesn\'t exist (but action is not Action::CreateAccount)')).or(zod.object({
  "CreateAccountOnlyByRegistrar": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "registrar_account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A top-level account ID can only be created by registrar.')).or(zod.object({
  "CreateAccountNotAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A newly created account must be under a namespace of the creator account')).or(zod.object({
  "ActorNoPermission": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "actor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\n or the first TX action is a `CreateAccount` action')).or(zod.object({
  "DeleteKeyDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('Account tries to remove an access key that doesn\'t exist')).or(zod.object({
  "AddKeyAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The public key is already used for an existing access key')).or(zod.object({
  "DeleteAccountStaking": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is staking and can not be deleted')).or(zod.object({
  "LackBalanceForState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which needs balance'),
  "amount": zod.string().describe('Balance required to complete an action.')
})
}).describe('ActionReceipt can\'t be completed, because the remaining balance will not be enough to cover storage.')).or(zod.object({
  "TriesToUnstake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is not yet staked, but tries to unstake')).or(zod.object({
  "TriesToStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "balance": zod.string(),
  "locked": zod.string(),
  "stake": zod.string()
})
}).describe('The account doesn\'t have enough balance to increase the stake.')).or(zod.object({
  "InsufficientStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "minimum_stake": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "FunctionCallError": zod.enum(['WasmUnknownError', '_EVMError']).or(zod.object({
  "CompilationError": zod.object({
  "CodeDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).or(zod.object({
  "PrepareError": zod.enum(['Serialization']).describe('Error happened while serializing the module.').or(zod.enum(['Deserialization']).describe('Error happened while deserializing the module.')).or(zod.enum(['InternalMemoryDeclared']).describe('Internal memory declaration has been found in the module.')).or(zod.enum(['GasInstrumentation']).describe('Gas instrumentation failed.\n\n This most likely indicates the module isn\'t valid.')).or(zod.enum(['StackHeightInstrumentation']).describe('Stack instrumentation failed.\n\n This  most likely indicates the module isn\'t valid.')).or(zod.enum(['Instantiate']).describe('Error happened during instantiation.\n\n This might indicate that `start` function trapped, or module isn\'t\n instantiable and/or un-linkable.')).or(zod.enum(['Memory']).describe('Error creating memory.')).or(zod.enum(['TooManyFunctions']).describe('Contract contains too many functions.')).or(zod.enum(['TooManyLocals']).describe('Contract contains too many locals.')).describe('Error that can occur while preparing or executing Wasm smart-contract.')
})).or(zod.object({
  "WasmerCompileError": zod.object({
  "msg": zod.string()
})
}).describe('This is for defense in depth.\n We expect our runtime-independent preparation code to fully catch all invalid wasms,\n but, if it ever misses something we‚Äôll emit this error'))
}).describe('Wasm compilation error')).or(zod.object({
  "LinkError": zod.object({
  "msg": zod.string()
})
}).describe('Wasm binary env link error\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "MethodResolveError": zod.enum(['MethodEmptyName', 'MethodNotFound', 'MethodInvalidSignature'])
}).describe('Import/export resolve error')).or(zod.object({
  "WasmTrap": zod.enum(['Unreachable']).describe('An `unreachable` opcode was executed.').or(zod.enum(['IncorrectCallIndirectSignature']).describe('Call indirect incorrect signature trap.')).or(zod.enum(['MemoryOutOfBounds']).describe('Memory out of bounds trap.')).or(zod.enum(['CallIndirectOOB']).describe('Call indirect out of bounds trap.')).or(zod.enum(['IllegalArithmetic']).describe('An arithmetic exception, e.g. divided by zero.')).or(zod.enum(['MisalignedAtomicAccess']).describe('Misaligned atomic access trap.')).or(zod.enum(['IndirectCallToNull']).describe('Indirect call to null.')).or(zod.enum(['StackOverflow']).describe('Stack overflow.')).or(zod.enum(['GenericTrap']).describe('Generic trap.')).describe('A kind of a trap happened during execution of a binary')
}).describe('A trap happened during execution of a binary\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "HostError": zod.enum(['BadUTF16']).describe('String encoding is bad UTF-16 sequence').or(zod.enum(['BadUTF8']).describe('String encoding is bad UTF-8 sequence')).or(zod.enum(['GasExceeded']).describe('Exceeded the prepaid gas')).or(zod.enum(['GasLimitExceeded']).describe('Exceeded the maximum amount of gas allowed to burn per contract')).or(zod.enum(['BalanceExceeded']).describe('Exceeded the account balance')).or(zod.enum(['EmptyMethodName']).describe('Tried to call an empty method name')).or(zod.object({
  "GuestPanic": zod.object({
  "panic_msg": zod.string()
})
}).describe('Smart contract panicked')).or(zod.enum(['IntegerOverflow']).describe('IntegerOverflow happened during a contract execution')).or(zod.object({
  "InvalidPromiseIndex": zod.object({
  "promise_idx": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMin)
})
}).describe('`promise_idx` does not correspond to existing promises')).or(zod.enum(['CannotAppendActionToJointPromise']).describe('Actions can only be appended to non-joint promise.')).or(zod.enum(['CannotReturnJointPromise']).describe('Returning joint promise is currently prohibited')).or(zod.object({
  "InvalidPromiseResultIndex": zod.object({
  "result_idx": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMin)
})
}).describe('Accessed invalid promise result index')).or(zod.object({
  "InvalidRegisterId": zod.object({
  "register_id": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMin)
})
}).describe('Accessed invalid register id')).or(zod.object({
  "IteratorWasInvalidated": zod.object({
  "iterator_index": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMin)
})
}).describe('Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie')).or(zod.enum(['MemoryAccessViolation']).describe('Accessed memory outside the bounds')).or(zod.object({
  "InvalidReceiptIndex": zod.object({
  "receipt_index": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMin)
})
}).describe('VM Logic returned an invalid receipt index')).or(zod.object({
  "InvalidIteratorIndex": zod.object({
  "iterator_index": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMin)
})
}).describe('Iterator index `iterator_index` does not exist')).or(zod.enum(['InvalidAccountId']).describe('VM Logic returned an invalid account id')).or(zod.enum(['InvalidMethodName']).describe('VM Logic returned an invalid method name')).or(zod.enum(['InvalidPublicKey']).describe('VM Logic provided an invalid public key')).or(zod.object({
  "ProhibitedInView": zod.object({
  "method_name": zod.string()
})
}).describe('`method_name` is not allowed in view calls')).or(zod.object({
  "NumberOfLogsExceeded": zod.object({
  "limit": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMin)
})
}).describe('The total number of logs will exceed the limit.')).or(zod.object({
  "KeyLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMin),
  "limit": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMin)
})
}).describe('The storage key length exceeded the limit.')).or(zod.object({
  "ValueLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMin),
  "limit": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMin)
})
}).describe('The storage value length exceeded the limit.')).or(zod.object({
  "TotalLogLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMin),
  "limit": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMin)
})
}).describe('The total log length exceeded the limit.')).or(zod.object({
  "NumberPromisesExceeded": zod.object({
  "limit": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMin),
  "number_of_promises": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMin)
})
}).describe('The maximum number of promises within a FunctionCall exceeded the limit.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMin),
  "number_of_input_data_dependencies": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin)
})
}).describe('The maximum number of input data dependencies exceeded the limit.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMin),
  "limit": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMin)
})
}).describe('The returned value length exceeded the limit.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMin),
  "size": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMin)
})
}).describe('The contract size for DeployContract action exceeded the limit.')).or(zod.object({
  "Deprecated": zod.object({
  "method_name": zod.string()
})
}).describe('The host function was deprecated.')).or(zod.object({
  "ECRecoverError": zod.object({
  "msg": zod.string()
})
}).describe('General errors for ECDSA recover.')).or(zod.object({
  "AltBn128InvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to alt_bn128 family of functions (e.g., point which isn\'t\n on the curve).')).or(zod.object({
  "Ed25519VerifyInvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to ed25519 signature verification function (e.g. signature cannot be\n derived from bytes).'))
}).describe('Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "ExecutionError": zod.string()
})).describe('Serializable version of `near-vm-runner::FunctionCallError`.\n\n Must never reorder/remove elements, can only add new variants at the end (but do that very\n carefully). It describes stable serialization format, and only used by serialization logic.')
}).describe('An error occurred during a `FunctionCall` Action, parameter is debug message.')).or(zod.object({
  "NewReceiptValidationError": zod.object({
  "InvalidPredecessorId": zod.object({
  "account_id": zod.string()
})
}).describe('The `predecessor_id` of a Receipt is not valid.').or(zod.object({
  "InvalidReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a Receipt is not valid.')).or(zod.object({
  "InvalidSignerId": zod.object({
  "account_id": zod.string()
})
}).describe('The `signer_id` of an ActionReceipt is not valid.')).or(zod.object({
  "InvalidDataReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a DataReceiver within an ActionReceipt is not valid.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMin),
  "limit": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMin)
})
}).describe('The length of the returned data exceeded the limit in a DataReceipt.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMin),
  "number_of_input_data_dependencies": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin)
})
}).describe('The number of input data dependencies exceeds the limit in an ActionReceipt.')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMin),
  "total_prepaid_gas": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMin),
  "total_number_of_actions": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin),
  "total_number_of_bytes": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMin),
  "size": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMin)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin),
  "limit": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMin)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of an ActionReceipt.')).or(zod.object({
  "ReceiptSizeExceeded": zod.object({
  "limit": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMin),
  "size": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMin)
})
}).describe('Receipt is bigger than the limit.')).describe('Describes the error for validating a receipt.')
}).describe('Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\n receipt validation.')).or(zod.object({
  "OnlyImplicitAccountCreationAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\n See NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\n Also, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\n TODO(#8598): This error is named very poorly. A better name would be\n `OnlyNamedAccountCreationAllowed`.')).or(zod.object({
  "DeleteAccountWithLargeState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Delete account whose state is large is temporarily banned.')).or(zod.enum(['DelegateActionInvalidSignature']).describe('Signature does not match the provided actions and given signer public key.')).or(zod.object({
  "DelegateActionSenderDoesNotMatchTxReceiver": zod.object({
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Receiver of the transaction doesn\'t match Sender of the delegate action')).or(zod.enum(['DelegateActionExpired']).describe('Delegate action has expired. `max_block_height` is less than actual block height.')).or(zod.object({
  "DelegateActionAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('The given public key doesn\'t exist for Sender account')).or(zod.object({
  "DelegateActionInvalidNonce": zod.object({
  "ak_nonce": zod.number().min(txResponseResultStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMin),
  "delegate_nonce": zod.number().min(txResponseResultStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMin)
})
}).describe('DelegateAction nonce must be greater sender[public_key].nonce')).or(zod.object({
  "DelegateActionNonceTooLarge": zod.object({
  "delegate_nonce": zod.number().min(txResponseResultStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMin),
  "upper_bound": zod.number().min(txResponseResultStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMin)
})
}).describe('DelegateAction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "GlobalContractDoesNotExist": zod.object({
  "identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
})
})).describe('The kind of ActionError happened')
}).describe('An error happened during Action execution')
}).describe('An error happened during Action execution').or(zod.object({
  "InvalidTxError": zod.object({
  "InvalidAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('Happens if a wrong AccessKey used or AccessKey has not enough permissions').or(zod.object({
  "InvalidSignerId": zod.object({
  "signer_id": zod.string()
})
}).describe('TX signer_id is not a valid [`AccountId`]')).or(zod.object({
  "SignerDoesNotExist": zod.object({
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('TX signer_id is not found in a storage')).or(zod.object({
  "InvalidNonce": zod.object({
  "ak_nonce": zod.number().min(txResponseResultStatusFailureInvalidTxErrorInvalidNonceAkNonceMin),
  "tx_nonce": zod.number().min(txResponseResultStatusFailureInvalidTxErrorInvalidNonceTxNonceMin)
})
}).describe('Transaction nonce must be strictly greater than `account[access_key].nonce`.')).or(zod.object({
  "NonceTooLarge": zod.object({
  "tx_nonce": zod.number().min(txResponseResultStatusFailureInvalidTxErrorNonceTooLargeTxNonceMin),
  "upper_bound": zod.number().min(txResponseResultStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMin)
})
}).describe('Transaction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "InvalidReceiverId": zod.object({
  "receiver_id": zod.string()
})
}).describe('TX receiver_id is not a valid AccountId')).or(zod.enum(['InvalidSignature']).describe('TX signature is not valid')).or(zod.object({
  "NotEnoughBalance": zod.object({
  "balance": zod.string(),
  "cost": zod.string(),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account does not have enough balance to cover TX cost')).or(zod.object({
  "LackBalanceForState": zod.object({
  "amount": zod.string().describe('Required balance to cover the state.'),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which doesn\'t have enough balance to cover storage.')
})
}).describe('Signer account doesn\'t have enough balance after transaction.')).or(zod.enum(['CostOverflow']).describe('An integer overflow occurred during transaction cost estimation.')).or(zod.enum(['InvalidChain']).describe('Transaction parent block hash doesn\'t belong to the current chain')).or(zod.enum(['Expired']).describe('Transaction has expired')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(txResponseResultStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMin),
  "total_prepaid_gas": zod.number().min(txResponseResultStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(txResponseResultStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMin),
  "total_number_of_actions": zod.number().min(txResponseResultStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(txResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin),
  "total_number_of_bytes": zod.number().min(txResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(txResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(txResponseResultStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMin),
  "size": zod.number().min(txResponseResultStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMin)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(txResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin),
  "limit": zod.number().min(txResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(txResponseResultStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMin)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of a Transaction.')).or(zod.object({
  "TransactionSizeExceeded": zod.object({
  "limit": zod.number().min(txResponseResultStatusFailureInvalidTxErrorTransactionSizeExceededLimitMin),
  "size": zod.number().min(txResponseResultStatusFailureInvalidTxErrorTransactionSizeExceededSizeMin)
})
}).describe('The size of serialized transaction exceeded the limit.')).or(zod.enum(['InvalidTransactionVersion']).describe('Transaction version is invalid.')).or(zod.object({
  "StorageError": zod.enum(['StorageInternalError']).describe('Key-value db internal failure').or(zod.object({
  "MissingTrieValue": zod.object({
  "context": zod.enum(['TrieIterator']).describe('Missing trie value when reading from TrieIterator.').or(zod.enum(['TriePrefetchingStorage']).describe('Missing trie value when reading from TriePrefetchingStorage.')).or(zod.enum(['TrieMemoryPartialStorage']).describe('Missing trie value when reading from TrieMemoryPartialStorage.')).or(zod.enum(['TrieStorage']).describe('Missing trie value when reading from TrieStorage.')).describe('Contexts in which `StorageError::MissingTrieValue` error might occur.'),
  "hash": zod.string()
})
}).describe('Requested trie value by its hash which is missing in storage.')).or(zod.enum(['UnexpectedTrieValue']).describe('Found trie node which shouldn\'t be part of state. Raised during\n validation of state sync parts where incorrect node was passed.\n TODO (#8997): consider including hash of trie node.')).or(zod.object({
  "StorageInconsistentState": zod.string()
}).describe('Either invalid state or key-value db is corrupted.\n For PartialStorage it cannot be corrupted.\n Error message is unreliable and for debugging purposes only. It\'s also probably ok to\n panic in every place that produces this error.\n We can check if db is corrupted by verifying everything in the state trie.')).or(zod.object({
  "FlatStorageBlockNotSupported": zod.string()
}).describe('Flat storage error, meaning that it doesn\'t support some block anymore.\n We guarantee that such block cannot become final, thus block processing\n must resume normally.')).or(zod.object({
  "MemTrieLoadingError": zod.string()
}).describe('In-memory trie could not be loaded for some reason.')).describe('Errors which may occur during working with trie storages, storing\n trie values (trie nodes and state values) by their hashes.')
})).or(zod.object({
  "ShardCongested": zod.object({
  "congestion_level": zod.number().describe('A value between 0 (no congestion) and 1 (max congestion).'),
  "shard_id": zod.number().min(txResponseResultStatusFailureInvalidTxErrorShardCongestedShardIdMin).describe('The congested shard.')
})
}).describe('The receiver shard of the transaction is too congested to accept new\n transactions at the moment.')).or(zod.object({
  "ShardStuck": zod.object({
  "missed_chunks": zod.number().min(txResponseResultStatusFailureInvalidTxErrorShardStuckMissedChunksMin).describe('The number of blocks since the last included chunk of the shard.'),
  "shard_id": zod.number().min(txResponseResultStatusFailureInvalidTxErrorShardStuckShardIdMin).describe('The shard that fails making progress.')
})
}).describe('The receiver shard of the transaction missed several chunks and rejects\n new transaction until it can make progress again.')).describe('An error happened during TX execution')
}).describe('An error happened during Transaction execution')).describe('Error returned in the ExecutionOutcome in case of failure')
}).describe('The execution has failed with the given error.')).or(zod.object({
  "SuccessValue": zod.string()
}).describe('The execution has succeeded and returned some value or an empty vec encoded in base64.')).describe('Execution status defined by chain.rs:get_final_transaction_result\n FinalExecutionStatus::NotStarted - the tx is not converted to the receipt yet\n FinalExecutionStatus::Started - we have at least 1 receipt, but the first leaf receipt_id (using dfs) hasn\'t finished the execution\n FinalExecutionStatus::Failure - the result of the first leaf receipt_id\n FinalExecutionStatus::SuccessValue - the result of the first leaf receipt_id'),
  "transaction": zod.object({
  "actions": zod.array(zod.enum(['CreateAccount']).or(zod.object({
  "DeployContract": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "FunctionCall": zod.object({
  "args": zod.string(),
  "deposit": zod.string(),
  "gas": zod.number().min(txResponseResultTransactionActionsItemFunctionCallGasMin),
  "method_name": zod.string()
})
})).or(zod.object({
  "Transfer": zod.object({
  "deposit": zod.string()
})
})).or(zod.object({
  "Stake": zod.object({
  "public_key": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "AddKey": zod.object({
  "access_key": zod.object({
  "nonce": zod.number().min(txResponseResultTransactionActionsItemAddKeyAccessKeyNonceMin),
  "permission": zod.enum(['FullAccess']).or(zod.object({
  "FunctionCall": zod.object({
  "allowance": zod.string().nullish(),
  "method_names": zod.array(zod.string()),
  "receiver_id": zod.string()
})
}))
}),
  "public_key": zod.string()
})
})).or(zod.object({
  "DeleteKey": zod.object({
  "public_key": zod.string()
})
})).or(zod.object({
  "DeleteAccount": zod.object({
  "beneficiary_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
})).or(zod.object({
  "Delegate": zod.object({
  "delegate_action": zod.object({
  "actions": zod.array(zod.object({
  "CreateAccount": zod.object({

}).describe('Create account action')
}).describe('Create an (sub)account using a transaction `receiver_id` as an ID for\n a new account ID must pass validation rules described here\n <http://nomicon.io/Primitives/Account.html>.').or(zod.object({
  "DeployContract": zod.object({
  "code": zod.string().describe('WebAssembly binary')
}).describe('Deploy contract action')
}).describe('Sets a Wasm code to a receiver_id')).or(zod.object({
  "FunctionCall": zod.object({
  "args": zod.string(),
  "deposit": zod.string(),
  "gas": zod.number().min(txResponseResultTransactionActionsItemDelegateDelegateActionActionsItemFunctionCallGasMin),
  "method_name": zod.string()
})
})).or(zod.object({
  "Transfer": zod.object({
  "deposit": zod.string()
})
})).or(zod.object({
  "Stake": zod.object({
  "public_key": zod.string().describe('Validator key which will be used to sign transactions on behalf of signer_id'),
  "stake": zod.string().describe('Amount of tokens to stake.')
}).describe('An action which stakes signer_id tokens and setup\'s validator public key')
})).or(zod.object({
  "AddKey": zod.object({
  "access_key": zod.object({
  "nonce": zod.number().min(txResponseResultTransactionActionsItemDelegateDelegateActionActionsItemAddKeyAccessKeyNonceMin).describe('Nonce for this access key, used for tx nonce generation. When access key is created, nonce\n is set to `(block_height - 1) * 1e6` to avoid tx hash collision on access key re-creation.\n See <https://github.com/near/nearcore/issues/3779> for more details.'),
  "permission": zod.object({
  "FunctionCall": zod.object({
  "allowance": zod.string().nullish().describe('Allowance is a balance limit to use by this access key to pay for function call gas and\n transaction fees. When this access key is used, both account balance and the allowance is\n decreased by the same value.\n `None` means unlimited allowance.\n NOTE: To change or increase the allowance, the old access key needs to be deleted and a new\n access key should be created.'),
  "method_names": zod.array(zod.string()).describe('A list of method names that can be used. The access key only allows transactions with the\n function call of one of the given method names.\n Empty list means any method name can be used.'),
  "receiver_id": zod.string().describe('The access key only allows transactions with the given receiver\'s account id.')
}).describe('Grants limited permission to make transactions with FunctionCallActions\n The permission can limit the allowed balance to be spent on the prepaid gas.\n It also restrict the account ID of the receiver for this function call.\n It also can restrict the method name for the allowed function calls.')
}).or(zod.enum(['FullAccess']).describe('Grants full access to the account.\n NOTE: It\'s used to replace account-level public keys.')).describe('Defines permissions for AccessKey').describe('Defines permissions for this access key.')
}).describe('Access key provides limited access to an account. Each access key belongs to some account and\n is identified by a unique (within the account) public key. One account may have large number of\n access keys. Access keys allow to act on behalf of the account by restricting transactions\n that can be issued.\n `account_id,public_key` is a key in the state').describe('An access key with the permission'),
  "public_key": zod.string().describe('A public key which will be associated with an access_key')
})
})).or(zod.object({
  "DeleteKey": zod.object({
  "public_key": zod.string().describe('A public key associated with the access_key to be deleted.')
})
})).or(zod.object({
  "DeleteAccount": zod.object({
  "beneficiary_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
})).or(zod.object({
  "Delegate": zod.object({
  "delegate_action": zod.any(),
  "signature": zod.string()
})
})).or(zod.object({
  "DeployGlobalContract": zod.object({
  "code": zod.string().describe('WebAssembly binary'),
  "deploy_mode": zod.enum(['CodeHash']).describe('Contract is deployed under its code hash.\n Users will be able reference it by that hash.\n This effectively makes the contract immutable.').or(zod.enum(['AccountId']).describe('Contract is deployed under the owner account id.\n Users will be able reference it by that account id.\n This allows the owner to update the contract for all its users.'))
}).describe('Deploy global contract action')
})).or(zod.object({
  "UseGlobalContract": zod.object({
  "contract_identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
}).describe('Use global contract action')
})).describe('This is Action which mustn\'t contain DelegateAction.\n\n This struct is needed to avoid the recursion when Action/DelegateAction is deserialized.\n\n Important: Don\'t make the inner Action public, this must only be constructed\n through the correct interface that ensures the inner Action is actually not\n a delegate action. That would break an assumption of this type, which we use\n in several places. For example, borsh de-/serialization relies on it. If the\n invariant is broken, we may end up with a `Transaction` or `Receipt` that we\n can serialize but deserializing it back causes a parsing error.')).describe('List of actions to be executed.\n\n With the meta transactions MVP defined in NEP-366, nested\n DelegateActions are not allowed. A separate type is used to enforce it.'),
  "max_block_height": zod.number().min(txResponseResultTransactionActionsItemDelegateDelegateActionMaxBlockHeightMin).describe('The maximal height of the block in the blockchain below which the given DelegateAction is valid.'),
  "nonce": zod.number().min(txResponseResultTransactionActionsItemDelegateDelegateActionNonceMin).describe('Nonce to ensure that the same delegate action is not sent twice by a\n relayer and should match for given account\'s `public_key`.\n After this action is processed it will increment.'),
  "public_key": zod.string().describe('Public key used to sign this delegated action.'),
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('Receiver of the delegated actions.'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('Signer of the delegated actions')
}).describe('This action allows to execute the inner actions behalf of the defined sender.'),
  "signature": zod.string()
})
})).or(zod.object({
  "DeployGlobalContract": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "DeployGlobalContractByAccountId": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "UseGlobalContract": zod.object({
  "code_hash": zod.string()
})
})).or(zod.object({
  "UseGlobalContractByAccountId": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}))),
  "hash": zod.string(),
  "nonce": zod.number().min(txResponseResultTransactionNonceMin),
  "priority_fee": zod.number().min(txResponseResultTransactionPriorityFeeMin).optional(),
  "public_key": zod.string(),
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "signature": zod.string(),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}).describe('Signed Transaction'),
  "transaction_outcome": zod.object({
  "block_hash": zod.string(),
  "id": zod.string(),
  "outcome": zod.object({
  "executor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('The id of the account on which the execution happens. For transaction this is signer_id,\n for receipt this is receiver_id.'),
  "gas_burnt": zod.number().min(txResponseResultTransactionOutcomeOutcomeGasBurntMin).describe('The amount of the gas burnt by the given transaction or receipt.'),
  "logs": zod.array(zod.string()).describe('Logs from this transaction or receipt.'),
  "metadata": zod.object({
  "gas_profile": zod.array(zod.object({
  "cost": zod.string(),
  "cost_category": zod.string(),
  "gas_used": zod.string()
})).nullish(),
  "version": zod.number().min(txResponseResultTransactionOutcomeOutcomeMetadataVersionMin)
}).default(txResponseResultTransactionOutcomeOutcomeMetadataDefault).describe('Execution metadata, versioned'),
  "receipt_ids": zod.array(zod.string()).describe('Receipt IDs generated by this transaction or receipt.'),
  "status": zod.enum(['Unknown']).describe('The execution is pending or unknown.').or(zod.object({
  "Failure": zod.object({
  "ActionError": zod.object({
  "index": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorIndexMin).nullish().describe('Index of the failed action in the transaction.\n Action index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`'),
  "kind": zod.object({
  "AccountAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage').or(zod.object({
  "AccountDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when TX receiver_id doesn\'t exist (but action is not Action::CreateAccount)')).or(zod.object({
  "CreateAccountOnlyByRegistrar": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "registrar_account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A top-level account ID can only be created by registrar.')).or(zod.object({
  "CreateAccountNotAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A newly created account must be under a namespace of the creator account')).or(zod.object({
  "ActorNoPermission": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "actor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\n or the first TX action is a `CreateAccount` action')).or(zod.object({
  "DeleteKeyDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('Account tries to remove an access key that doesn\'t exist')).or(zod.object({
  "AddKeyAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The public key is already used for an existing access key')).or(zod.object({
  "DeleteAccountStaking": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is staking and can not be deleted')).or(zod.object({
  "LackBalanceForState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which needs balance'),
  "amount": zod.string().describe('Balance required to complete an action.')
})
}).describe('ActionReceipt can\'t be completed, because the remaining balance will not be enough to cover storage.')).or(zod.object({
  "TriesToUnstake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is not yet staked, but tries to unstake')).or(zod.object({
  "TriesToStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "balance": zod.string(),
  "locked": zod.string(),
  "stake": zod.string()
})
}).describe('The account doesn\'t have enough balance to increase the stake.')).or(zod.object({
  "InsufficientStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "minimum_stake": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "FunctionCallError": zod.enum(['WasmUnknownError', '_EVMError']).or(zod.object({
  "CompilationError": zod.object({
  "CodeDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).or(zod.object({
  "PrepareError": zod.enum(['Serialization']).describe('Error happened while serializing the module.').or(zod.enum(['Deserialization']).describe('Error happened while deserializing the module.')).or(zod.enum(['InternalMemoryDeclared']).describe('Internal memory declaration has been found in the module.')).or(zod.enum(['GasInstrumentation']).describe('Gas instrumentation failed.\n\n This most likely indicates the module isn\'t valid.')).or(zod.enum(['StackHeightInstrumentation']).describe('Stack instrumentation failed.\n\n This  most likely indicates the module isn\'t valid.')).or(zod.enum(['Instantiate']).describe('Error happened during instantiation.\n\n This might indicate that `start` function trapped, or module isn\'t\n instantiable and/or un-linkable.')).or(zod.enum(['Memory']).describe('Error creating memory.')).or(zod.enum(['TooManyFunctions']).describe('Contract contains too many functions.')).or(zod.enum(['TooManyLocals']).describe('Contract contains too many locals.')).describe('Error that can occur while preparing or executing Wasm smart-contract.')
})).or(zod.object({
  "WasmerCompileError": zod.object({
  "msg": zod.string()
})
}).describe('This is for defense in depth.\n We expect our runtime-independent preparation code to fully catch all invalid wasms,\n but, if it ever misses something we‚Äôll emit this error'))
}).describe('Wasm compilation error')).or(zod.object({
  "LinkError": zod.object({
  "msg": zod.string()
})
}).describe('Wasm binary env link error\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "MethodResolveError": zod.enum(['MethodEmptyName', 'MethodNotFound', 'MethodInvalidSignature'])
}).describe('Import/export resolve error')).or(zod.object({
  "WasmTrap": zod.enum(['Unreachable']).describe('An `unreachable` opcode was executed.').or(zod.enum(['IncorrectCallIndirectSignature']).describe('Call indirect incorrect signature trap.')).or(zod.enum(['MemoryOutOfBounds']).describe('Memory out of bounds trap.')).or(zod.enum(['CallIndirectOOB']).describe('Call indirect out of bounds trap.')).or(zod.enum(['IllegalArithmetic']).describe('An arithmetic exception, e.g. divided by zero.')).or(zod.enum(['MisalignedAtomicAccess']).describe('Misaligned atomic access trap.')).or(zod.enum(['IndirectCallToNull']).describe('Indirect call to null.')).or(zod.enum(['StackOverflow']).describe('Stack overflow.')).or(zod.enum(['GenericTrap']).describe('Generic trap.')).describe('A kind of a trap happened during execution of a binary')
}).describe('A trap happened during execution of a binary\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "HostError": zod.enum(['BadUTF16']).describe('String encoding is bad UTF-16 sequence').or(zod.enum(['BadUTF8']).describe('String encoding is bad UTF-8 sequence')).or(zod.enum(['GasExceeded']).describe('Exceeded the prepaid gas')).or(zod.enum(['GasLimitExceeded']).describe('Exceeded the maximum amount of gas allowed to burn per contract')).or(zod.enum(['BalanceExceeded']).describe('Exceeded the account balance')).or(zod.enum(['EmptyMethodName']).describe('Tried to call an empty method name')).or(zod.object({
  "GuestPanic": zod.object({
  "panic_msg": zod.string()
})
}).describe('Smart contract panicked')).or(zod.enum(['IntegerOverflow']).describe('IntegerOverflow happened during a contract execution')).or(zod.object({
  "InvalidPromiseIndex": zod.object({
  "promise_idx": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMin)
})
}).describe('`promise_idx` does not correspond to existing promises')).or(zod.enum(['CannotAppendActionToJointPromise']).describe('Actions can only be appended to non-joint promise.')).or(zod.enum(['CannotReturnJointPromise']).describe('Returning joint promise is currently prohibited')).or(zod.object({
  "InvalidPromiseResultIndex": zod.object({
  "result_idx": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMin)
})
}).describe('Accessed invalid promise result index')).or(zod.object({
  "InvalidRegisterId": zod.object({
  "register_id": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMin)
})
}).describe('Accessed invalid register id')).or(zod.object({
  "IteratorWasInvalidated": zod.object({
  "iterator_index": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMin)
})
}).describe('Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie')).or(zod.enum(['MemoryAccessViolation']).describe('Accessed memory outside the bounds')).or(zod.object({
  "InvalidReceiptIndex": zod.object({
  "receipt_index": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMin)
})
}).describe('VM Logic returned an invalid receipt index')).or(zod.object({
  "InvalidIteratorIndex": zod.object({
  "iterator_index": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMin)
})
}).describe('Iterator index `iterator_index` does not exist')).or(zod.enum(['InvalidAccountId']).describe('VM Logic returned an invalid account id')).or(zod.enum(['InvalidMethodName']).describe('VM Logic returned an invalid method name')).or(zod.enum(['InvalidPublicKey']).describe('VM Logic provided an invalid public key')).or(zod.object({
  "ProhibitedInView": zod.object({
  "method_name": zod.string()
})
}).describe('`method_name` is not allowed in view calls')).or(zod.object({
  "NumberOfLogsExceeded": zod.object({
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMin)
})
}).describe('The total number of logs will exceed the limit.')).or(zod.object({
  "KeyLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMin),
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMin)
})
}).describe('The storage key length exceeded the limit.')).or(zod.object({
  "ValueLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMin),
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMin)
})
}).describe('The storage value length exceeded the limit.')).or(zod.object({
  "TotalLogLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMin),
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMin)
})
}).describe('The total log length exceeded the limit.')).or(zod.object({
  "NumberPromisesExceeded": zod.object({
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMin),
  "number_of_promises": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMin)
})
}).describe('The maximum number of promises within a FunctionCall exceeded the limit.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMin),
  "number_of_input_data_dependencies": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin)
})
}).describe('The maximum number of input data dependencies exceeded the limit.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMin),
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMin)
})
}).describe('The returned value length exceeded the limit.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMin),
  "size": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMin)
})
}).describe('The contract size for DeployContract action exceeded the limit.')).or(zod.object({
  "Deprecated": zod.object({
  "method_name": zod.string()
})
}).describe('The host function was deprecated.')).or(zod.object({
  "ECRecoverError": zod.object({
  "msg": zod.string()
})
}).describe('General errors for ECDSA recover.')).or(zod.object({
  "AltBn128InvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to alt_bn128 family of functions (e.g., point which isn\'t\n on the curve).')).or(zod.object({
  "Ed25519VerifyInvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to ed25519 signature verification function (e.g. signature cannot be\n derived from bytes).'))
}).describe('Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "ExecutionError": zod.string()
})).describe('Serializable version of `near-vm-runner::FunctionCallError`.\n\n Must never reorder/remove elements, can only add new variants at the end (but do that very\n carefully). It describes stable serialization format, and only used by serialization logic.')
}).describe('An error occurred during a `FunctionCall` Action, parameter is debug message.')).or(zod.object({
  "NewReceiptValidationError": zod.object({
  "InvalidPredecessorId": zod.object({
  "account_id": zod.string()
})
}).describe('The `predecessor_id` of a Receipt is not valid.').or(zod.object({
  "InvalidReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a Receipt is not valid.')).or(zod.object({
  "InvalidSignerId": zod.object({
  "account_id": zod.string()
})
}).describe('The `signer_id` of an ActionReceipt is not valid.')).or(zod.object({
  "InvalidDataReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a DataReceiver within an ActionReceipt is not valid.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMin),
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMin)
})
}).describe('The length of the returned data exceeded the limit in a DataReceipt.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMin),
  "number_of_input_data_dependencies": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMin)
})
}).describe('The number of input data dependencies exceeds the limit in an ActionReceipt.')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMin),
  "total_prepaid_gas": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMin),
  "total_number_of_actions": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin),
  "total_number_of_bytes": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMin),
  "size": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMin)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin),
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMin)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of an ActionReceipt.')).or(zod.object({
  "ReceiptSizeExceeded": zod.object({
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMin),
  "size": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMin)
})
}).describe('Receipt is bigger than the limit.')).describe('Describes the error for validating a receipt.')
}).describe('Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\n receipt validation.')).or(zod.object({
  "OnlyImplicitAccountCreationAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\n See NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\n Also, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\n TODO(#8598): This error is named very poorly. A better name would be\n `OnlyNamedAccountCreationAllowed`.')).or(zod.object({
  "DeleteAccountWithLargeState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Delete account whose state is large is temporarily banned.')).or(zod.enum(['DelegateActionInvalidSignature']).describe('Signature does not match the provided actions and given signer public key.')).or(zod.object({
  "DelegateActionSenderDoesNotMatchTxReceiver": zod.object({
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Receiver of the transaction doesn\'t match Sender of the delegate action')).or(zod.enum(['DelegateActionExpired']).describe('Delegate action has expired. `max_block_height` is less than actual block height.')).or(zod.object({
  "DelegateActionAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('The given public key doesn\'t exist for Sender account')).or(zod.object({
  "DelegateActionInvalidNonce": zod.object({
  "ak_nonce": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMin),
  "delegate_nonce": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMin)
})
}).describe('DelegateAction nonce must be greater sender[public_key].nonce')).or(zod.object({
  "DelegateActionNonceTooLarge": zod.object({
  "delegate_nonce": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMin),
  "upper_bound": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMin)
})
}).describe('DelegateAction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "GlobalContractDoesNotExist": zod.object({
  "identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
})
})).describe('The kind of ActionError happened')
}).describe('An error happened during Action execution')
}).describe('An error happened during Action execution').or(zod.object({
  "InvalidTxError": zod.object({
  "InvalidAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('Happens if a wrong AccessKey used or AccessKey has not enough permissions').or(zod.object({
  "InvalidSignerId": zod.object({
  "signer_id": zod.string()
})
}).describe('TX signer_id is not a valid [`AccountId`]')).or(zod.object({
  "SignerDoesNotExist": zod.object({
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('TX signer_id is not found in a storage')).or(zod.object({
  "InvalidNonce": zod.object({
  "ak_nonce": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorInvalidNonceAkNonceMin),
  "tx_nonce": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorInvalidNonceTxNonceMin)
})
}).describe('Transaction nonce must be strictly greater than `account[access_key].nonce`.')).or(zod.object({
  "NonceTooLarge": zod.object({
  "tx_nonce": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorNonceTooLargeTxNonceMin),
  "upper_bound": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMin)
})
}).describe('Transaction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "InvalidReceiverId": zod.object({
  "receiver_id": zod.string()
})
}).describe('TX receiver_id is not a valid AccountId')).or(zod.enum(['InvalidSignature']).describe('TX signature is not valid')).or(zod.object({
  "NotEnoughBalance": zod.object({
  "balance": zod.string(),
  "cost": zod.string(),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account does not have enough balance to cover TX cost')).or(zod.object({
  "LackBalanceForState": zod.object({
  "amount": zod.string().describe('Required balance to cover the state.'),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which doesn\'t have enough balance to cover storage.')
})
}).describe('Signer account doesn\'t have enough balance after transaction.')).or(zod.enum(['CostOverflow']).describe('An integer overflow occurred during transaction cost estimation.')).or(zod.enum(['InvalidChain']).describe('Transaction parent block hash doesn\'t belong to the current chain')).or(zod.enum(['Expired']).describe('Transaction has expired')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMin),
  "total_prepaid_gas": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMin)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMin),
  "total_number_of_actions": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMin)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMin),
  "total_number_of_bytes": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMin)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMin)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMin),
  "size": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMin)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMin),
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMin)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMin),
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMin)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMin)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of a Transaction.')).or(zod.object({
  "TransactionSizeExceeded": zod.object({
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededLimitMin),
  "size": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededSizeMin)
})
}).describe('The size of serialized transaction exceeded the limit.')).or(zod.enum(['InvalidTransactionVersion']).describe('Transaction version is invalid.')).or(zod.object({
  "StorageError": zod.enum(['StorageInternalError']).describe('Key-value db internal failure').or(zod.object({
  "MissingTrieValue": zod.object({
  "context": zod.enum(['TrieIterator']).describe('Missing trie value when reading from TrieIterator.').or(zod.enum(['TriePrefetchingStorage']).describe('Missing trie value when reading from TriePrefetchingStorage.')).or(zod.enum(['TrieMemoryPartialStorage']).describe('Missing trie value when reading from TrieMemoryPartialStorage.')).or(zod.enum(['TrieStorage']).describe('Missing trie value when reading from TrieStorage.')).describe('Contexts in which `StorageError::MissingTrieValue` error might occur.'),
  "hash": zod.string()
})
}).describe('Requested trie value by its hash which is missing in storage.')).or(zod.enum(['UnexpectedTrieValue']).describe('Found trie node which shouldn\'t be part of state. Raised during\n validation of state sync parts where incorrect node was passed.\n TODO (#8997): consider including hash of trie node.')).or(zod.object({
  "StorageInconsistentState": zod.string()
}).describe('Either invalid state or key-value db is corrupted.\n For PartialStorage it cannot be corrupted.\n Error message is unreliable and for debugging purposes only. It\'s also probably ok to\n panic in every place that produces this error.\n We can check if db is corrupted by verifying everything in the state trie.')).or(zod.object({
  "FlatStorageBlockNotSupported": zod.string()
}).describe('Flat storage error, meaning that it doesn\'t support some block anymore.\n We guarantee that such block cannot become final, thus block processing\n must resume normally.')).or(zod.object({
  "MemTrieLoadingError": zod.string()
}).describe('In-memory trie could not be loaded for some reason.')).describe('Errors which may occur during working with trie storages, storing\n trie values (trie nodes and state values) by their hashes.')
})).or(zod.object({
  "ShardCongested": zod.object({
  "congestion_level": zod.number().describe('A value between 0 (no congestion) and 1 (max congestion).'),
  "shard_id": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardCongestedShardIdMin).describe('The congested shard.')
})
}).describe('The receiver shard of the transaction is too congested to accept new\n transactions at the moment.')).or(zod.object({
  "ShardStuck": zod.object({
  "missed_chunks": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardStuckMissedChunksMin).describe('The number of blocks since the last included chunk of the shard.'),
  "shard_id": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardStuckShardIdMin).describe('The shard that fails making progress.')
})
}).describe('The receiver shard of the transaction missed several chunks and rejects\n new transaction until it can make progress again.')).describe('An error happened during TX execution')
}).describe('An error happened during Transaction execution')).describe('Error returned in the ExecutionOutcome in case of failure')
}).describe('The execution has failed.')).or(zod.object({
  "SuccessValue": zod.string()
}).describe('The final action succeeded and returned some value or an empty vec encoded in base64.')).or(zod.object({
  "SuccessReceiptId": zod.string()
}).describe('The final action of the receipt returned a promise or the signed transaction was converted\n to a receipt. Contains the receipt_id of the generated receipt.')).describe('Execution status. Contains the result in case of successful execution.'),
  "tokens_burnt": zod.string().describe('The amount of tokens burnt corresponding to the burnt gas amount.\n This value doesn\'t always equal to the `gas_burnt` multiplied by the gas price, because\n the prepaid gas price might be lower than the actual gas price and it creates a deficit.\n `tokens_burnt` also contains the penalty subtracted from refunds, while\n `gas_burnt` only contains the gas that we actually burn for the execution.')
}),
  "proof": zod.array(zod.object({
  "direction": zod.enum(['Left', 'Right']),
  "hash": zod.string()
}))
}).describe('The execution outcome of the signed transaction.')
}).describe('Final execution outcome of the transaction and all of subsequent the receipts. Also includes\n the generated receipt.').or(zod.object({
  "receipts_outcome": zod.array(zod.object({
  "block_hash": zod.string(),
  "id": zod.string(),
  "outcome": zod.object({
  "executor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('The id of the account on which the execution happens. For transaction this is signer_id,\n for receipt this is receiver_id.'),
  "gas_burnt": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeGasBurntMinOne).describe('The amount of the gas burnt by the given transaction or receipt.'),
  "logs": zod.array(zod.string()).describe('Logs from this transaction or receipt.'),
  "metadata": zod.object({
  "gas_profile": zod.array(zod.object({
  "cost": zod.string(),
  "cost_category": zod.string(),
  "gas_used": zod.string()
})).nullish(),
  "version": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeMetadataVersionMinOne)
}).default(txResponseResultReceiptsOutcomeItemOutcomeMetadataDefaultTwo).describe('Execution metadata, versioned'),
  "receipt_ids": zod.array(zod.string()).describe('Receipt IDs generated by this transaction or receipt.'),
  "status": zod.enum(['Unknown']).describe('The execution is pending or unknown.').or(zod.object({
  "Failure": zod.object({
  "ActionError": zod.object({
  "index": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorIndexMinOne).nullish().describe('Index of the failed action in the transaction.\n Action index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`'),
  "kind": zod.object({
  "AccountAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage').or(zod.object({
  "AccountDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when TX receiver_id doesn\'t exist (but action is not Action::CreateAccount)')).or(zod.object({
  "CreateAccountOnlyByRegistrar": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "registrar_account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A top-level account ID can only be created by registrar.')).or(zod.object({
  "CreateAccountNotAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A newly created account must be under a namespace of the creator account')).or(zod.object({
  "ActorNoPermission": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "actor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\n or the first TX action is a `CreateAccount` action')).or(zod.object({
  "DeleteKeyDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('Account tries to remove an access key that doesn\'t exist')).or(zod.object({
  "AddKeyAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The public key is already used for an existing access key')).or(zod.object({
  "DeleteAccountStaking": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is staking and can not be deleted')).or(zod.object({
  "LackBalanceForState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which needs balance'),
  "amount": zod.string().describe('Balance required to complete an action.')
})
}).describe('ActionReceipt can\'t be completed, because the remaining balance will not be enough to cover storage.')).or(zod.object({
  "TriesToUnstake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is not yet staked, but tries to unstake')).or(zod.object({
  "TriesToStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "balance": zod.string(),
  "locked": zod.string(),
  "stake": zod.string()
})
}).describe('The account doesn\'t have enough balance to increase the stake.')).or(zod.object({
  "InsufficientStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "minimum_stake": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "FunctionCallError": zod.enum(['WasmUnknownError', '_EVMError']).or(zod.object({
  "CompilationError": zod.object({
  "CodeDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).or(zod.object({
  "PrepareError": zod.enum(['Serialization']).describe('Error happened while serializing the module.').or(zod.enum(['Deserialization']).describe('Error happened while deserializing the module.')).or(zod.enum(['InternalMemoryDeclared']).describe('Internal memory declaration has been found in the module.')).or(zod.enum(['GasInstrumentation']).describe('Gas instrumentation failed.\n\n This most likely indicates the module isn\'t valid.')).or(zod.enum(['StackHeightInstrumentation']).describe('Stack instrumentation failed.\n\n This  most likely indicates the module isn\'t valid.')).or(zod.enum(['Instantiate']).describe('Error happened during instantiation.\n\n This might indicate that `start` function trapped, or module isn\'t\n instantiable and/or un-linkable.')).or(zod.enum(['Memory']).describe('Error creating memory.')).or(zod.enum(['TooManyFunctions']).describe('Contract contains too many functions.')).or(zod.enum(['TooManyLocals']).describe('Contract contains too many locals.')).describe('Error that can occur while preparing or executing Wasm smart-contract.')
})).or(zod.object({
  "WasmerCompileError": zod.object({
  "msg": zod.string()
})
}).describe('This is for defense in depth.\n We expect our runtime-independent preparation code to fully catch all invalid wasms,\n but, if it ever misses something we‚Äôll emit this error'))
}).describe('Wasm compilation error')).or(zod.object({
  "LinkError": zod.object({
  "msg": zod.string()
})
}).describe('Wasm binary env link error\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "MethodResolveError": zod.enum(['MethodEmptyName', 'MethodNotFound', 'MethodInvalidSignature'])
}).describe('Import/export resolve error')).or(zod.object({
  "WasmTrap": zod.enum(['Unreachable']).describe('An `unreachable` opcode was executed.').or(zod.enum(['IncorrectCallIndirectSignature']).describe('Call indirect incorrect signature trap.')).or(zod.enum(['MemoryOutOfBounds']).describe('Memory out of bounds trap.')).or(zod.enum(['CallIndirectOOB']).describe('Call indirect out of bounds trap.')).or(zod.enum(['IllegalArithmetic']).describe('An arithmetic exception, e.g. divided by zero.')).or(zod.enum(['MisalignedAtomicAccess']).describe('Misaligned atomic access trap.')).or(zod.enum(['IndirectCallToNull']).describe('Indirect call to null.')).or(zod.enum(['StackOverflow']).describe('Stack overflow.')).or(zod.enum(['GenericTrap']).describe('Generic trap.')).describe('A kind of a trap happened during execution of a binary')
}).describe('A trap happened during execution of a binary\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "HostError": zod.enum(['BadUTF16']).describe('String encoding is bad UTF-16 sequence').or(zod.enum(['BadUTF8']).describe('String encoding is bad UTF-8 sequence')).or(zod.enum(['GasExceeded']).describe('Exceeded the prepaid gas')).or(zod.enum(['GasLimitExceeded']).describe('Exceeded the maximum amount of gas allowed to burn per contract')).or(zod.enum(['BalanceExceeded']).describe('Exceeded the account balance')).or(zod.enum(['EmptyMethodName']).describe('Tried to call an empty method name')).or(zod.object({
  "GuestPanic": zod.object({
  "panic_msg": zod.string()
})
}).describe('Smart contract panicked')).or(zod.enum(['IntegerOverflow']).describe('IntegerOverflow happened during a contract execution')).or(zod.object({
  "InvalidPromiseIndex": zod.object({
  "promise_idx": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMinOne)
})
}).describe('`promise_idx` does not correspond to existing promises')).or(zod.enum(['CannotAppendActionToJointPromise']).describe('Actions can only be appended to non-joint promise.')).or(zod.enum(['CannotReturnJointPromise']).describe('Returning joint promise is currently prohibited')).or(zod.object({
  "InvalidPromiseResultIndex": zod.object({
  "result_idx": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMinOne)
})
}).describe('Accessed invalid promise result index')).or(zod.object({
  "InvalidRegisterId": zod.object({
  "register_id": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMinOne)
})
}).describe('Accessed invalid register id')).or(zod.object({
  "IteratorWasInvalidated": zod.object({
  "iterator_index": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMinOne)
})
}).describe('Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie')).or(zod.enum(['MemoryAccessViolation']).describe('Accessed memory outside the bounds')).or(zod.object({
  "InvalidReceiptIndex": zod.object({
  "receipt_index": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMinOne)
})
}).describe('VM Logic returned an invalid receipt index')).or(zod.object({
  "InvalidIteratorIndex": zod.object({
  "iterator_index": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMinOne)
})
}).describe('Iterator index `iterator_index` does not exist')).or(zod.enum(['InvalidAccountId']).describe('VM Logic returned an invalid account id')).or(zod.enum(['InvalidMethodName']).describe('VM Logic returned an invalid method name')).or(zod.enum(['InvalidPublicKey']).describe('VM Logic provided an invalid public key')).or(zod.object({
  "ProhibitedInView": zod.object({
  "method_name": zod.string()
})
}).describe('`method_name` is not allowed in view calls')).or(zod.object({
  "NumberOfLogsExceeded": zod.object({
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMinOne)
})
}).describe('The total number of logs will exceed the limit.')).or(zod.object({
  "KeyLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMinOne),
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMinOne)
})
}).describe('The storage key length exceeded the limit.')).or(zod.object({
  "ValueLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMinOne),
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMinOne)
})
}).describe('The storage value length exceeded the limit.')).or(zod.object({
  "TotalLogLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMinOne),
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMinOne)
})
}).describe('The total log length exceeded the limit.')).or(zod.object({
  "NumberPromisesExceeded": zod.object({
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMinOne),
  "number_of_promises": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMinOne)
})
}).describe('The maximum number of promises within a FunctionCall exceeded the limit.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMinOne),
  "number_of_input_data_dependencies": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne)
})
}).describe('The maximum number of input data dependencies exceeded the limit.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMinOne),
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMinOne)
})
}).describe('The returned value length exceeded the limit.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMinOne),
  "size": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMinOne)
})
}).describe('The contract size for DeployContract action exceeded the limit.')).or(zod.object({
  "Deprecated": zod.object({
  "method_name": zod.string()
})
}).describe('The host function was deprecated.')).or(zod.object({
  "ECRecoverError": zod.object({
  "msg": zod.string()
})
}).describe('General errors for ECDSA recover.')).or(zod.object({
  "AltBn128InvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to alt_bn128 family of functions (e.g., point which isn\'t\n on the curve).')).or(zod.object({
  "Ed25519VerifyInvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to ed25519 signature verification function (e.g. signature cannot be\n derived from bytes).'))
}).describe('Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "ExecutionError": zod.string()
})).describe('Serializable version of `near-vm-runner::FunctionCallError`.\n\n Must never reorder/remove elements, can only add new variants at the end (but do that very\n carefully). It describes stable serialization format, and only used by serialization logic.')
}).describe('An error occurred during a `FunctionCall` Action, parameter is debug message.')).or(zod.object({
  "NewReceiptValidationError": zod.object({
  "InvalidPredecessorId": zod.object({
  "account_id": zod.string()
})
}).describe('The `predecessor_id` of a Receipt is not valid.').or(zod.object({
  "InvalidReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a Receipt is not valid.')).or(zod.object({
  "InvalidSignerId": zod.object({
  "account_id": zod.string()
})
}).describe('The `signer_id` of an ActionReceipt is not valid.')).or(zod.object({
  "InvalidDataReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a DataReceiver within an ActionReceipt is not valid.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMinOne),
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMinOne)
})
}).describe('The length of the returned data exceeded the limit in a DataReceipt.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMinOne),
  "number_of_input_data_dependencies": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne)
})
}).describe('The number of input data dependencies exceeds the limit in an ActionReceipt.')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMinOne),
  "total_prepaid_gas": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne),
  "total_number_of_actions": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne),
  "total_number_of_bytes": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMinOne),
  "size": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMinOne)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne),
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of an ActionReceipt.')).or(zod.object({
  "ReceiptSizeExceeded": zod.object({
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMinOne),
  "size": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMinOne)
})
}).describe('Receipt is bigger than the limit.')).describe('Describes the error for validating a receipt.')
}).describe('Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\n receipt validation.')).or(zod.object({
  "OnlyImplicitAccountCreationAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\n See NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\n Also, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\n TODO(#8598): This error is named very poorly. A better name would be\n `OnlyNamedAccountCreationAllowed`.')).or(zod.object({
  "DeleteAccountWithLargeState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Delete account whose state is large is temporarily banned.')).or(zod.enum(['DelegateActionInvalidSignature']).describe('Signature does not match the provided actions and given signer public key.')).or(zod.object({
  "DelegateActionSenderDoesNotMatchTxReceiver": zod.object({
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Receiver of the transaction doesn\'t match Sender of the delegate action')).or(zod.enum(['DelegateActionExpired']).describe('Delegate action has expired. `max_block_height` is less than actual block height.')).or(zod.object({
  "DelegateActionAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('The given public key doesn\'t exist for Sender account')).or(zod.object({
  "DelegateActionInvalidNonce": zod.object({
  "ak_nonce": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMinOne),
  "delegate_nonce": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMinOne)
})
}).describe('DelegateAction nonce must be greater sender[public_key].nonce')).or(zod.object({
  "DelegateActionNonceTooLarge": zod.object({
  "delegate_nonce": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMinOne),
  "upper_bound": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMinOne)
})
}).describe('DelegateAction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "GlobalContractDoesNotExist": zod.object({
  "identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
})
})).describe('The kind of ActionError happened')
}).describe('An error happened during Action execution')
}).describe('An error happened during Action execution').or(zod.object({
  "InvalidTxError": zod.object({
  "InvalidAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('Happens if a wrong AccessKey used or AccessKey has not enough permissions').or(zod.object({
  "InvalidSignerId": zod.object({
  "signer_id": zod.string()
})
}).describe('TX signer_id is not a valid [`AccountId`]')).or(zod.object({
  "SignerDoesNotExist": zod.object({
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('TX signer_id is not found in a storage')).or(zod.object({
  "InvalidNonce": zod.object({
  "ak_nonce": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorInvalidNonceAkNonceMinOne),
  "tx_nonce": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorInvalidNonceTxNonceMinOne)
})
}).describe('Transaction nonce must be strictly greater than `account[access_key].nonce`.')).or(zod.object({
  "NonceTooLarge": zod.object({
  "tx_nonce": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorNonceTooLargeTxNonceMinOne),
  "upper_bound": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMinOne)
})
}).describe('Transaction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "InvalidReceiverId": zod.object({
  "receiver_id": zod.string()
})
}).describe('TX receiver_id is not a valid AccountId')).or(zod.enum(['InvalidSignature']).describe('TX signature is not valid')).or(zod.object({
  "NotEnoughBalance": zod.object({
  "balance": zod.string(),
  "cost": zod.string(),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account does not have enough balance to cover TX cost')).or(zod.object({
  "LackBalanceForState": zod.object({
  "amount": zod.string().describe('Required balance to cover the state.'),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which doesn\'t have enough balance to cover storage.')
})
}).describe('Signer account doesn\'t have enough balance after transaction.')).or(zod.enum(['CostOverflow']).describe('An integer overflow occurred during transaction cost estimation.')).or(zod.enum(['InvalidChain']).describe('Transaction parent block hash doesn\'t belong to the current chain')).or(zod.enum(['Expired']).describe('Transaction has expired')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMinOne),
  "total_prepaid_gas": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne),
  "total_number_of_actions": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne),
  "total_number_of_bytes": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMinOne),
  "size": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMinOne)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne),
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of a Transaction.')).or(zod.object({
  "TransactionSizeExceeded": zod.object({
  "limit": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededLimitMinOne),
  "size": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededSizeMinOne)
})
}).describe('The size of serialized transaction exceeded the limit.')).or(zod.enum(['InvalidTransactionVersion']).describe('Transaction version is invalid.')).or(zod.object({
  "StorageError": zod.enum(['StorageInternalError']).describe('Key-value db internal failure').or(zod.object({
  "MissingTrieValue": zod.object({
  "context": zod.enum(['TrieIterator']).describe('Missing trie value when reading from TrieIterator.').or(zod.enum(['TriePrefetchingStorage']).describe('Missing trie value when reading from TriePrefetchingStorage.')).or(zod.enum(['TrieMemoryPartialStorage']).describe('Missing trie value when reading from TrieMemoryPartialStorage.')).or(zod.enum(['TrieStorage']).describe('Missing trie value when reading from TrieStorage.')).describe('Contexts in which `StorageError::MissingTrieValue` error might occur.'),
  "hash": zod.string()
})
}).describe('Requested trie value by its hash which is missing in storage.')).or(zod.enum(['UnexpectedTrieValue']).describe('Found trie node which shouldn\'t be part of state. Raised during\n validation of state sync parts where incorrect node was passed.\n TODO (#8997): consider including hash of trie node.')).or(zod.object({
  "StorageInconsistentState": zod.string()
}).describe('Either invalid state or key-value db is corrupted.\n For PartialStorage it cannot be corrupted.\n Error message is unreliable and for debugging purposes only. It\'s also probably ok to\n panic in every place that produces this error.\n We can check if db is corrupted by verifying everything in the state trie.')).or(zod.object({
  "FlatStorageBlockNotSupported": zod.string()
}).describe('Flat storage error, meaning that it doesn\'t support some block anymore.\n We guarantee that such block cannot become final, thus block processing\n must resume normally.')).or(zod.object({
  "MemTrieLoadingError": zod.string()
}).describe('In-memory trie could not be loaded for some reason.')).describe('Errors which may occur during working with trie storages, storing\n trie values (trie nodes and state values) by their hashes.')
})).or(zod.object({
  "ShardCongested": zod.object({
  "congestion_level": zod.number().describe('A value between 0 (no congestion) and 1 (max congestion).'),
  "shard_id": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardCongestedShardIdMinOne).describe('The congested shard.')
})
}).describe('The receiver shard of the transaction is too congested to accept new\n transactions at the moment.')).or(zod.object({
  "ShardStuck": zod.object({
  "missed_chunks": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardStuckMissedChunksMinOne).describe('The number of blocks since the last included chunk of the shard.'),
  "shard_id": zod.number().min(txResponseResultReceiptsOutcomeItemOutcomeStatusFailureInvalidTxErrorShardStuckShardIdMinOne).describe('The shard that fails making progress.')
})
}).describe('The receiver shard of the transaction missed several chunks and rejects\n new transaction until it can make progress again.')).describe('An error happened during TX execution')
}).describe('An error happened during Transaction execution')).describe('Error returned in the ExecutionOutcome in case of failure')
}).describe('The execution has failed.')).or(zod.object({
  "SuccessValue": zod.string()
}).describe('The final action succeeded and returned some value or an empty vec encoded in base64.')).or(zod.object({
  "SuccessReceiptId": zod.string()
}).describe('The final action of the receipt returned a promise or the signed transaction was converted\n to a receipt. Contains the receipt_id of the generated receipt.')).describe('Execution status. Contains the result in case of successful execution.'),
  "tokens_burnt": zod.string().describe('The amount of tokens burnt corresponding to the burnt gas amount.\n This value doesn\'t always equal to the `gas_burnt` multiplied by the gas price, because\n the prepaid gas price might be lower than the actual gas price and it creates a deficit.\n `tokens_burnt` also contains the penalty subtracted from refunds, while\n `gas_burnt` only contains the gas that we actually burn for the execution.')
}),
  "proof": zod.array(zod.object({
  "direction": zod.enum(['Left', 'Right']),
  "hash": zod.string()
}))
})).describe('The execution outcome of receipts.'),
  "status": zod.enum(['NotStarted']).describe('The execution has not yet started.').or(zod.enum(['Started']).describe('The execution has started and still going.')).or(zod.object({
  "Failure": zod.object({
  "ActionError": zod.object({
  "index": zod.number().min(txResponseResultStatusFailureActionErrorIndexMinOne).nullish().describe('Index of the failed action in the transaction.\n Action index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`'),
  "kind": zod.object({
  "AccountAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage').or(zod.object({
  "AccountDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when TX receiver_id doesn\'t exist (but action is not Action::CreateAccount)')).or(zod.object({
  "CreateAccountOnlyByRegistrar": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "registrar_account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A top-level account ID can only be created by registrar.')).or(zod.object({
  "CreateAccountNotAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A newly created account must be under a namespace of the creator account')).or(zod.object({
  "ActorNoPermission": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "actor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\n or the first TX action is a `CreateAccount` action')).or(zod.object({
  "DeleteKeyDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('Account tries to remove an access key that doesn\'t exist')).or(zod.object({
  "AddKeyAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The public key is already used for an existing access key')).or(zod.object({
  "DeleteAccountStaking": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is staking and can not be deleted')).or(zod.object({
  "LackBalanceForState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which needs balance'),
  "amount": zod.string().describe('Balance required to complete an action.')
})
}).describe('ActionReceipt can\'t be completed, because the remaining balance will not be enough to cover storage.')).or(zod.object({
  "TriesToUnstake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is not yet staked, but tries to unstake')).or(zod.object({
  "TriesToStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "balance": zod.string(),
  "locked": zod.string(),
  "stake": zod.string()
})
}).describe('The account doesn\'t have enough balance to increase the stake.')).or(zod.object({
  "InsufficientStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "minimum_stake": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "FunctionCallError": zod.enum(['WasmUnknownError', '_EVMError']).or(zod.object({
  "CompilationError": zod.object({
  "CodeDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).or(zod.object({
  "PrepareError": zod.enum(['Serialization']).describe('Error happened while serializing the module.').or(zod.enum(['Deserialization']).describe('Error happened while deserializing the module.')).or(zod.enum(['InternalMemoryDeclared']).describe('Internal memory declaration has been found in the module.')).or(zod.enum(['GasInstrumentation']).describe('Gas instrumentation failed.\n\n This most likely indicates the module isn\'t valid.')).or(zod.enum(['StackHeightInstrumentation']).describe('Stack instrumentation failed.\n\n This  most likely indicates the module isn\'t valid.')).or(zod.enum(['Instantiate']).describe('Error happened during instantiation.\n\n This might indicate that `start` function trapped, or module isn\'t\n instantiable and/or un-linkable.')).or(zod.enum(['Memory']).describe('Error creating memory.')).or(zod.enum(['TooManyFunctions']).describe('Contract contains too many functions.')).or(zod.enum(['TooManyLocals']).describe('Contract contains too many locals.')).describe('Error that can occur while preparing or executing Wasm smart-contract.')
})).or(zod.object({
  "WasmerCompileError": zod.object({
  "msg": zod.string()
})
}).describe('This is for defense in depth.\n We expect our runtime-independent preparation code to fully catch all invalid wasms,\n but, if it ever misses something we‚Äôll emit this error'))
}).describe('Wasm compilation error')).or(zod.object({
  "LinkError": zod.object({
  "msg": zod.string()
})
}).describe('Wasm binary env link error\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "MethodResolveError": zod.enum(['MethodEmptyName', 'MethodNotFound', 'MethodInvalidSignature'])
}).describe('Import/export resolve error')).or(zod.object({
  "WasmTrap": zod.enum(['Unreachable']).describe('An `unreachable` opcode was executed.').or(zod.enum(['IncorrectCallIndirectSignature']).describe('Call indirect incorrect signature trap.')).or(zod.enum(['MemoryOutOfBounds']).describe('Memory out of bounds trap.')).or(zod.enum(['CallIndirectOOB']).describe('Call indirect out of bounds trap.')).or(zod.enum(['IllegalArithmetic']).describe('An arithmetic exception, e.g. divided by zero.')).or(zod.enum(['MisalignedAtomicAccess']).describe('Misaligned atomic access trap.')).or(zod.enum(['IndirectCallToNull']).describe('Indirect call to null.')).or(zod.enum(['StackOverflow']).describe('Stack overflow.')).or(zod.enum(['GenericTrap']).describe('Generic trap.')).describe('A kind of a trap happened during execution of a binary')
}).describe('A trap happened during execution of a binary\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "HostError": zod.enum(['BadUTF16']).describe('String encoding is bad UTF-16 sequence').or(zod.enum(['BadUTF8']).describe('String encoding is bad UTF-8 sequence')).or(zod.enum(['GasExceeded']).describe('Exceeded the prepaid gas')).or(zod.enum(['GasLimitExceeded']).describe('Exceeded the maximum amount of gas allowed to burn per contract')).or(zod.enum(['BalanceExceeded']).describe('Exceeded the account balance')).or(zod.enum(['EmptyMethodName']).describe('Tried to call an empty method name')).or(zod.object({
  "GuestPanic": zod.object({
  "panic_msg": zod.string()
})
}).describe('Smart contract panicked')).or(zod.enum(['IntegerOverflow']).describe('IntegerOverflow happened during a contract execution')).or(zod.object({
  "InvalidPromiseIndex": zod.object({
  "promise_idx": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMinOne)
})
}).describe('`promise_idx` does not correspond to existing promises')).or(zod.enum(['CannotAppendActionToJointPromise']).describe('Actions can only be appended to non-joint promise.')).or(zod.enum(['CannotReturnJointPromise']).describe('Returning joint promise is currently prohibited')).or(zod.object({
  "InvalidPromiseResultIndex": zod.object({
  "result_idx": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMinOne)
})
}).describe('Accessed invalid promise result index')).or(zod.object({
  "InvalidRegisterId": zod.object({
  "register_id": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMinOne)
})
}).describe('Accessed invalid register id')).or(zod.object({
  "IteratorWasInvalidated": zod.object({
  "iterator_index": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMinOne)
})
}).describe('Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie')).or(zod.enum(['MemoryAccessViolation']).describe('Accessed memory outside the bounds')).or(zod.object({
  "InvalidReceiptIndex": zod.object({
  "receipt_index": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMinOne)
})
}).describe('VM Logic returned an invalid receipt index')).or(zod.object({
  "InvalidIteratorIndex": zod.object({
  "iterator_index": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMinOne)
})
}).describe('Iterator index `iterator_index` does not exist')).or(zod.enum(['InvalidAccountId']).describe('VM Logic returned an invalid account id')).or(zod.enum(['InvalidMethodName']).describe('VM Logic returned an invalid method name')).or(zod.enum(['InvalidPublicKey']).describe('VM Logic provided an invalid public key')).or(zod.object({
  "ProhibitedInView": zod.object({
  "method_name": zod.string()
})
}).describe('`method_name` is not allowed in view calls')).or(zod.object({
  "NumberOfLogsExceeded": zod.object({
  "limit": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMinOne)
})
}).describe('The total number of logs will exceed the limit.')).or(zod.object({
  "KeyLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMinOne),
  "limit": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMinOne)
})
}).describe('The storage key length exceeded the limit.')).or(zod.object({
  "ValueLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMinOne),
  "limit": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMinOne)
})
}).describe('The storage value length exceeded the limit.')).or(zod.object({
  "TotalLogLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMinOne),
  "limit": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMinOne)
})
}).describe('The total log length exceeded the limit.')).or(zod.object({
  "NumberPromisesExceeded": zod.object({
  "limit": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMinOne),
  "number_of_promises": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMinOne)
})
}).describe('The maximum number of promises within a FunctionCall exceeded the limit.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMinOne),
  "number_of_input_data_dependencies": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne)
})
}).describe('The maximum number of input data dependencies exceeded the limit.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMinOne),
  "limit": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMinOne)
})
}).describe('The returned value length exceeded the limit.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMinOne),
  "size": zod.number().min(txResponseResultStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMinOne)
})
}).describe('The contract size for DeployContract action exceeded the limit.')).or(zod.object({
  "Deprecated": zod.object({
  "method_name": zod.string()
})
}).describe('The host function was deprecated.')).or(zod.object({
  "ECRecoverError": zod.object({
  "msg": zod.string()
})
}).describe('General errors for ECDSA recover.')).or(zod.object({
  "AltBn128InvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to alt_bn128 family of functions (e.g., point which isn\'t\n on the curve).')).or(zod.object({
  "Ed25519VerifyInvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to ed25519 signature verification function (e.g. signature cannot be\n derived from bytes).'))
}).describe('Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "ExecutionError": zod.string()
})).describe('Serializable version of `near-vm-runner::FunctionCallError`.\n\n Must never reorder/remove elements, can only add new variants at the end (but do that very\n carefully). It describes stable serialization format, and only used by serialization logic.')
}).describe('An error occurred during a `FunctionCall` Action, parameter is debug message.')).or(zod.object({
  "NewReceiptValidationError": zod.object({
  "InvalidPredecessorId": zod.object({
  "account_id": zod.string()
})
}).describe('The `predecessor_id` of a Receipt is not valid.').or(zod.object({
  "InvalidReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a Receipt is not valid.')).or(zod.object({
  "InvalidSignerId": zod.object({
  "account_id": zod.string()
})
}).describe('The `signer_id` of an ActionReceipt is not valid.')).or(zod.object({
  "InvalidDataReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a DataReceiver within an ActionReceipt is not valid.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMinOne),
  "limit": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMinOne)
})
}).describe('The length of the returned data exceeded the limit in a DataReceipt.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMinOne),
  "number_of_input_data_dependencies": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne)
})
}).describe('The number of input data dependencies exceeds the limit in an ActionReceipt.')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMinOne),
  "total_prepaid_gas": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne),
  "total_number_of_actions": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne),
  "total_number_of_bytes": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMinOne),
  "size": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMinOne)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne),
  "limit": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of an ActionReceipt.')).or(zod.object({
  "ReceiptSizeExceeded": zod.object({
  "limit": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMinOne),
  "size": zod.number().min(txResponseResultStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMinOne)
})
}).describe('Receipt is bigger than the limit.')).describe('Describes the error for validating a receipt.')
}).describe('Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\n receipt validation.')).or(zod.object({
  "OnlyImplicitAccountCreationAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\n See NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\n Also, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\n TODO(#8598): This error is named very poorly. A better name would be\n `OnlyNamedAccountCreationAllowed`.')).or(zod.object({
  "DeleteAccountWithLargeState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Delete account whose state is large is temporarily banned.')).or(zod.enum(['DelegateActionInvalidSignature']).describe('Signature does not match the provided actions and given signer public key.')).or(zod.object({
  "DelegateActionSenderDoesNotMatchTxReceiver": zod.object({
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Receiver of the transaction doesn\'t match Sender of the delegate action')).or(zod.enum(['DelegateActionExpired']).describe('Delegate action has expired. `max_block_height` is less than actual block height.')).or(zod.object({
  "DelegateActionAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('The given public key doesn\'t exist for Sender account')).or(zod.object({
  "DelegateActionInvalidNonce": zod.object({
  "ak_nonce": zod.number().min(txResponseResultStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMinOne),
  "delegate_nonce": zod.number().min(txResponseResultStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMinOne)
})
}).describe('DelegateAction nonce must be greater sender[public_key].nonce')).or(zod.object({
  "DelegateActionNonceTooLarge": zod.object({
  "delegate_nonce": zod.number().min(txResponseResultStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMinOne),
  "upper_bound": zod.number().min(txResponseResultStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMinOne)
})
}).describe('DelegateAction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "GlobalContractDoesNotExist": zod.object({
  "identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
})
})).describe('The kind of ActionError happened')
}).describe('An error happened during Action execution')
}).describe('An error happened during Action execution').or(zod.object({
  "InvalidTxError": zod.object({
  "InvalidAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('Happens if a wrong AccessKey used or AccessKey has not enough permissions').or(zod.object({
  "InvalidSignerId": zod.object({
  "signer_id": zod.string()
})
}).describe('TX signer_id is not a valid [`AccountId`]')).or(zod.object({
  "SignerDoesNotExist": zod.object({
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('TX signer_id is not found in a storage')).or(zod.object({
  "InvalidNonce": zod.object({
  "ak_nonce": zod.number().min(txResponseResultStatusFailureInvalidTxErrorInvalidNonceAkNonceMinOne),
  "tx_nonce": zod.number().min(txResponseResultStatusFailureInvalidTxErrorInvalidNonceTxNonceMinOne)
})
}).describe('Transaction nonce must be strictly greater than `account[access_key].nonce`.')).or(zod.object({
  "NonceTooLarge": zod.object({
  "tx_nonce": zod.number().min(txResponseResultStatusFailureInvalidTxErrorNonceTooLargeTxNonceMinOne),
  "upper_bound": zod.number().min(txResponseResultStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMinOne)
})
}).describe('Transaction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "InvalidReceiverId": zod.object({
  "receiver_id": zod.string()
})
}).describe('TX receiver_id is not a valid AccountId')).or(zod.enum(['InvalidSignature']).describe('TX signature is not valid')).or(zod.object({
  "NotEnoughBalance": zod.object({
  "balance": zod.string(),
  "cost": zod.string(),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account does not have enough balance to cover TX cost')).or(zod.object({
  "LackBalanceForState": zod.object({
  "amount": zod.string().describe('Required balance to cover the state.'),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which doesn\'t have enough balance to cover storage.')
})
}).describe('Signer account doesn\'t have enough balance after transaction.')).or(zod.enum(['CostOverflow']).describe('An integer overflow occurred during transaction cost estimation.')).or(zod.enum(['InvalidChain']).describe('Transaction parent block hash doesn\'t belong to the current chain')).or(zod.enum(['Expired']).describe('Transaction has expired')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(txResponseResultStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMinOne),
  "total_prepaid_gas": zod.number().min(txResponseResultStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(txResponseResultStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne),
  "total_number_of_actions": zod.number().min(txResponseResultStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(txResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne),
  "total_number_of_bytes": zod.number().min(txResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(txResponseResultStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(txResponseResultStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMinOne),
  "size": zod.number().min(txResponseResultStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMinOne)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(txResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne),
  "limit": zod.number().min(txResponseResultStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(txResponseResultStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of a Transaction.')).or(zod.object({
  "TransactionSizeExceeded": zod.object({
  "limit": zod.number().min(txResponseResultStatusFailureInvalidTxErrorTransactionSizeExceededLimitMinOne),
  "size": zod.number().min(txResponseResultStatusFailureInvalidTxErrorTransactionSizeExceededSizeMinOne)
})
}).describe('The size of serialized transaction exceeded the limit.')).or(zod.enum(['InvalidTransactionVersion']).describe('Transaction version is invalid.')).or(zod.object({
  "StorageError": zod.enum(['StorageInternalError']).describe('Key-value db internal failure').or(zod.object({
  "MissingTrieValue": zod.object({
  "context": zod.enum(['TrieIterator']).describe('Missing trie value when reading from TrieIterator.').or(zod.enum(['TriePrefetchingStorage']).describe('Missing trie value when reading from TriePrefetchingStorage.')).or(zod.enum(['TrieMemoryPartialStorage']).describe('Missing trie value when reading from TrieMemoryPartialStorage.')).or(zod.enum(['TrieStorage']).describe('Missing trie value when reading from TrieStorage.')).describe('Contexts in which `StorageError::MissingTrieValue` error might occur.'),
  "hash": zod.string()
})
}).describe('Requested trie value by its hash which is missing in storage.')).or(zod.enum(['UnexpectedTrieValue']).describe('Found trie node which shouldn\'t be part of state. Raised during\n validation of state sync parts where incorrect node was passed.\n TODO (#8997): consider including hash of trie node.')).or(zod.object({
  "StorageInconsistentState": zod.string()
}).describe('Either invalid state or key-value db is corrupted.\n For PartialStorage it cannot be corrupted.\n Error message is unreliable and for debugging purposes only. It\'s also probably ok to\n panic in every place that produces this error.\n We can check if db is corrupted by verifying everything in the state trie.')).or(zod.object({
  "FlatStorageBlockNotSupported": zod.string()
}).describe('Flat storage error, meaning that it doesn\'t support some block anymore.\n We guarantee that such block cannot become final, thus block processing\n must resume normally.')).or(zod.object({
  "MemTrieLoadingError": zod.string()
}).describe('In-memory trie could not be loaded for some reason.')).describe('Errors which may occur during working with trie storages, storing\n trie values (trie nodes and state values) by their hashes.')
})).or(zod.object({
  "ShardCongested": zod.object({
  "congestion_level": zod.number().describe('A value between 0 (no congestion) and 1 (max congestion).'),
  "shard_id": zod.number().min(txResponseResultStatusFailureInvalidTxErrorShardCongestedShardIdMinOne).describe('The congested shard.')
})
}).describe('The receiver shard of the transaction is too congested to accept new\n transactions at the moment.')).or(zod.object({
  "ShardStuck": zod.object({
  "missed_chunks": zod.number().min(txResponseResultStatusFailureInvalidTxErrorShardStuckMissedChunksMinOne).describe('The number of blocks since the last included chunk of the shard.'),
  "shard_id": zod.number().min(txResponseResultStatusFailureInvalidTxErrorShardStuckShardIdMinOne).describe('The shard that fails making progress.')
})
}).describe('The receiver shard of the transaction missed several chunks and rejects\n new transaction until it can make progress again.')).describe('An error happened during TX execution')
}).describe('An error happened during Transaction execution')).describe('Error returned in the ExecutionOutcome in case of failure')
}).describe('The execution has failed with the given error.')).or(zod.object({
  "SuccessValue": zod.string()
}).describe('The execution has succeeded and returned some value or an empty vec encoded in base64.')).describe('Execution status defined by chain.rs:get_final_transaction_result\n FinalExecutionStatus::NotStarted - the tx is not converted to the receipt yet\n FinalExecutionStatus::Started - we have at least 1 receipt, but the first leaf receipt_id (using dfs) hasn\'t finished the execution\n FinalExecutionStatus::Failure - the result of the first leaf receipt_id\n FinalExecutionStatus::SuccessValue - the result of the first leaf receipt_id'),
  "transaction": zod.object({
  "actions": zod.array(zod.enum(['CreateAccount']).or(zod.object({
  "DeployContract": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "FunctionCall": zod.object({
  "args": zod.string(),
  "deposit": zod.string(),
  "gas": zod.number().min(txResponseResultTransactionActionsItemFunctionCallGasMinOne),
  "method_name": zod.string()
})
})).or(zod.object({
  "Transfer": zod.object({
  "deposit": zod.string()
})
})).or(zod.object({
  "Stake": zod.object({
  "public_key": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "AddKey": zod.object({
  "access_key": zod.object({
  "nonce": zod.number().min(txResponseResultTransactionActionsItemAddKeyAccessKeyNonceMinOne),
  "permission": zod.enum(['FullAccess']).or(zod.object({
  "FunctionCall": zod.object({
  "allowance": zod.string().nullish(),
  "method_names": zod.array(zod.string()),
  "receiver_id": zod.string()
})
}))
}),
  "public_key": zod.string()
})
})).or(zod.object({
  "DeleteKey": zod.object({
  "public_key": zod.string()
})
})).or(zod.object({
  "DeleteAccount": zod.object({
  "beneficiary_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
})).or(zod.object({
  "Delegate": zod.object({
  "delegate_action": zod.object({
  "actions": zod.array(zod.object({
  "CreateAccount": zod.object({

}).describe('Create account action')
}).describe('Create an (sub)account using a transaction `receiver_id` as an ID for\n a new account ID must pass validation rules described here\n <http://nomicon.io/Primitives/Account.html>.').or(zod.object({
  "DeployContract": zod.object({
  "code": zod.string().describe('WebAssembly binary')
}).describe('Deploy contract action')
}).describe('Sets a Wasm code to a receiver_id')).or(zod.object({
  "FunctionCall": zod.object({
  "args": zod.string(),
  "deposit": zod.string(),
  "gas": zod.number().min(txResponseResultTransactionActionsItemDelegateDelegateActionActionsItemFunctionCallGasMinOne),
  "method_name": zod.string()
})
})).or(zod.object({
  "Transfer": zod.object({
  "deposit": zod.string()
})
})).or(zod.object({
  "Stake": zod.object({
  "public_key": zod.string().describe('Validator key which will be used to sign transactions on behalf of signer_id'),
  "stake": zod.string().describe('Amount of tokens to stake.')
}).describe('An action which stakes signer_id tokens and setup\'s validator public key')
})).or(zod.object({
  "AddKey": zod.object({
  "access_key": zod.object({
  "nonce": zod.number().min(txResponseResultTransactionActionsItemDelegateDelegateActionActionsItemAddKeyAccessKeyNonceMinOne).describe('Nonce for this access key, used for tx nonce generation. When access key is created, nonce\n is set to `(block_height - 1) * 1e6` to avoid tx hash collision on access key re-creation.\n See <https://github.com/near/nearcore/issues/3779> for more details.'),
  "permission": zod.object({
  "FunctionCall": zod.object({
  "allowance": zod.string().nullish().describe('Allowance is a balance limit to use by this access key to pay for function call gas and\n transaction fees. When this access key is used, both account balance and the allowance is\n decreased by the same value.\n `None` means unlimited allowance.\n NOTE: To change or increase the allowance, the old access key needs to be deleted and a new\n access key should be created.'),
  "method_names": zod.array(zod.string()).describe('A list of method names that can be used. The access key only allows transactions with the\n function call of one of the given method names.\n Empty list means any method name can be used.'),
  "receiver_id": zod.string().describe('The access key only allows transactions with the given receiver\'s account id.')
}).describe('Grants limited permission to make transactions with FunctionCallActions\n The permission can limit the allowed balance to be spent on the prepaid gas.\n It also restrict the account ID of the receiver for this function call.\n It also can restrict the method name for the allowed function calls.')
}).or(zod.enum(['FullAccess']).describe('Grants full access to the account.\n NOTE: It\'s used to replace account-level public keys.')).describe('Defines permissions for AccessKey').describe('Defines permissions for this access key.')
}).describe('Access key provides limited access to an account. Each access key belongs to some account and\n is identified by a unique (within the account) public key. One account may have large number of\n access keys. Access keys allow to act on behalf of the account by restricting transactions\n that can be issued.\n `account_id,public_key` is a key in the state').describe('An access key with the permission'),
  "public_key": zod.string().describe('A public key which will be associated with an access_key')
})
})).or(zod.object({
  "DeleteKey": zod.object({
  "public_key": zod.string().describe('A public key associated with the access_key to be deleted.')
})
})).or(zod.object({
  "DeleteAccount": zod.object({
  "beneficiary_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
})).or(zod.object({
  "Delegate": zod.object({
  "delegate_action": zod.any(),
  "signature": zod.string()
})
})).or(zod.object({
  "DeployGlobalContract": zod.object({
  "code": zod.string().describe('WebAssembly binary'),
  "deploy_mode": zod.enum(['CodeHash']).describe('Contract is deployed under its code hash.\n Users will be able reference it by that hash.\n This effectively makes the contract immutable.').or(zod.enum(['AccountId']).describe('Contract is deployed under the owner account id.\n Users will be able reference it by that account id.\n This allows the owner to update the contract for all its users.'))
}).describe('Deploy global contract action')
})).or(zod.object({
  "UseGlobalContract": zod.object({
  "contract_identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
}).describe('Use global contract action')
})).describe('This is Action which mustn\'t contain DelegateAction.\n\n This struct is needed to avoid the recursion when Action/DelegateAction is deserialized.\n\n Important: Don\'t make the inner Action public, this must only be constructed\n through the correct interface that ensures the inner Action is actually not\n a delegate action. That would break an assumption of this type, which we use\n in several places. For example, borsh de-/serialization relies on it. If the\n invariant is broken, we may end up with a `Transaction` or `Receipt` that we\n can serialize but deserializing it back causes a parsing error.')).describe('List of actions to be executed.\n\n With the meta transactions MVP defined in NEP-366, nested\n DelegateActions are not allowed. A separate type is used to enforce it.'),
  "max_block_height": zod.number().min(txResponseResultTransactionActionsItemDelegateDelegateActionMaxBlockHeightMinOne).describe('The maximal height of the block in the blockchain below which the given DelegateAction is valid.'),
  "nonce": zod.number().min(txResponseResultTransactionActionsItemDelegateDelegateActionNonceMinOne).describe('Nonce to ensure that the same delegate action is not sent twice by a\n relayer and should match for given account\'s `public_key`.\n After this action is processed it will increment.'),
  "public_key": zod.string().describe('Public key used to sign this delegated action.'),
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('Receiver of the delegated actions.'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('Signer of the delegated actions')
}).describe('This action allows to execute the inner actions behalf of the defined sender.'),
  "signature": zod.string()
})
})).or(zod.object({
  "DeployGlobalContract": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "DeployGlobalContractByAccountId": zod.object({
  "code": zod.string()
})
})).or(zod.object({
  "UseGlobalContract": zod.object({
  "code_hash": zod.string()
})
})).or(zod.object({
  "UseGlobalContractByAccountId": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}))),
  "hash": zod.string(),
  "nonce": zod.number().min(txResponseResultTransactionNonceMinOne),
  "priority_fee": zod.number().min(txResponseResultTransactionPriorityFeeMinOne).optional(),
  "public_key": zod.string(),
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "signature": zod.string(),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}).describe('Signed Transaction'),
  "transaction_outcome": zod.object({
  "block_hash": zod.string(),
  "id": zod.string(),
  "outcome": zod.object({
  "executor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('The id of the account on which the execution happens. For transaction this is signer_id,\n for receipt this is receiver_id.'),
  "gas_burnt": zod.number().min(txResponseResultTransactionOutcomeOutcomeGasBurntMinOne).describe('The amount of the gas burnt by the given transaction or receipt.'),
  "logs": zod.array(zod.string()).describe('Logs from this transaction or receipt.'),
  "metadata": zod.object({
  "gas_profile": zod.array(zod.object({
  "cost": zod.string(),
  "cost_category": zod.string(),
  "gas_used": zod.string()
})).nullish(),
  "version": zod.number().min(txResponseResultTransactionOutcomeOutcomeMetadataVersionMinOne)
}).default(txResponseResultTransactionOutcomeOutcomeMetadataDefaultTwo).describe('Execution metadata, versioned'),
  "receipt_ids": zod.array(zod.string()).describe('Receipt IDs generated by this transaction or receipt.'),
  "status": zod.enum(['Unknown']).describe('The execution is pending or unknown.').or(zod.object({
  "Failure": zod.object({
  "ActionError": zod.object({
  "index": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorIndexMinOne).nullish().describe('Index of the failed action in the transaction.\n Action index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`'),
  "kind": zod.object({
  "AccountAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage').or(zod.object({
  "AccountDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Happens when TX receiver_id doesn\'t exist (but action is not Action::CreateAccount)')).or(zod.object({
  "CreateAccountOnlyByRegistrar": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "registrar_account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A top-level account ID can only be created by registrar.')).or(zod.object({
  "CreateAccountNotAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "predecessor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('A newly created account must be under a namespace of the creator account')).or(zod.object({
  "ActorNoPermission": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "actor_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\n or the first TX action is a `CreateAccount` action')).or(zod.object({
  "DeleteKeyDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('Account tries to remove an access key that doesn\'t exist')).or(zod.object({
  "AddKeyAlreadyExists": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The public key is already used for an existing access key')).or(zod.object({
  "DeleteAccountStaking": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is staking and can not be deleted')).or(zod.object({
  "LackBalanceForState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which needs balance'),
  "amount": zod.string().describe('Balance required to complete an action.')
})
}).describe('ActionReceipt can\'t be completed, because the remaining balance will not be enough to cover storage.')).or(zod.object({
  "TriesToUnstake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account is not yet staked, but tries to unstake')).or(zod.object({
  "TriesToStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "balance": zod.string(),
  "locked": zod.string(),
  "stake": zod.string()
})
}).describe('The account doesn\'t have enough balance to increase the stake.')).or(zod.object({
  "InsufficientStake": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "minimum_stake": zod.string(),
  "stake": zod.string()
})
})).or(zod.object({
  "FunctionCallError": zod.enum(['WasmUnknownError', '_EVMError']).or(zod.object({
  "CompilationError": zod.object({
  "CodeDoesNotExist": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).or(zod.object({
  "PrepareError": zod.enum(['Serialization']).describe('Error happened while serializing the module.').or(zod.enum(['Deserialization']).describe('Error happened while deserializing the module.')).or(zod.enum(['InternalMemoryDeclared']).describe('Internal memory declaration has been found in the module.')).or(zod.enum(['GasInstrumentation']).describe('Gas instrumentation failed.\n\n This most likely indicates the module isn\'t valid.')).or(zod.enum(['StackHeightInstrumentation']).describe('Stack instrumentation failed.\n\n This  most likely indicates the module isn\'t valid.')).or(zod.enum(['Instantiate']).describe('Error happened during instantiation.\n\n This might indicate that `start` function trapped, or module isn\'t\n instantiable and/or un-linkable.')).or(zod.enum(['Memory']).describe('Error creating memory.')).or(zod.enum(['TooManyFunctions']).describe('Contract contains too many functions.')).or(zod.enum(['TooManyLocals']).describe('Contract contains too many locals.')).describe('Error that can occur while preparing or executing Wasm smart-contract.')
})).or(zod.object({
  "WasmerCompileError": zod.object({
  "msg": zod.string()
})
}).describe('This is for defense in depth.\n We expect our runtime-independent preparation code to fully catch all invalid wasms,\n but, if it ever misses something we‚Äôll emit this error'))
}).describe('Wasm compilation error')).or(zod.object({
  "LinkError": zod.object({
  "msg": zod.string()
})
}).describe('Wasm binary env link error\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "MethodResolveError": zod.enum(['MethodEmptyName', 'MethodNotFound', 'MethodInvalidSignature'])
}).describe('Import/export resolve error')).or(zod.object({
  "WasmTrap": zod.enum(['Unreachable']).describe('An `unreachable` opcode was executed.').or(zod.enum(['IncorrectCallIndirectSignature']).describe('Call indirect incorrect signature trap.')).or(zod.enum(['MemoryOutOfBounds']).describe('Memory out of bounds trap.')).or(zod.enum(['CallIndirectOOB']).describe('Call indirect out of bounds trap.')).or(zod.enum(['IllegalArithmetic']).describe('An arithmetic exception, e.g. divided by zero.')).or(zod.enum(['MisalignedAtomicAccess']).describe('Misaligned atomic access trap.')).or(zod.enum(['IndirectCallToNull']).describe('Indirect call to null.')).or(zod.enum(['StackOverflow']).describe('Stack overflow.')).or(zod.enum(['GenericTrap']).describe('Generic trap.')).describe('A kind of a trap happened during execution of a binary')
}).describe('A trap happened during execution of a binary\n\n Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "HostError": zod.enum(['BadUTF16']).describe('String encoding is bad UTF-16 sequence').or(zod.enum(['BadUTF8']).describe('String encoding is bad UTF-8 sequence')).or(zod.enum(['GasExceeded']).describe('Exceeded the prepaid gas')).or(zod.enum(['GasLimitExceeded']).describe('Exceeded the maximum amount of gas allowed to burn per contract')).or(zod.enum(['BalanceExceeded']).describe('Exceeded the account balance')).or(zod.enum(['EmptyMethodName']).describe('Tried to call an empty method name')).or(zod.object({
  "GuestPanic": zod.object({
  "panic_msg": zod.string()
})
}).describe('Smart contract panicked')).or(zod.enum(['IntegerOverflow']).describe('IntegerOverflow happened during a contract execution')).or(zod.object({
  "InvalidPromiseIndex": zod.object({
  "promise_idx": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseIndexPromiseIdxMinOne)
})
}).describe('`promise_idx` does not correspond to existing promises')).or(zod.enum(['CannotAppendActionToJointPromise']).describe('Actions can only be appended to non-joint promise.')).or(zod.enum(['CannotReturnJointPromise']).describe('Returning joint promise is currently prohibited')).or(zod.object({
  "InvalidPromiseResultIndex": zod.object({
  "result_idx": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidPromiseResultIndexResultIdxMinOne)
})
}).describe('Accessed invalid promise result index')).or(zod.object({
  "InvalidRegisterId": zod.object({
  "register_id": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidRegisterIdRegisterIdMinOne)
})
}).describe('Accessed invalid register id')).or(zod.object({
  "IteratorWasInvalidated": zod.object({
  "iterator_index": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorIteratorWasInvalidatedIteratorIndexMinOne)
})
}).describe('Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie')).or(zod.enum(['MemoryAccessViolation']).describe('Accessed memory outside the bounds')).or(zod.object({
  "InvalidReceiptIndex": zod.object({
  "receipt_index": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidReceiptIndexReceiptIndexMinOne)
})
}).describe('VM Logic returned an invalid receipt index')).or(zod.object({
  "InvalidIteratorIndex": zod.object({
  "iterator_index": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorInvalidIteratorIndexIteratorIndexMinOne)
})
}).describe('Iterator index `iterator_index` does not exist')).or(zod.enum(['InvalidAccountId']).describe('VM Logic returned an invalid account id')).or(zod.enum(['InvalidMethodName']).describe('VM Logic returned an invalid method name')).or(zod.enum(['InvalidPublicKey']).describe('VM Logic provided an invalid public key')).or(zod.object({
  "ProhibitedInView": zod.object({
  "method_name": zod.string()
})
}).describe('`method_name` is not allowed in view calls')).or(zod.object({
  "NumberOfLogsExceeded": zod.object({
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberOfLogsExceededLimitMinOne)
})
}).describe('The total number of logs will exceed the limit.')).or(zod.object({
  "KeyLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLengthMinOne),
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorKeyLengthExceededLimitMinOne)
})
}).describe('The storage key length exceeded the limit.')).or(zod.object({
  "ValueLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLengthMinOne),
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorValueLengthExceededLimitMinOne)
})
}).describe('The storage value length exceeded the limit.')).or(zod.object({
  "TotalLogLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLengthMinOne),
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorTotalLogLengthExceededLimitMinOne)
})
}).describe('The total log length exceeded the limit.')).or(zod.object({
  "NumberPromisesExceeded": zod.object({
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededLimitMinOne),
  "number_of_promises": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberPromisesExceededNumberOfPromisesMinOne)
})
}).describe('The maximum number of promises within a FunctionCall exceeded the limit.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededLimitMinOne),
  "number_of_input_data_dependencies": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne)
})
}).describe('The maximum number of input data dependencies exceeded the limit.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLengthMinOne),
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorReturnedValueLengthExceededLimitMinOne)
})
}).describe('The returned value length exceeded the limit.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededLimitMinOne),
  "size": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindFunctionCallErrorHostErrorContractSizeExceededSizeMinOne)
})
}).describe('The contract size for DeployContract action exceeded the limit.')).or(zod.object({
  "Deprecated": zod.object({
  "method_name": zod.string()
})
}).describe('The host function was deprecated.')).or(zod.object({
  "ECRecoverError": zod.object({
  "msg": zod.string()
})
}).describe('General errors for ECDSA recover.')).or(zod.object({
  "AltBn128InvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to alt_bn128 family of functions (e.g., point which isn\'t\n on the curve).')).or(zod.object({
  "Ed25519VerifyInvalidInput": zod.object({
  "msg": zod.string()
})
}).describe('Invalid input to ed25519 signature verification function (e.g. signature cannot be\n derived from bytes).'))
}).describe('Note: this is only to deserialize old data, use execution error for new data')).or(zod.object({
  "ExecutionError": zod.string()
})).describe('Serializable version of `near-vm-runner::FunctionCallError`.\n\n Must never reorder/remove elements, can only add new variants at the end (but do that very\n carefully). It describes stable serialization format, and only used by serialization logic.')
}).describe('An error occurred during a `FunctionCall` Action, parameter is debug message.')).or(zod.object({
  "NewReceiptValidationError": zod.object({
  "InvalidPredecessorId": zod.object({
  "account_id": zod.string()
})
}).describe('The `predecessor_id` of a Receipt is not valid.').or(zod.object({
  "InvalidReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a Receipt is not valid.')).or(zod.object({
  "InvalidSignerId": zod.object({
  "account_id": zod.string()
})
}).describe('The `signer_id` of an ActionReceipt is not valid.')).or(zod.object({
  "InvalidDataReceiverId": zod.object({
  "account_id": zod.string()
})
}).describe('The `receiver_id` of a DataReceiver within an ActionReceipt is not valid.')).or(zod.object({
  "ReturnedValueLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLengthMinOne),
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReturnedValueLengthExceededLimitMinOne)
})
}).describe('The length of the returned data exceeded the limit in a DataReceipt.')).or(zod.object({
  "NumberInputDataDependenciesExceeded": zod.object({
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededLimitMinOne),
  "number_of_input_data_dependencies": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorNumberInputDataDependenciesExceededNumberOfInputDataDependenciesMinOne)
})
}).describe('The number of input data dependencies exceeds the limit in an ActionReceipt.')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededLimitMinOne),
  "total_prepaid_gas": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne),
  "total_number_of_actions": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne),
  "total_number_of_bytes": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededLimitMinOne),
  "size": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationContractSizeExceededSizeMinOne)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne),
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of an ActionReceipt.')).or(zod.object({
  "ReceiptSizeExceeded": zod.object({
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededLimitMinOne),
  "size": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindNewReceiptValidationErrorReceiptSizeExceededSizeMinOne)
})
}).describe('Receipt is bigger than the limit.')).describe('Describes the error for validating a receipt.')
}).describe('Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\n receipt validation.')).or(zod.object({
  "OnlyImplicitAccountCreationAllowed": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\n See NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\n Also, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\n TODO(#8598): This error is named very poorly. A better name would be\n `OnlyNamedAccountCreationAllowed`.')).or(zod.object({
  "DeleteAccountWithLargeState": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Delete account whose state is large is temporarily banned.')).or(zod.enum(['DelegateActionInvalidSignature']).describe('Signature does not match the provided actions and given signer public key.')).or(zod.object({
  "DelegateActionSenderDoesNotMatchTxReceiver": zod.object({
  "receiver_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "sender_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Receiver of the transaction doesn\'t match Sender of the delegate action')).or(zod.enum(['DelegateActionExpired']).describe('Delegate action has expired. `max_block_height` is less than actual block height.')).or(zod.object({
  "DelegateActionAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('The given public key doesn\'t exist for Sender account')).or(zod.object({
  "DelegateActionInvalidNonce": zod.object({
  "ak_nonce": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceAkNonceMinOne),
  "delegate_nonce": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionInvalidNonceDelegateNonceMinOne)
})
}).describe('DelegateAction nonce must be greater sender[public_key].nonce')).or(zod.object({
  "DelegateActionNonceTooLarge": zod.object({
  "delegate_nonce": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeDelegateNonceMinOne),
  "upper_bound": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureActionErrorKindDelegateActionNonceTooLargeUpperBoundMinOne)
})
}).describe('DelegateAction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "GlobalContractDoesNotExist": zod.object({
  "identifier": zod.object({
  "CodeHash": zod.string()
}).or(zod.object({
  "AccountId": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
}))
})
})).describe('The kind of ActionError happened')
}).describe('An error happened during Action execution')
}).describe('An error happened during Action execution').or(zod.object({
  "InvalidTxError": zod.object({
  "InvalidAccessKeyError": zod.object({
  "AccessKeyNotFound": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string()
})
}).describe('The access key identified by the `public_key` doesn\'t exist for the account').or(zod.object({
  "ReceiverMismatch": zod.object({
  "ak_receiver": zod.string(),
  "tx_receiver": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Transaction `receiver_id` doesn\'t match the access key receiver_id')).or(zod.object({
  "MethodNameMismatch": zod.object({
  "method_name": zod.string()
})
}).describe('Transaction method name isn\'t allowed by the access key')).or(zod.enum(['RequiresFullAccess']).describe('Transaction requires a full permission access key.')).or(zod.object({
  "NotEnoughAllowance": zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "allowance": zod.string(),
  "cost": zod.string(),
  "public_key": zod.string()
})
}).describe('Access Key does not have enough allowance to cover transaction cost')).or(zod.enum(['DepositWithFunctionCall']).describe('Having a deposit with a function call action is not allowed with a function call access key.'))
}).describe('Happens if a wrong AccessKey used or AccessKey has not enough permissions').or(zod.object({
  "InvalidSignerId": zod.object({
  "signer_id": zod.string()
})
}).describe('TX signer_id is not a valid [`AccountId`]')).or(zod.object({
  "SignerDoesNotExist": zod.object({
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('TX signer_id is not found in a storage')).or(zod.object({
  "InvalidNonce": zod.object({
  "ak_nonce": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorInvalidNonceAkNonceMinOne),
  "tx_nonce": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorInvalidNonceTxNonceMinOne)
})
}).describe('Transaction nonce must be strictly greater than `account[access_key].nonce`.')).or(zod.object({
  "NonceTooLarge": zod.object({
  "tx_nonce": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorNonceTooLargeTxNonceMinOne),
  "upper_bound": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorNonceTooLargeUpperBoundMinOne)
})
}).describe('Transaction nonce is larger than the upper bound given by the block height')).or(zod.object({
  "InvalidReceiverId": zod.object({
  "receiver_id": zod.string()
})
}).describe('TX receiver_id is not a valid AccountId')).or(zod.enum(['InvalidSignature']).describe('TX signature is not valid')).or(zod.object({
  "NotEnoughBalance": zod.object({
  "balance": zod.string(),
  "cost": zod.string(),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```')
})
}).describe('Account does not have enough balance to cover TX cost')).or(zod.object({
  "LackBalanceForState": zod.object({
  "amount": zod.string().describe('Required balance to cover the state.'),
  "signer_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```').describe('An account which doesn\'t have enough balance to cover storage.')
})
}).describe('Signer account doesn\'t have enough balance after transaction.')).or(zod.enum(['CostOverflow']).describe('An integer overflow occurred during transaction cost estimation.')).or(zod.enum(['InvalidChain']).describe('Transaction parent block hash doesn\'t belong to the current chain')).or(zod.enum(['Expired']).describe('Transaction has expired')).or(zod.object({
  "ActionsValidation": zod.enum(['DeleteActionMustBeFinal']).describe('The delete action must be a final action in transaction').or(zod.object({
  "TotalPrepaidGasExceeded": zod.object({
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededLimitMinOne),
  "total_prepaid_gas": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalPrepaidGasExceededTotalPrepaidGasMinOne)
})
}).describe('The total prepaid gas (for all given actions) exceeded the limit.')).or(zod.object({
  "TotalNumberOfActionsExceeded": zod.object({
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededLimitMinOne),
  "total_number_of_actions": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationTotalNumberOfActionsExceededTotalNumberOfActionsMinOne)
})
}).describe('The number of actions exceeded the given limit.')).or(zod.object({
  "AddKeyMethodNamesNumberOfBytesExceeded": zod.object({
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededLimitMinOne),
  "total_number_of_bytes": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNamesNumberOfBytesExceededTotalNumberOfBytesMinOne)
})
}).describe('The total number of bytes of the method names exceeded the limit in a Add Key action.')).or(zod.object({
  "AddKeyMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationAddKeyMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of some method name exceeded the limit in a Add Key action.')).or(zod.enum(['IntegerOverflow']).describe('Integer overflow during a compute.')).or(zod.object({
  "InvalidAccountId": zod.object({
  "account_id": zod.string()
})
}).describe('Invalid account ID.')).or(zod.object({
  "ContractSizeExceeded": zod.object({
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededLimitMinOne),
  "size": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationContractSizeExceededSizeMinOne)
})
}).describe('The size of the contract code exceeded the limit in a DeployContract action.')).or(zod.object({
  "FunctionCallMethodNameLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLengthMinOne),
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallMethodNameLengthExceededLimitMinOne)
})
}).describe('The length of the method name exceeded the limit in a Function Call action.')).or(zod.object({
  "FunctionCallArgumentsLengthExceeded": zod.object({
  "length": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLengthMinOne),
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationFunctionCallArgumentsLengthExceededLimitMinOne)
})
}).describe('The length of the arguments exceeded the limit in a Function Call action.')).or(zod.object({
  "UnsuitableStakingKey": zod.object({
  "public_key": zod.string()
})
}).describe('An attempt to stake with a public key that is not convertible to ristretto.')).or(zod.enum(['FunctionCallZeroAttachedGas']).describe('The attached amount of gas in a FunctionCall action has to be a positive number.')).or(zod.enum(['DelegateActionMustBeOnlyOne']).describe('There should be the only one DelegateAction')).or(zod.object({
  "UnsupportedProtocolFeature": zod.object({
  "protocol_feature": zod.string(),
  "version": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorActionsValidationUnsupportedProtocolFeatureVersionMinOne)
})
}).describe('The transaction includes a feature that the current protocol version\n does not support.\n\n Note: we stringify the protocol feature name instead of using\n `ProtocolFeature` here because we don\'t want to leak the internals of\n that type into observable borsh serialization.')).describe('Describes the error for validating a list of actions.')
}).describe('An error occurred while validating actions of a Transaction.')).or(zod.object({
  "TransactionSizeExceeded": zod.object({
  "limit": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededLimitMinOne),
  "size": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorTransactionSizeExceededSizeMinOne)
})
}).describe('The size of serialized transaction exceeded the limit.')).or(zod.enum(['InvalidTransactionVersion']).describe('Transaction version is invalid.')).or(zod.object({
  "StorageError": zod.enum(['StorageInternalError']).describe('Key-value db internal failure').or(zod.object({
  "MissingTrieValue": zod.object({
  "context": zod.enum(['TrieIterator']).describe('Missing trie value when reading from TrieIterator.').or(zod.enum(['TriePrefetchingStorage']).describe('Missing trie value when reading from TriePrefetchingStorage.')).or(zod.enum(['TrieMemoryPartialStorage']).describe('Missing trie value when reading from TrieMemoryPartialStorage.')).or(zod.enum(['TrieStorage']).describe('Missing trie value when reading from TrieStorage.')).describe('Contexts in which `StorageError::MissingTrieValue` error might occur.'),
  "hash": zod.string()
})
}).describe('Requested trie value by its hash which is missing in storage.')).or(zod.enum(['UnexpectedTrieValue']).describe('Found trie node which shouldn\'t be part of state. Raised during\n validation of state sync parts where incorrect node was passed.\n TODO (#8997): consider including hash of trie node.')).or(zod.object({
  "StorageInconsistentState": zod.string()
}).describe('Either invalid state or key-value db is corrupted.\n For PartialStorage it cannot be corrupted.\n Error message is unreliable and for debugging purposes only. It\'s also probably ok to\n panic in every place that produces this error.\n We can check if db is corrupted by verifying everything in the state trie.')).or(zod.object({
  "FlatStorageBlockNotSupported": zod.string()
}).describe('Flat storage error, meaning that it doesn\'t support some block anymore.\n We guarantee that such block cannot become final, thus block processing\n must resume normally.')).or(zod.object({
  "MemTrieLoadingError": zod.string()
}).describe('In-memory trie could not be loaded for some reason.')).describe('Errors which may occur during working with trie storages, storing\n trie values (trie nodes and state values) by their hashes.')
})).or(zod.object({
  "ShardCongested": zod.object({
  "congestion_level": zod.number().describe('A value between 0 (no congestion) and 1 (max congestion).'),
  "shard_id": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardCongestedShardIdMinOne).describe('The congested shard.')
})
}).describe('The receiver shard of the transaction is too congested to accept new\n transactions at the moment.')).or(zod.object({
  "ShardStuck": zod.object({
  "missed_chunks": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardStuckMissedChunksMinOne).describe('The number of blocks since the last included chunk of the shard.'),
  "shard_id": zod.number().min(txResponseResultTransactionOutcomeOutcomeStatusFailureInvalidTxErrorShardStuckShardIdMinOne).describe('The shard that fails making progress.')
})
}).describe('The receiver shard of the transaction missed several chunks and rejects\n new transaction until it can make progress again.')).describe('An error happened during TX execution')
}).describe('An error happened during Transaction execution')).describe('Error returned in the ExecutionOutcome in case of failure')
}).describe('The execution has failed.')).or(zod.object({
  "SuccessValue": zod.string()
}).describe('The final action succeeded and returned some value or an empty vec encoded in base64.')).or(zod.object({
  "SuccessReceiptId": zod.string()
}).describe('The final action of the receipt returned a promise or the signed transaction was converted\n to a receipt. Contains the receipt_id of the generated receipt.')).describe('Execution status. Contains the result in case of successful execution.'),
  "tokens_burnt": zod.string().describe('The amount of tokens burnt corresponding to the burnt gas amount.\n This value doesn\'t always equal to the `gas_burnt` multiplied by the gas price, because\n the prepaid gas price might be lower than the actual gas price and it creates a deficit.\n `tokens_burnt` also contains the penalty subtracted from refunds, while\n `gas_burnt` only contains the gas that we actually burn for the execution.')
}),
  "proof": zod.array(zod.object({
  "direction": zod.enum(['Left', 'Right']),
  "hash": zod.string()
}))
}).describe('The execution outcome of the signed transaction.')
}).describe('Execution outcome of the transaction and all the subsequent receipts.\n Could be not finalized yet'))
}).or(zod.object({
  "error": zod.object({
  "cause": zod.object({
  "info": zod.object({
  "method_name": zod.string()
}),
  "name": zod.enum(['METHOD_NOT_FOUND'])
}).or(zod.object({
  "info": zod.object({
  "error_message": zod.string()
}),
  "name": zod.enum(['PARSE_ERROR'])
})),
  "name": zod.enum(['REQUEST_VALIDATION_ERROR'])
}).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['HANDLER_ERROR'])
})).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['INTERNAL_ERROR'])
})).describe('This struct may be returned from JSON RPC server in case of error\n It is expected that this struct has impl From<_> all other RPC errors\n like [RpcBlockError](crate::types::blocks::RpcBlockError)')
}))


export const validatorsBodyParamsBlockIdMinOne = 0;


export const validatorsBody = zod.object({
  "id": zod.string(),
  "jsonrpc": zod.string(),
  "method": zod.enum(['validators']),
  "params": zod.enum(['latest']).or(zod.object({
  "epoch_id": zod.string().describe('Epoch identifier -- wrapped hash, to make it easier to distinguish.\n EpochId of epoch T is the hash of last block in T-2\n EpochId of first two epochs is 0')
})).or(zod.object({
  "block_id": zod.number().min(validatorsBodyParamsBlockIdMinOne).or(zod.string())
}))
})

export const validatorsResponseResultCurrentValidatorsItemNumExpectedBlocksMin = 0;
export const validatorsResponseResultCurrentValidatorsItemNumExpectedChunksDefault = 0;
export const validatorsResponseResultCurrentValidatorsItemNumExpectedChunksMin = 0;
export const validatorsResponseResultCurrentValidatorsItemNumExpectedChunksPerShardItemMin = 0;
export const validatorsResponseResultCurrentValidatorsItemNumExpectedChunksPerShardDefault = [];export const validatorsResponseResultCurrentValidatorsItemNumExpectedEndorsementsDefault = 0;
export const validatorsResponseResultCurrentValidatorsItemNumExpectedEndorsementsMin = 0;
export const validatorsResponseResultCurrentValidatorsItemNumExpectedEndorsementsPerShardItemMin = 0;
export const validatorsResponseResultCurrentValidatorsItemNumExpectedEndorsementsPerShardDefault = [];export const validatorsResponseResultCurrentValidatorsItemNumProducedBlocksMin = 0;
export const validatorsResponseResultCurrentValidatorsItemNumProducedChunksDefault = 0;
export const validatorsResponseResultCurrentValidatorsItemNumProducedChunksMin = 0;
export const validatorsResponseResultCurrentValidatorsItemNumProducedChunksPerShardItemMin = 0;
export const validatorsResponseResultCurrentValidatorsItemNumProducedChunksPerShardDefault = [];export const validatorsResponseResultCurrentValidatorsItemNumProducedEndorsementsDefault = 0;
export const validatorsResponseResultCurrentValidatorsItemNumProducedEndorsementsMin = 0;
export const validatorsResponseResultCurrentValidatorsItemNumProducedEndorsementsPerShardItemMin = 0;
export const validatorsResponseResultCurrentValidatorsItemNumProducedEndorsementsPerShardDefault = [];export const validatorsResponseResultCurrentValidatorsItemShardsItemMin = 0;
export const validatorsResponseResultCurrentValidatorsItemShardsEndorsedItemMin = 0;
export const validatorsResponseResultCurrentValidatorsItemShardsEndorsedDefault = [];export const validatorsResponseResultEpochHeightMin = 0;
export const validatorsResponseResultEpochStartHeightMin = 0;
export const validatorsResponseResultNextValidatorsItemShardsItemMin = 0;
export const validatorsResponseResultPrevEpochKickoutItemReasonNotEnoughBlocksExpectedMin = 0;
export const validatorsResponseResultPrevEpochKickoutItemReasonNotEnoughBlocksProducedMin = 0;
export const validatorsResponseResultPrevEpochKickoutItemReasonNotEnoughChunksExpectedMin = 0;
export const validatorsResponseResultPrevEpochKickoutItemReasonNotEnoughChunksProducedMin = 0;
export const validatorsResponseResultPrevEpochKickoutItemReasonNotEnoughChunkEndorsementsExpectedMin = 0;
export const validatorsResponseResultPrevEpochKickoutItemReasonNotEnoughChunkEndorsementsProducedMin = 0;
export const validatorsResponseResultPrevEpochKickoutItemReasonProtocolVersionTooOldNetworkVersionMin = 0;
export const validatorsResponseResultPrevEpochKickoutItemReasonProtocolVersionTooOldVersionMin = 0;


export const validatorsResponse = zod.object({
  "result": zod.object({
  "current_fishermen": zod.array(zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string(),
  "stake": zod.string()
})).describe('Fishermen for the current epoch'),
  "current_proposals": zod.array(zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string(),
  "stake": zod.string()
})).describe('Proposals in the current epoch'),
  "current_validators": zod.array(zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "is_slashed": zod.boolean(),
  "num_expected_blocks": zod.number().min(validatorsResponseResultCurrentValidatorsItemNumExpectedBlocksMin),
  "num_expected_chunks": zod.number().min(validatorsResponseResultCurrentValidatorsItemNumExpectedChunksMin).optional(),
  "num_expected_chunks_per_shard": zod.array(zod.number().min(validatorsResponseResultCurrentValidatorsItemNumExpectedChunksPerShardItemMin)).default(validatorsResponseResultCurrentValidatorsItemNumExpectedChunksPerShardDefault).describe('Number of chunks this validator was expected to produce in each shard.\n Each entry in the array corresponds to the shard in the `shards_produced` array.'),
  "num_expected_endorsements": zod.number().min(validatorsResponseResultCurrentValidatorsItemNumExpectedEndorsementsMin).optional(),
  "num_expected_endorsements_per_shard": zod.array(zod.number().min(validatorsResponseResultCurrentValidatorsItemNumExpectedEndorsementsPerShardItemMin)).default(validatorsResponseResultCurrentValidatorsItemNumExpectedEndorsementsPerShardDefault).describe('Number of chunks this validator was expected to validate and endorse in each shard.\n Each entry in the array corresponds to the shard in the `shards_endorsed` array.'),
  "num_produced_blocks": zod.number().min(validatorsResponseResultCurrentValidatorsItemNumProducedBlocksMin),
  "num_produced_chunks": zod.number().min(validatorsResponseResultCurrentValidatorsItemNumProducedChunksMin).optional(),
  "num_produced_chunks_per_shard": zod.array(zod.number().min(validatorsResponseResultCurrentValidatorsItemNumProducedChunksPerShardItemMin)).default(validatorsResponseResultCurrentValidatorsItemNumProducedChunksPerShardDefault),
  "num_produced_endorsements": zod.number().min(validatorsResponseResultCurrentValidatorsItemNumProducedEndorsementsMin).optional(),
  "num_produced_endorsements_per_shard": zod.array(zod.number().min(validatorsResponseResultCurrentValidatorsItemNumProducedEndorsementsPerShardItemMin)).default(validatorsResponseResultCurrentValidatorsItemNumProducedEndorsementsPerShardDefault),
  "public_key": zod.string(),
  "shards": zod.array(zod.number().min(validatorsResponseResultCurrentValidatorsItemShardsItemMin).describe('The shard identifier. It may be an arbitrary number - it does not need to be\n a number in the range 0..NUM_SHARDS. The shard ids do not need to be\n sequential or contiguous.\n\n The shard id is wrapped in a new type to prevent the old pattern of using\n indices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\n if fully complete it potentially may be simplified to a regular type alias.')).describe('Shards this validator is assigned to as chunk producer in the current epoch.'),
  "shards_endorsed": zod.array(zod.number().min(validatorsResponseResultCurrentValidatorsItemShardsEndorsedItemMin).describe('The shard identifier. It may be an arbitrary number - it does not need to be\n a number in the range 0..NUM_SHARDS. The shard ids do not need to be\n sequential or contiguous.\n\n The shard id is wrapped in a new type to prevent the old pattern of using\n indices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\n if fully complete it potentially may be simplified to a regular type alias.')).default(validatorsResponseResultCurrentValidatorsItemShardsEndorsedDefault).describe('Shards this validator is assigned to as chunk validator in the current epoch.'),
  "stake": zod.string()
})).describe('Validators for the current epoch'),
  "epoch_height": zod.number().min(validatorsResponseResultEpochHeightMin).describe('Epoch height'),
  "epoch_start_height": zod.number().min(validatorsResponseResultEpochStartHeightMin).describe('Epoch start block height'),
  "next_fishermen": zod.array(zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string(),
  "stake": zod.string()
})).describe('Fishermen for the next epoch'),
  "next_validators": zod.array(zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "public_key": zod.string(),
  "shards": zod.array(zod.number().min(validatorsResponseResultNextValidatorsItemShardsItemMin).describe('The shard identifier. It may be an arbitrary number - it does not need to be\n a number in the range 0..NUM_SHARDS. The shard ids do not need to be\n sequential or contiguous.\n\n The shard id is wrapped in a new type to prevent the old pattern of using\n indices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\n if fully complete it potentially may be simplified to a regular type alias.')),
  "stake": zod.string()
})).describe('Validators for the next epoch'),
  "prev_epoch_kickout": zod.array(zod.object({
  "account_id": zod.string().describe('NEAR Account Identifier.\n\n This is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n [See the crate-level docs for information about validation.](index.html#account-id-rules)\n\n Also see [Error kind precedence](AccountId#error-kind-precedence).\n\n ## Examples\n\n ```\n use near_account_id::AccountId;\n\n let alice: AccountId = \"alice.near\".parse().unwrap();\n\n assert!(\"∆íelicia.near\".parse::<AccountId>().is_err()); // (∆í is not f)\n ```'),
  "reason": zod.enum(['_UnusedSlashed']).describe('Deprecated').or(zod.object({
  "NotEnoughBlocks": zod.object({
  "expected": zod.number().min(validatorsResponseResultPrevEpochKickoutItemReasonNotEnoughBlocksExpectedMin),
  "produced": zod.number().min(validatorsResponseResultPrevEpochKickoutItemReasonNotEnoughBlocksProducedMin)
})
}).describe('Validator didn\'t produce enough blocks.')).or(zod.object({
  "NotEnoughChunks": zod.object({
  "expected": zod.number().min(validatorsResponseResultPrevEpochKickoutItemReasonNotEnoughChunksExpectedMin),
  "produced": zod.number().min(validatorsResponseResultPrevEpochKickoutItemReasonNotEnoughChunksProducedMin)
})
}).describe('Validator didn\'t produce enough chunks.')).or(zod.enum(['Unstaked']).describe('Validator unstaked themselves.')).or(zod.object({
  "NotEnoughStake": zod.object({
  "stake_u128": zod.string(),
  "threshold_u128": zod.string()
})
}).describe('Validator stake is now below threshold')).or(zod.enum(['DidNotGetASeat']).describe('Enough stake but is not chosen because of seat limits.')).or(zod.object({
  "NotEnoughChunkEndorsements": zod.object({
  "expected": zod.number().min(validatorsResponseResultPrevEpochKickoutItemReasonNotEnoughChunkEndorsementsExpectedMin),
  "produced": zod.number().min(validatorsResponseResultPrevEpochKickoutItemReasonNotEnoughChunkEndorsementsProducedMin)
})
}).describe('Validator didn\'t produce enough chunk endorsements.')).or(zod.object({
  "ProtocolVersionTooOld": zod.object({
  "network_version": zod.number().min(validatorsResponseResultPrevEpochKickoutItemReasonProtocolVersionTooOldNetworkVersionMin),
  "version": zod.number().min(validatorsResponseResultPrevEpochKickoutItemReasonProtocolVersionTooOldVersionMin)
})
}).describe('Validator\'s last block proposal was for a protocol version older than\n the network\'s voted protocol version.')).describe('Reasons for removing a validator from the validator set.')
})).describe('Kickout in the previous epoch')
}).describe('Information about this epoch validators and next epoch validators')
}).or(zod.object({
  "error": zod.object({
  "cause": zod.object({
  "info": zod.object({
  "method_name": zod.string()
}),
  "name": zod.enum(['METHOD_NOT_FOUND'])
}).or(zod.object({
  "info": zod.object({
  "error_message": zod.string()
}),
  "name": zod.enum(['PARSE_ERROR'])
})),
  "name": zod.enum(['REQUEST_VALIDATION_ERROR'])
}).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['HANDLER_ERROR'])
})).or(zod.object({
  "cause": zod.any(),
  "name": zod.enum(['INTERNAL_ERROR'])
})).describe('This struct may be returned from JSON RPC server in case of error\n It is expected that this struct has impl From<_> all other RPC errors\n like [RpcBlockError](crate::types::blocks::RpcBlockError)')
}))


